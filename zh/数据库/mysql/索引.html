<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>索引 | 米二</title><meta name=keywords content=" **前言**, **一、MySQL中索引的语法**, **二、索引的优缺点**, **三、索引的分类**, **四、索引的实现原理**, **4.1、哈希索引**, **4.2、全文索引**, 五、索引数据结构, **5.1 BTree索引**, **5.2 B+Tree索引**"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E7%B4%A2%E5%BC%95.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E7%B4%A2%E5%BC%95.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="索引"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E7%B4%A2%E5%BC%95.html"><meta property="article:section" content="数据库"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-29T06:58:42+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="索引"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"索引","item":"https://xiaokunji.com/zh/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E7%B4%A2%E5%BC%95.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"索引","name":"索引","description":"     ","keywords":[" **前言**"," **一、MySQL中索引的语法**"," **二、索引的优缺点**"," **三、索引的分类**"," **四、索引的实现原理**"," **4.1、哈希索引**"," **4.2、全文索引**"," 五、索引数据结构"," **5.1 BTree索引**"," **5.2 B+Tree索引**"],"articleBody":"[toc]\n前言 说到索引，很多人都知道“索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。”\n但是索引是怎么实现的呢？因为索引并不是关系模型的组成部分，因此不同的DBMS有不同的实现，我们针对MySQL数据库的实现进行说明。\n一、MySQL中索引的语法 创建索引\n在创建表的时候添加索引\nCREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 在创建表以后添加索引\nALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);\n或者\nCREATE INDEX index_name ON my_table(column_name);\n注意：\n1、索引需要占用磁盘空间，因此在创建索引时要考虑到磁盘空间是否足够\n2、创建索引时需要对表加锁，因此实际操作中需要在业务空闲期间进行\n原文链接：https://blog.csdn.net/tongdanping/article/details/79878302\n删除索引\nDROP INDEX my_index ON tablename；\n或者\nALTER TABLE table_name DROP INDEX index_name;\n查看表中的索引\nSHOW INDEX FROM tablename\n查看查询语句使用索引的情况\nexplain SELECT * FROM table_name WHERE column_1='123'; 原文链接：https://blog.csdn.net/tongdanping/article/details/79878302\n二、索引的优缺点 优势：可以快速检索，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；\n劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；\n索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；\n构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；\n原文链接：https://blog.csdn.net/tongdanping/article/details/79878302\n三、索引的分类 常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引\n1、主键索引：即主索引，根据主键pk_clolum（length）建立索引，不允许重复，不允许空值；\nALTER TABLE ’table_name’ ADD PRIMARY KEY pk_index(‘col’)；\n2、唯一索引：用来建立索引的列的值必须是唯一的，允许空值\nALTER TABLE ’table_name’ ADD UNIQUE index_name(‘col’)；\n3、普通索引：用表中的普通列构建的索引，没有任何限制\nALTER TABLE ’table_name’ ADD INDEX index_name(‘col’)；\n4、全文索引：用大文本对象的列构建的索引（下一部分会讲解）\nALTER TABLE ’table_name’ ADD FULLTEXT INDEX ft_index(‘col’)；\n5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值\nALTER TABLE ’table_name’ ADD INDEX index_name(‘col1’,‘col2’,‘col3’)；\n*遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。\n如果设立一个组合索引 (a,b,c), 如何使用才会生效?\n1、组合索引字段无论顺序如何改变都会用到索引，前提是所有字段都在where条件上\n2、如果想要使用一个或者两个字段在where条件上，必须有组合索引里的第一个字段，但是与顺序无关，例如a,c或c,a，这种场景是可以命中索引的。但是，b,c或c,b这种是不会命中索引的。\n3、order by 只能使用a，才能用到索引\n*在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引\nALTER TABLE 'table_name' ADD INDEX index_name(col1(4),col2（3))；\n表示使用col1的前4个字符和col2的前3个字符作为索引\n6、前缀索引：当索引是很长的字符序列时，这个索引将会很占内存，而且会很慢，这时候就会用到前缀索引了。所谓的前缀索引就是去索引的前面几个字母作为索引，但是要降低索引的重复率，索引我们还必须要判断前缀索引的重复率\nalter table test add key(name(4));\nselect 1.0*count(distinct name)/count(*) from test 这是比较整个name的重复率,选择较好的索引长度\nhttps://blog.csdn.net/ma2595162349/article/details/79449493 原文链接：https://blog.csdn.net/tongdanping/article/details/79878302\n四、索引的实现原理 MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等等，\n4.1、哈希索引 只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。\n缺点:\n0、因为Hash索引比较的是经过Hash计算的值，所以只能进行等式比较，不能用于范围查询\n1、每次都要全表扫描\n2、由于哈希值是按照顺序排列的，但是哈希值映射的真正数据在哈希表中就不一定按照顺序排列，所以无法利用Hash索引来加速任何排序操作\n3、不能用部分索引键来搜索，因为组合索引在计算哈希值的时候是一起计算的。\n4、当哈希值大量重复且数据量非常大时，其检索效率并没有Btree索引高的。\nhttps://www.cnblogs.com/zhidongjian/p/10414129.html 4.2、全文索引 FULLTEXT（全文）索引，仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。FULLTEXT可以在创建表的时候创建，也可以在需要的时候用ALTER或者CREATE INDEX来添加：\n全文索引的查询也有自己特殊的语法，而不能使用LIKE %查询字符串%的模糊查询语法\nSELECT * FROM table_name MATCH(ft_index) AGAINST('查询字符串');\n注意：\n*对于较大的数据集，把数据添加到一个没有FULLTEXT索引的表，然后添加FULLTEXT索引的速度比把数据添加到一个已经有FULLTEXT索引的表快。\n*5.6版本前的MySQL自带的全文索引只能用于MyISAM存储引擎，如果是其它数据引擎，那么全文索引不会生效。5.6版本之后InnoDB存储引擎开始支持全文索引\n*在MySQL中，全文索引支队英文有用，目前对中文还不支持。5.7版本之后通过使用ngram插件开始支持中文。\n*在MySQL中，如果检索的字符串太短则无法检索得到预期的结果，检索的字符串长度至少为4字节，此外，如果检索的字符包括停止词，那么停止词会被忽略。\n五、索引数据结构 为什么用B/B+树这种结构来实现索引呢？\n答：红黑树等结构也可以用来实现索引，但是文件系统及数据库系统普遍使用B/B+树结构来实现索引。mysql是基于磁盘的数据库，索引是以索引文件的形式存在于磁盘中的，索引的查找过程就会涉及到磁盘IO(为什么涉及到磁盘IO请看文章后面的附加理解部分)消耗，磁盘IO的消耗相比较于内存IO的消耗要高好几个数量级，所以索引的组织结构要设计得在查找关键字时要尽量减少磁盘IO的次数。为什么要使用B/B+树，跟磁盘的存储原理有关。\n局部性原理与磁盘预读\n为了提升效率，要尽量减少磁盘IO的次数。实际过程中，磁盘并不是每次严格按需读取，而是每次都会预读。磁盘读取完需要的数据后，会按顺序再多读一部分数据到内存中，这样做的理论依据是计算机科学中注明的局部性原理：\n当一个数据被用到时，其附近的数据也通常会马上被使用;程序运行期间所需要的数据通常比较集中\n（1）由于磁盘顺序读取的效率很高(不需要寻道时间，只需很少的旋转时间)，\n因此对于具有局部性的程序来说，预读可以提高I/O效率.预读的长度一般为页(page)的整倍数。\n（2）MySQL(默认使用InnoDB引擎),将记录按照页的方式进行管理,每页大小默认为16K(这个值可以修改)。linux 默认页大小为4K。\n为什么不用红黑树?\nB-Tree可以借助计算机磁盘预读的机制，并使用如下技巧：\n每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个结点只需一次I/O。\n假设 B-Tree 的高度为 h,B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3，也即索引的B+树层次一般不超过三层，所以查找效率很高）。\n而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。\n链接：https://www.jianshu.com/p/0371c9569736\nhttps://blog.csdn.net/kongmin_123/article/details/82055901 每次插入和删除都会更新树,树需要重新达到平衡(或者说需要保持定义),btree和b+tree的操作有点不同,\n具体图解:\nhttps://blog.csdn.net/disiwei1012/article/details/78632859 https://www.cnblogs.com/nullzx/p/8729425.html 5.1 BTree索引 也就是B-tree https://ac.nowcoder.com/discuss/299888?type=1\u0026order=0\u0026pos=11\u0026page=1 BTree是平衡多路搜索树，设树的度为2d（d\u003e1），高度为h，那么BTree要满足以下条件：\n每个叶子结点的高度一样，等于h； 每个非叶子结点由n-1个key和n个指针point组成，其中d\u003c=n\u003c=2d,key和point相互间隔，结点两端一定是key； 叶子结点指针都为null； 非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的数据； 多路搜索树是指每个节点的孩子数可以有多个,每个的节点存储的数据也可以有多个, 普通的二叉树只能一个节点数据+两个孩子,\n一个节点不像图中画的只有几个数值,为了方便理解嘛,可能是成千上万个数值, **每个索引节点一般都是操作系统页的整数倍,**InnoDB默认是16K,到时候查出来的数据,在内存中进行筛选(索引数据都是在磁盘上的)\n一个千万量级，且存储引擎是MyISAM或者InnoDB的表，其索引树的高度在3~5之间\n\u003e来自: https://cloud.tencent.com/developer/news/373193 BTree的结构如下：\n在BTree的机构下，就可以使用二分查找的查找方式，时间复杂度为h*log(n)，一般来说树的高度是很小的，h一般为3左右，因此BTree是一个非常高效的查找结构。\n5.2 B+Tree索引 B+Tree是BTree的一个变种，设d为树的度数，h为树的高度，B+Tree和BTree的不同主要在于：\nB+Tree中的非叶子结点不存储数据，只存储键值； B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址； B+Tree的每个非叶子节点由n个键值key和n个指针point组成； B+Tree的结构如下：\n![img](F:\\学习资料\\个人笔记\\MDImages\n","wordCount":"4601","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-08-29T06:58:42.928530207Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E7%B4%A2%E5%BC%95.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search.html title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E6%95%B0%E6%8D%AE%E5%BA%93.html>数据库</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql.html>MySQL</a> <span>></span></ul></nav><h1 class=post-title>索引</h1><div class=post-description></div><div class=post-meta><span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;10 分钟&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/%E6%95%B0%E6%8D%AE%E5%BA%93.html>数据库</a></ul><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言><strong>前言</strong></a></li><li><a href=#%e4%b8%80mysql%e4%b8%ad%e7%b4%a2%e5%bc%95%e7%9a%84%e8%af%ad%e6%b3%95 aria-label=一、MySQL中索引的语法><strong>一、MySQL中索引的语法</strong></a></li><li><a href=#%e4%ba%8c%e7%b4%a2%e5%bc%95%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=二、索引的优缺点><strong>二、索引的优缺点</strong></a></li><li><a href=#%e4%b8%89%e7%b4%a2%e5%bc%95%e7%9a%84%e5%88%86%e7%b1%bb aria-label=三、索引的分类><strong>三、索引的分类</strong></a></li><li><a href=#%e5%9b%9b%e7%b4%a2%e5%bc%95%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86 aria-label=四、索引的实现原理><strong>四、索引的实现原理</strong></a><ul><li><a href=#41%e5%93%88%e5%b8%8c%e7%b4%a2%e5%bc%95 aria-label=4.1、哈希索引><strong>4.1、哈希索引</strong></a></li><li><a href=#42%e5%85%a8%e6%96%87%e7%b4%a2%e5%bc%95 aria-label=4.2、全文索引><strong>4.2、全文索引</strong></a></li></ul></li><li><a href=#%e4%ba%94%e7%b4%a2%e5%bc%95%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=五、索引数据结构>五、索引数据结构</a><ul><li><a href=#51-btree%e7%b4%a2%e5%bc%95 aria-label="5.1 BTree索引"><strong>5.1 BTree索引</strong></a></li><li><a href=#52-btree%e7%b4%a2%e5%bc%95 aria-label="5.2 B+Tree索引"><strong>5.2 B+Tree索引</strong></a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=前言><strong>前言</strong><a hidden class=anchor aria-hidden=true href=#前言>#</a></h1><p>说到索引，很多人都知道“索引<strong>是一个排序的列表</strong>，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。”</p><p>但是索引是怎么实现的呢？因为索引并不是关系模型的组成部分，因此不同的DBMS有不同的实现，我们针对MySQL数据库的实现进行说明。</p><h1 id=一mysql中索引的语法><strong>一、MySQL中索引的语法</strong><a hidden class=anchor aria-hidden=true href=#一mysql中索引的语法>#</a></h1><p><strong>创建索引</strong></p><p>在创建表的时候添加索引</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff7b72>CREATE</span><span style=color:#6e7681> </span><span style=color:#ff7b72>TABLE</span><span style=color:#6e7681> </span>mytable(<span style=color:#6e7681>  
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>ID<span style=color:#6e7681> </span>INT<span style=color:#6e7681> </span><span style=color:#ff7b72>NOT</span><span style=color:#6e7681> </span><span style=color:#ff7b72>NULL</span>,<span style=color:#6e7681>   
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>username<span style=color:#6e7681> </span>VARCHAR(<span style=color:#a5d6ff>16</span>)<span style=color:#6e7681> </span><span style=color:#ff7b72>NOT</span><span style=color:#6e7681> </span><span style=color:#ff7b72>NULL</span>,<span style=color:#6e7681>  
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>INDEX</span><span style=color:#6e7681> </span>[indexName]<span style=color:#6e7681> </span>(username(<span style=color:#ff7b72>length</span>))<span style=color:#6e7681>  
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>);<span style=color:#6e7681> 
</span></span></span></code></pre></div><p>在创建表以后添加索引</p><p><code>ALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);</code></p><p>或者</p><p><code>CREATE INDEX index_name ON my_table(column_name);</code></p><p>注意：</p><p><strong>1、索引需要占用磁盘空间，因此在创建索引时要考虑到磁盘空间是否足够</strong></p><p><strong>2、创建索引时需要对表加锁，因此实际操作中需要在业务空闲期间进行</strong></p><blockquote><p>原文链接：https://blog.csdn.net/tongdanping/article/details/79878302</p></blockquote><p><strong>删除索引</strong></p><p><code>DROP INDEX my_index ON tablename；</code></p><p>或者</p><p><code>ALTER TABLE table_name DROP INDEX index_name;</code></p><p><strong>查看表中的索引</strong></p><p><code>SHOW INDEX FROM tablename</code></p><p>查看查询语句使用索引的情况</p><p><code>explain SELECT * FROM table_name WHERE column_1='123';</code></p><blockquote><p>原文链接：https://blog.csdn.net/tongdanping/article/details/79878302</p></blockquote><h1 id=二索引的优缺点><strong>二、索引的优缺点</strong><a hidden class=anchor aria-hidden=true href=#二索引的优缺点>#</a></h1><p><strong>优势</strong>：可以快速检索，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；</p><p><strong>劣势</strong>：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；</p><p>索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；</p><p><strong>构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；</strong></p><blockquote><p>原文链接：https://blog.csdn.net/tongdanping/article/details/79878302</p></blockquote><h1 id=三索引的分类><strong>三、索引的分类</strong><a hidden class=anchor aria-hidden=true href=#三索引的分类>#</a></h1><p>常见的索引类型有：<strong>主键索引、唯一索引、普通索引、全文索引、组合索引</strong></p><p><strong>1、主键索引</strong>：即主索引，根据主键pk_clolum（length）建立索引，不允许重复，不允许空值；</p><p>ALTER TABLE &rsquo;table_name&rsquo; ADD PRIMARY KEY pk_index(&lsquo;col&rsquo;)；</p><p><strong>2、唯一索引</strong>：用来建立索引的列的值必须是唯一的，允许空值</p><p>ALTER TABLE &rsquo;table_name&rsquo; ADD UNIQUE index_name(&lsquo;col&rsquo;)；</p><p><strong>3、普通索引</strong>：用表中的普通列构建的索引，没有任何限制</p><p>ALTER TABLE &rsquo;table_name&rsquo; ADD INDEX index_name(&lsquo;col&rsquo;)；</p><p><strong>4、全文索引</strong>：用大文本对象的列构建的索引（下一部分会讲解）</p><p>ALTER TABLE &rsquo;table_name&rsquo; ADD FULLTEXT INDEX ft_index(&lsquo;col&rsquo;)；</p><p><strong>5、组合索引</strong>：用多个列组合构建的索引，这多个列中的值不允许有空值</p><p>ALTER TABLE &rsquo;table_name&rsquo; ADD INDEX index_name(&lsquo;col1&rsquo;,&lsquo;col2&rsquo;,&lsquo;col3&rsquo;)；</p><p>*遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。</p><blockquote><p>如果设立一个组合索引 (a,b,c), <strong>如何使用才会生效?</strong></p><p>1、组合索引字段无论顺序如何改变都会用到索引，前提是所有字段都在where条件上</p><p>2、如果想要使用一个或者两个字段在where条件上，必须有组合索引里的第一个字段，但是与顺序无关，例如a,c或c,a，这种场景是可以命中索引的。但是，b,c或c,b这种是不会命中索引的。</p><p>3、order by 只能使用a，才能用到索引</p></blockquote><p>*在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引</p><p><code>ALTER TABLE 'table_name' ADD INDEX index_name(col1(4),col2（3))；</code></p><p>表示使用col1的前4个字符和col2的前3个字符作为索引</p><p><strong>6、前缀索引</strong>：当索引是很长的字符序列时，这个索引将会很占内存，而且会很慢，这时候就会用到前缀索引了。所谓的前缀索引就是去索引的前面几个字母作为索引，但是要降低索引的重复率，索引我们还必须要判断前缀索引的重复率</p><p><code>alter table test add key(name(4));</code></p><blockquote><p><code>select 1.0*count(distinct name)/count(*) from test</code> 这是比较整个name的重复率,选择较好的索引长度</p><p><a href=https://blog.csdn.net/ma2595162349/article/details/79449493 target=_blank rel=noopener>https://blog.csdn.net/ma2595162349/article/details/79449493</a></p><p>原文链接：https://blog.csdn.net/tongdanping/article/details/79878302</p></blockquote><h1 id=四索引的实现原理><strong>四、索引的实现原理</strong><a hidden class=anchor aria-hidden=true href=#四索引的实现原理>#</a></h1><p>MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等等，</p><h2 id=41哈希索引><strong>4.1、哈希索引</strong><a hidden class=anchor aria-hidden=true href=#41哈希索引>#</a></h2><p>只有<strong>memory</strong>（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</p><p>缺点:</p><p>0、因为Hash索引比较的是经过Hash计算的值，所以只能进行等式比较，不能用于范围查询</p><p>1、每次都要全表扫描</p><p>2、由于哈希值是按照顺序排列的，但是哈希值映射的真正数据在哈希表中就不一定按照顺序排列，所以无法利用Hash索引来加速任何排序操作</p><p>3、不能用部分索引键来搜索，因为组合索引在计算哈希值的时候是一起计算的。</p><p>4、当哈希值大量重复且数据量非常大时，其检索效率并没有Btree索引高的。</p><blockquote><p><a href=https://www.cnblogs.com/zhidongjian/p/10414129.html target=_blank rel=noopener>https://www.cnblogs.com/zhidongjian/p/10414129.html</a></p></blockquote><h2 id=42全文索引><strong>4.2、全文索引</strong><a hidden class=anchor aria-hidden=true href=#42全文索引>#</a></h2><p>FULLTEXT（全文）索引，仅可用于<strong>MyISAM和InnoDB</strong>，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。FULLTEXT可以在创建表的时候创建，也可以在需要的时候用ALTER或者CREATE INDEX来添加：</p><p>全文索引的查询也有自己特殊的语法，而不能使用LIKE %查询字符串%的模糊查询语法</p><p><code>SELECT * FROM table_name MATCH(ft_index) AGAINST('查询字符串');</code></p><blockquote><p>注意：</p><p>*对于较大的数据集，把数据添加到一个没有FULLTEXT索引的表，然后添加FULLTEXT索引的速度比把数据添加到一个已经有FULLTEXT索引的表快。</p><p>*5.6版本前的MySQL自带的全文索引只能用于MyISAM存储引擎，如果是其它数据引擎，那么全文索引不会生效。<strong>5.6版本之后InnoDB存储引擎开始支持全文索引</strong></p><p>*在MySQL中，全文索引支队英文有用，目前对中文还不支持。<strong>5.7版本之后通过使用ngram插件开始支持中文。</strong></p><p>*在MySQL中，如果检索的字符串太短则无法检索得到预期的结果，检索的字符串长度至少为4字节，此外，如果检索的字符包括停止词，那么停止词会被忽略。</p></blockquote><h1 id=五索引数据结构>五、索引数据结构<a hidden class=anchor aria-hidden=true href=#五索引数据结构>#</a></h1><p><strong>为什么用B/B+树这种结构来实现索引呢？</strong></p><p>答：红黑树等结构也可以用来实现索引，但是文件系统及数据库系统普遍使用B/B+树结构来实现索引。mysql是基于磁盘的数据库，索引是以索引文件的形式存在于磁盘中的，索引的查找过程就会涉及到磁盘IO(为什么涉及到磁盘IO请看文章后面的附加理解部分)消耗，磁盘IO的消耗相比较于内存IO的消耗要高好几个数量级，所以索引的组织结构要设计得在查找关键字时要尽量减少磁盘IO的次数。为什么要使用B/B+树，跟磁盘的存储原理有关。</p><p><strong>局部性原理与磁盘预读</strong></p><p>为了提升效率，要尽量减少磁盘IO的次数。实际过程中，磁盘并不是每次严格按需读取，而是每次都会预读。磁盘读取完需要的数据后，会按顺序再多读一部分数据到内存中，这样做的理论依据是计算机科学中注明的局部性原理：</p><p>当一个数据被用到时，其附近的数据也通常会马上被使用;程序运行期间所需要的数据通常比较集中</p><p>（1）由于磁盘顺序读取的效率很高(不需要寻道时间，只需很少的旋转时间)，</p><p>因此对于具有局部性的程序来说，预读可以提高I/O效率.预读的长度一般为页(page)的整倍数。</p><p>（2）MySQL(默认使用InnoDB引擎),将记录按照页的方式进行管理,每页大小默认为16K(这个值可以修改)。linux 默认页大小为4K。</p><p><strong>为什么不用红黑树?</strong></p><p><strong>B-Tree可以借助计算机磁盘预读的机制</strong>，并使用如下技巧：</p><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个结点只需一次I/O。</p><p>假设 B-Tree 的高度为 h,B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3，也即索引的B+树层次一般不超过三层，所以查找效率很高）。</p><p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，<strong>无法利用局部性</strong>，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p><blockquote><p>链接：https://www.jianshu.com/p/0371c9569736</p><p><a href=https://blog.csdn.net/kongmin_123/article/details/82055901 target=_blank rel=noopener>https://blog.csdn.net/kongmin_123/article/details/82055901</a></p></blockquote><p><strong>每次插入和删除都会更新树,树需要重新达到平衡(或者说需要保持定义)</strong>,btree和b+tree的操作有点不同,</p><blockquote><p>具体图解:</p><p><a href=https://blog.csdn.net/disiwei1012/article/details/78632859 target=_blank rel=noopener>https://blog.csdn.net/disiwei1012/article/details/78632859</a></p><p><a href=https://www.cnblogs.com/nullzx/p/8729425.html target=_blank rel=noopener>https://www.cnblogs.com/nullzx/p/8729425.html</a></p></blockquote><h2 id=51-btree索引><strong>5.1 BTree索引</strong><a hidden class=anchor aria-hidden=true href=#51-btree索引>#</a></h2><blockquote><p>也就是B-tree <a href="https://ac.nowcoder.com/discuss/299888?type=1&amp;order=0&amp;pos=11&amp;page=1" target=_blank rel=noopener>https://ac.nowcoder.com/discuss/299888?type=1&order=0&pos=11&page=1</a></p></blockquote><p>BTree是平衡多路搜索树，设树的度为2d（d>1），高度为h，那么BTree要满足以下条件：</p><ul><li>每个叶子结点的高度一样，等于h；</li><li>每个非叶子结点由n-1个key和n个指针point组成，其中d&lt;=n&lt;=2d,key和point相互间隔，结点两端一定是key；</li><li>叶子结点指针都为null；</li><li>非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的数据；</li></ul><p><strong>多路搜索树是指每个节点的孩子数可以有多个,每个的节点存储的数据也可以有多个</strong>, 普通的二叉树只能一个节点数据+两个孩子,</p><p>一个节点不像图中画的只有几个数值,为了方便理解嘛,可能是成千上万个数值, **每个索引节点一般都是操作系统页的整数倍,**InnoDB默认是16K,到时候查出来的数据,在内存中进行筛选(索引数据都是在磁盘上的)</p><p><strong>一个千万量级，且存储引擎是MyISAM或者InnoDB的表，其索引树的高度在3~5之间</strong></p><p><strong>>来自:</strong> <a href=https://cloud.tencent.com/developer/news/373193 target=_blank rel=noopener><strong>https://cloud.tencent.com/developer/news/373193</strong></a></p><p>BTree的结构如下：</p><p><img loading=lazy src=F:%5c%e5%ad%a6%e4%b9%a0%e8%b5%84%e6%96%99%5c%e4%b8%aa%e4%ba%ba%e7%ac%94%e8%ae%b0%5cMDImages%5c411150103704.png alt=img></p><p>在BTree的机构下，就可以使用二分查找的查找方式，时间复杂度为h*log(n)，一般来说树的高度是很小的，h一般为3左右，因此BTree是一个非常高效的查找结构。</p><h2 id=52-btree索引><strong>5.2 B+Tree索引</strong><a hidden class=anchor aria-hidden=true href=#52-btree索引>#</a></h2><p>B+Tree是BTree的一个变种，设d为树的度数，h为树的高度，B+Tree和BTree的不同主要在于：</p><ul><li>B+Tree中的非叶子结点不存储数据，只存储键值；</li><li>B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址；</li><li>B+Tree的每个非叶子节点由n个键值key和n个指针point组成；</li></ul><p>B+Tree的结构如下：</p><p>![img](F:\学习资料\个人笔记\MDImages</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/mysql.html>MySQL</a></li><li><a href=https://xiaokunji.com/zh/tags/%E6%95%B0%E6%8D%AE%E5%BA%93.html>数据库</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%B4%A2%E5%BC%95.html><span class=title>« 上一页</span><br><span>索引</span></a>
<a class=next href=https://xiaokunji.com/zh/%E6%95%B0%E6%8D%AE%E5%BA%93/oracle/%E7%B4%A2%E5%BC%95.html><span class=title>下一页 »</span><br><span>索引</span></a></nav></footer></article></main><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>