<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>YARN | 米二</title><meta name=keywords content=" **1.YARN 概述 YARN**, **2.** **YARN 的重要概念**, **2.1**  **ResourceManager** , **2.2  NodeManager** , **2.3  MRAppMaster** , **2.4 Container**, **2.5 ASM**, **2.6 Scheduler**, **3. ARN 架构及各角色职责**, **4.  YARN 作业执行流程**"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.github.io/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/hadoop/yarn/><link crossorigin=anonymous href=/assets/css/stylesheet.4e0011f750c7441f57e7cdbfd7afb83ad2ac4efdcdb4adebee9988b40de3f85c.css integrity="sha256-TgAR91DHRB9X582/16+4OtKsTv3NtK3r7pmItA3j+Fw=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.github.io/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.github.io/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.github.io/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.github.io/Q.svg><link rel=mask-icon href=https://xiaokunji.github.io/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.github.io/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/hadoop/yarn/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="YARN"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.github.io/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/hadoop/yarn/"><meta property="article:section" content="Hadoop生态圈"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="YARN"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"YARN","item":"https://xiaokunji.github.io/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/hadoop/yarn/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"YARN","name":"YARN","description":"     ","keywords":[" **1.YARN 概述 YARN**"," **2.** **YARN 的重要概念**"," **2.1**  **ResourceManager** "," **2.2  NodeManager** "," **2.3  MRAppMaster** "," **2.4 Container**"," **2.5 ASM**"," **2.6 Scheduler**"," **3. ARN 架构及各角色职责**"," **4.  YARN 作业执行流程**"],"articleBody":"[toc]\n1.YARN 概述 YARN YARN 是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操 作系统平台，而 MapReduce 等运算程序则相当于运行于操作系统之上的应用程序\nYARN 是 Hadoop2.x 版本中的一个新特性。它的出现其实是为了解决第一代 MapReduce 编程 框架的不足，提高集群环境下的资源利用率，这些资源包括内存，磁盘，网络，IO等。Hadoop2.X 版本中重新设计的这个 YARN 集群，具有更好的扩展性，可用性，可靠性，向后兼容性，以 及能支持除 MapReduce 以外的更多分布式计算程序\n1、YARN 并不清楚用户提交的程序的运行机制\n2、YARN 只提供运算资源的调度（用户程序向 YARN 申请资源，YARN 就负责分配资源）\n3、YARN 中的主管角色叫 ResourceManager\n4、YARN 中具体提供运算资源的角色叫 NodeManager\n5、这样一来，YARN 其实就与运行的用户程序完全解耦，就意味着 YARN 上可以运行各种类 型的分布式运算程序（MapReduce 只是其中的一种），比如 MapReduce、Storm 程序，Spark 程序，Tez ……\n6、所以，Spark、Storm 等运算框架都可以整合在 YARN 上运行，只要他们各自的框架中有 符合 YARN 规范的资源请求机制即可\n7、yarn 就成为一个通用的资源调度平台，从此，企业中以前存在的各种运算集群都可以整 合在一个物理集群上，提高资源利用率，方便数据共享\nYARN/MRv2 最基本的想法是将原 JobTracker 主要的资源管理和 Job 调度/监视功能分开作为 两个单独的守护进程。有一个全局的 ResourceManager(RM)和每个 Application 有一个 ApplicationMaster(AM)，Application 相当于 MapReduce Job 或者 DAG jobs。ResourceManager 和 NodeManager(NM)组成了基本的数据计算框架。ResourceManager 协调集群的资源利用， 任何 Client 或者运行着的 applicatitonMaster 想要运行 Job 或者 Task 都得向 RM 申请一定的资 源。ApplicatonMaster 是一个框架特殊的库，对于 MapReduce 框架而言有它自己的 AM 实现， 用户也可以实现自己的 AM，在运行的时候，AM 会与 NM 一起来启动和监视 Tasks。\n2. YARN 的重要概念 2.1 ResourceManager ResourceManager 是基于应用程序对集群资源的需求进行调度的 YARN 集群主控节点，负责 协调和管理整个集群（所有 NodeManager）的资源，响应用户提交的不同类型应用程序的 解析，调度，监控等工作。ResourceManager 会为每一个 Application 启动一个 MRAppMaster， 并且 MRAppMaster 分散在各个 NodeManager 节点\n它主要由两个组件构成：调度器（Scheduler）和应用程序管理器（ApplicationsManager， ASM）\nYARN 集群的主节点 ResourceManager 的职责：\n1、处理客户端请求\n2、启动或监控 MRAppMaster\n3、监控 NodeManager\n4、资源的分配与调度\n2.2 NodeManager NodeManager 是 YARN 集群当中真正资源的提供者，是真正执行应用程序的容器的提供者， 监控应用程序的资源使用情况（CPU，内存，硬盘，网络），并通过心跳向集群资源调度器 ResourceManager 进行汇报以更新自己的健康状态。同时其也会监督 Container 的生命周期 管理，监控每个 Container 的资源使用（内存、CPU 等）情况，追踪节点健康状况，管理日 志和不同应用程序用到的附属服务（auxiliary service）。\nYARN 集群的从节点 NodeManager 的职责：\n1、管理单个节点上的资源\n2、处理来自 ResourceManager 的命令\n3、处理来自 MRAppMaster 的命令\n2.3 MRAppMaster MRAppMaster 对应一个应用程序，职责是：向资源调度器申请执行任务的资源容器，运行 任务，监控整个任务的执行，跟踪整个任务的状态，处理任务失败以异常情况\n2.4 Container Container 容器是一个抽象出来的逻辑资源单位。容器是由 ResourceManager Scheduler 服务 动态分配的资源构成，它包括了该节点上的一定量 CPU，内存，磁盘，网络等信息，MapReduce 程序的所有 Task 都是在一个容器里执行完成的，容器的大小是可以动态调整的\n2.5 ASM 应用程序管理器 ASM 负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协 商资源以启动 MRAppMaster、监控 MRAppMaster 运行状态并在失败时重新启动它等\n2.6 Scheduler 调度器根据应用程序的资源需求进行资源分配，不参与应用程序具体的执行和监控等工作 资源分配的单位就是 Container，调度器是一个可插拔的组件，用户可以根据自己的需求实 现自己的调度器。YARN 本身为我们提供了多种直接可用的调度器，比如 FIFO，Fair Scheduler 和 Capacity Scheduler 等\n3. ARN 架构及各角色职责 4. YARN 作业执行流程 YARN 作业执行流程：\n1、用户向 YARN 中提交应用程序，其中包括 MRAppMaster 程序，启动 MRAppMaster 的命令， 用户程序等。\n2、ResourceManager 为该程序分配第一个 Container，并与对应的 NodeManager 通讯，要求 它在这个 Container 中启动应用程序 MRAppMaster。\n3、MRAppMaster 首先向 ResourceManager 注册，这样用户可以直接通过 ResourceManager 查看应用程序的运行状态，然后将为各个任务申请资源，并监控它的运行状态，直到运行结束，重复 4 到 7 的步骤。\n4、MRAppMaster 采用轮询的方式通过 RPC 协议向 ResourceManager 申请和领取资源。\n5、一旦 MRAppMaster 申请到资源后，便与对应的 NodeManager 通讯，要求它启动任务。\n6、NodeManager 为任务设置好运行环境（包括环境变量、JAR 包、二进制程序等）后，将 任务启动命令写到一个脚本中，并通过运行该脚本启动任务。\n7、各个任务通过某个 RPC 协议向 MRAppMaster 汇报自己的状态和进度，以让 MRAppMaster 随时掌握各个任务的运行状态，从而可以在任务败的时候重新启动任务。\n8、应用程序运行完成后，MRAppMaster 向 ResourceManager 注销并关闭自己。\n","wordCount":"2124","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-08-22T00:00:00Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.github.io/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/hadoop/yarn/"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.github.io/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.github.io/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.github.io/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.github.io/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.github.io/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.github.io/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.github.io/zh/post title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.github.io/zh/archives/ title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.github.io/zh/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.github.io/zh/categories title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.github.io/zh/links title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.github.io/zh/>米二</a> <span>></span>
<a href=https://xiaokunji.github.io/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/>Hadoop生态圈</a> <span>></span>
<a href=https://xiaokunji.github.io/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/hadoop/>Hadoop</a> <span>></span></ul></nav><h1 class=post-title>YARN</h1><div class=post-description></div><div class=post-meta><span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;5 分钟&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.github.io/zh/categories/hadoop%E7%94%9F%E6%80%81%E5%9C%88/>Hadoop生态圈</a></ul><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#1yarn-%e6%a6%82%e8%bf%b0-yarn aria-label="1.YARN 概述 YARN"><strong>1.YARN 概述 YARN</strong></a></li><li><a href=#2-yarn-%e7%9a%84%e9%87%8d%e8%a6%81%e6%a6%82%e5%bf%b5 aria-label="2. YARN 的重要概念"><strong>2.</strong> <strong>YARN 的重要概念</strong></a><ul><li><a href=#21--resourcemanager aria-label="2.1 ResourceManager"><strong>2.1</strong> <strong>ResourceManager</strong></a></li><li><a href=#22--nodemanager aria-label="2.2 NodeManager"><strong>2.2 NodeManager</strong></a></li><li><a href=#23--mrappmaster aria-label="2.3 MRAppMaster"><strong>2.3 MRAppMaster</strong></a></li><li><a href=#24-container aria-label="2.4 Container"><strong>2.4 Container</strong></a></li><li><a href=#25-asm aria-label="2.5 ASM"><strong>2.5 ASM</strong></a></li><li><a href=#26-scheduler aria-label="2.6 Scheduler"><strong>2.6 Scheduler</strong></a></li></ul></li><li><a href=#3-arn-%e6%9e%b6%e6%9e%84%e5%8f%8a%e5%90%84%e8%a7%92%e8%89%b2%e8%81%8c%e8%b4%a3 aria-label="3. ARN 架构及各角色职责"><strong>3. ARN 架构及各角色职责</strong></a></li><li><a href=#4--yarn-%e4%bd%9c%e4%b8%9a%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b aria-label="4. YARN 作业执行流程"><strong>4. YARN 作业执行流程</strong></a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=1yarn-概述-yarn><strong>1.YARN 概述 YARN</strong><a hidden class=anchor aria-hidden=true href=#1yarn-概述-yarn>#</a></h1><p>　　YARN 是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操 作系统平台，而 MapReduce 等运算程序则相当于运行于操作系统之上的应用程序</p><p>　　YARN 是 Hadoop2.x 版本中的一个新特性。它的出现其实是为了解决第一代 MapReduce 编程 框架的不足，提高集群环境下的资源利用率，这些资源包括内存，磁盘，网络，IO等。Hadoop2.X 版本中重新设计的这个 YARN 集群，具有更好的扩展性，可用性，可靠性，向后兼容性，以 及能支持除 MapReduce 以外的更多分布式计算程序</p><p>　　1、YARN 并不清楚用户提交的程序的运行机制</p><p>　　2、YARN 只提供运算资源的调度（用户程序向 YARN 申请资源，YARN 就负责分配资源）</p><p>　　3、YARN 中的主管角色叫 ResourceManager</p><p>　　4、YARN 中具体提供运算资源的角色叫 NodeManager</p><p>　　5、这样一来，YARN 其实就与运行的用户程序完全解耦，就意味着 YARN 上可以运行各种类 型的分布式运算程序（MapReduce 只是其中的一种），比如 MapReduce、Storm 程序，Spark 程序，Tez ……</p><p>　　6、所以，Spark、Storm 等运算框架都可以整合在 YARN 上运行，只要他们各自的框架中有 符合 YARN 规范的资源请求机制即可</p><p>　　7、yarn 就成为一个通用的资源调度平台，从此，企业中以前存在的各种运算集群都可以整 合在一个物理集群上，提高资源利用率，方便数据共享</p><p>　YARN/MRv2 最基本的想法是将原 JobTracker 主要的资源管理和 Job 调度/监视功能分开作为 两个单独的守护进程。有一个全局的 ResourceManager(RM)和每个 Application 有一个 ApplicationMaster(AM)，Application 相当于 MapReduce Job 或者 DAG jobs。ResourceManager 和 NodeManager(NM)组成了基本的数据计算框架。ResourceManager 协调集群的资源利用， 任何 Client 或者运行着的 applicatitonMaster 想要运行 Job 或者 Task 都得向 RM 申请一定的资 源。ApplicatonMaster 是一个框架特殊的库，对于 MapReduce 框架而言有它自己的 AM 实现， 用户也可以实现自己的 AM，在运行的时候，AM 会与 NM 一起来启动和监视 Tasks。</p><h1 id=2-yarn-的重要概念><strong>2.</strong> <strong>YARN 的重要概念</strong><a hidden class=anchor aria-hidden=true href=#2-yarn-的重要概念>#</a></h1><h2 id=21--resourcemanager><strong>2.1</strong> <strong>ResourceManager</strong><a hidden class=anchor aria-hidden=true href=#21--resourcemanager>#</a></h2><p>ResourceManager 是基于应用程序对集群资源的需求进行调度的 YARN 集群主控节点，负责 协调和管理整个集群（所有 NodeManager）的资源，响应用户提交的不同类型应用程序的 解析，调度，监控等工作。ResourceManager 会为每一个 Application 启动一个 MRAppMaster， 并且 MRAppMaster 分散在各个 NodeManager 节点</p><p>　　它主要由两个组件构成：<strong>调度器（Scheduler）和应用程序管理器（ApplicationsManager， ASM）</strong></p><p>　　YARN 集群的主节点 ResourceManager 的职责：</p><p>　　　　1、处理客户端请求</p><p>　　　　2、启动或监控 MRAppMaster</p><p>　　　　3、监控 NodeManager</p><p>　　　　4、资源的分配与调度</p><h2 id=22--nodemanager><strong>2.2 NodeManager</strong><a hidden class=anchor aria-hidden=true href=#22--nodemanager>#</a></h2><p>　　NodeManager 是 YARN 集群当中真正资源的提供者，是真正执行应用程序的容器的提供者， 监控应用程序的资源使用情况（CPU，内存，硬盘，网络），并通过心跳向集群资源调度器 ResourceManager 进行汇报以更新自己的健康状态。同时其也会监督 Container 的生命周期 管理，监控每个 Container 的资源使用（内存、CPU 等）情况，追踪节点健康状况，管理日 志和不同应用程序用到的附属服务（auxiliary service）。</p><p>　　YARN 集群的从节点 NodeManager 的职责：</p><p>　　　　1、管理单个节点上的资源</p><p>　　　　2、处理来自 ResourceManager 的命令</p><p>　　　　3、处理来自 MRAppMaster 的命令</p><h2 id=23--mrappmaster><strong>2.3 MRAppMaster</strong><a hidden class=anchor aria-hidden=true href=#23--mrappmaster>#</a></h2><p>MRAppMaster 对应一个应用程序，职责是：向资源调度器申请执行任务的资源容器，运行 任务，监控整个任务的执行，跟踪整个任务的状态，处理任务失败以异常情况</p><h2 id=24-container><strong>2.4 Container</strong><a hidden class=anchor aria-hidden=true href=#24-container>#</a></h2><p>　　Container 容器是一个抽象出来的逻辑资源单位。容器是由 ResourceManager Scheduler 服务 动态分配的资源构成，它包括了该节点上的一定量 CPU，内存，磁盘，网络等信息，MapReduce 程序的所有 Task 都是在一个容器里执行完成的，容器的大小是可以动态调整的</p><h2 id=25-asm><strong>2.5 ASM</strong><a hidden class=anchor aria-hidden=true href=#25-asm>#</a></h2><p>　　应用程序管理器 ASM 负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协 商资源以启动 MRAppMaster、监控 MRAppMaster 运行状态并在失败时重新启动它等</p><h2 id=26-scheduler><strong>2.6 Scheduler</strong><a hidden class=anchor aria-hidden=true href=#26-scheduler>#</a></h2><p>　　调度器根据应用程序的资源需求进行资源分配，不参与应用程序具体的执行和监控等工作 资源分配的单位就是 Container，调度器是一个可插拔的组件，用户可以根据自己的需求实 现自己的调度器。YARN 本身为我们提供了多种直接可用的调度器，比如 FIFO，Fair Scheduler 和 Capacity Scheduler 等</p><h1 id=3-arn-架构及各角色职责><strong>3. ARN 架构及各角色职责</strong><a hidden class=anchor aria-hidden=true href=#3-arn-架构及各角色职责>#</a></h1><p><img loading=lazy src=https://gitee.com/xiaokunji/my-images/raw/master/myMD/20210711173949.png alt=img></p><h1 id=4--yarn-作业执行流程><strong>4. YARN 作业执行流程</strong><a hidden class=anchor aria-hidden=true href=#4--yarn-作业执行流程>#</a></h1><p>　　YARN 作业执行流程：</p><p>　　　　1、用户向 YARN 中提交应用程序，其中包括 MRAppMaster 程序，启动 MRAppMaster 的命令， 用户程序等。</p><p>　　　　2、ResourceManager 为该程序分配第一个 Container，并与对应的 NodeManager 通讯，要求 它在这个 Container 中启动应用程序 MRAppMaster。</p><p>　　　　3、MRAppMaster 首先向 ResourceManager 注册，这样用户可以直接通过 ResourceManager 查看应用程序的运行状态，然后将为各个任务申请资源，并监控它的运行状态，直到运行结束，重复 4 到 7 的步骤。</p><p>　　　　4、MRAppMaster 采用轮询的方式通过 RPC 协议向 ResourceManager 申请和领取资源。</p><p>　　　　5、一旦 MRAppMaster 申请到资源后，便与对应的 NodeManager 通讯，要求它启动任务。</p><p>　　　　6、NodeManager 为任务设置好运行环境（包括环境变量、JAR 包、二进制程序等）后，将 任务启动命令写到一个脚本中，并通过运行该脚本启动任务。</p><p>　　　　7、各个任务通过某个 RPC 协议向 MRAppMaster 汇报自己的状态和进度，以让 MRAppMaster 随时掌握各个任务的运行状态，从而可以在任务败的时候重新启动任务。</p><p>　　　　8、应用程序运行完成后，MRAppMaster 向 ResourceManager 注销并关闭自己。</p><p><img loading=lazy src=https://gitee.com/xiaokunji/my-images/raw/master/myMD/20210711173950.png alt=img></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.github.io/zh/tags/hadoop/>Hadoop</a></li><li><a href=https://xiaokunji.github.io/zh/tags/hadoop%E7%94%9F%E6%80%81%E5%9C%88/>Hadoop生态圈</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.github.io/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E6%9C%8D%E5%8A%A1%E5%99%A8/tomcat/><span class=title>« 上一页</span><br><span>Tomcat</span></a>
<a class=next href=https://xiaokunji.github.io/zh/python%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E7%88%AC%E8%99%AB/%E9%97%AE%E9%A2%98/%E7%88%B1%E5%8D%A1/%E7%88%B1%E5%8D%A1%E7%9A%84%E9%97%AE%E9%A2%98/><span class=title>下一页 »</span><br><span>爱卡的问题</span></a></nav></footer></article></main><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.github.io/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>