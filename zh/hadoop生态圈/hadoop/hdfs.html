<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>HDFS | 米二</title><meta name=keywords content=" **1.介绍**, **2.HDFS实现原理**, **2.2 Sencondary NameNode**, **2.3 DataNode**, **3. HDFS读写流程**, **3.1 写数据**, **3.2 文件读取**, **4. HDFS balancer**, **5. HDFS快照**, **6. Hadoop 配额设置**, **6.1 什么是配额**, **6.2 配额种类**, **7. 复制因子**, **8. 安全模式**, **9.空间回收**"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/hadoop/hdfs.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/hadoop/hdfs.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="HDFS"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/hadoop/hdfs.html"><meta property="article:section" content="hadoop生态圈"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-30T16:30:55+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="HDFS"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"HDFS","item":"https://xiaokunji.com/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/hadoop/hdfs.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"HDFS","name":"HDFS","description":"     ","keywords":[" **1.介绍**"," **2.HDFS实现原理**"," **2.2 Sencondary NameNode**"," **2.3 DataNode**"," **3. HDFS读写流程**"," **3.1 写数据**"," **3.2 文件读取**"," **4. HDFS balancer**"," **5. HDFS快照**"," **6. Hadoop 配额设置**"," **6.1 什么是配额**"," **6.2 配额种类**"," **7. 复制因子**"," **8. 安全模式**"," **9.空间回收**"],"articleBody":"[toc]\n1.介绍 一句话(官方):分布式存储系统HDFS( Hadoop Distributed File System)。 其实就是一个文件系统，类似于linux的文件系统。有目录，目录下可以存 储文件。但它又是一个分布式的文件系统。\n基本原理\n将文件切分成等大的数据块，分别存储到多台机器上。 每个数据块存在多个备份。 将数据切分、容错、负载均衡等功能透明化。 可将HDFS看成是一个巨大、具有容错性的磁盘。 缺点\n不适合存储大量小文件。 不适合低延迟数据访问 。 不支持多用户写入及任意修改文件 。 2.HDFS实现原理 数据块\n每个磁盘都有默认的数据块大小，这是磁盘进行数据读/写的最小单位。构建于单个磁盘之 上的文件系统通过磁盘块来管理该文件系统中的块，该文件系统块的大小可以是磁盘块的整数倍。 HDFS 同样也有块 (block) 的概念，但是大得多，默认为 128 MB 。与单一磁盘上的文件系统相似， HDFS 上的文件也被划分为块大小的多个分块 (chunk) ，作为独立的存储单元。但与其他 文件系统不同的是， HDFS 中小于一个块大小的文件不会占据整个块的空间。(好像老版本的会占用整个空间) 2.1 NameNode\nNameNode是HDFS架构中的主节点。 当NameNode启动时会从fsimage中读取数据,缩短启动时间,并会写入editlog,Namenode只有 在启动时候合并fsimage和edits log.\n功能\n管理各个从节点的状态(DataNode)。 记录存储在HDFS上的所有数据的元数据信息。例如:block存储的位置，文件大小，文件权限，文件层级等等。这些信息以两个文件形式永久保存在本地磁盘上。 命名空间镜像文件(FsImage): fsimage是HDFS文件系统存于硬盘中的元数据检查点，里面记录 了自最后一次检查点之前HDFS文件系统中所有目录和文件的序列化信息 编辑日志(edit-logs)文件:保存了自最后一次检查点之后所有针对HDFS文件系统的操作，比如: 增加文件、重命名文件、删除目录等等。 记录了存储在HDFS上文件的所有变化，例如文件被删除，namenode会记录到editlog中。\n接受DataNode的心跳和各个datanode上的block报告信息，确保DataNode是否存活。\n负责处理所有块的复制因子。\n如果DataNode节点宕机，NameNode会选择另外一个DataNode均衡复制因子，并做负载均衡。\n2.2 Sencondary NameNode S NameNode是NameNode的助手，不要将其理解成是NameNode的备份。Secondary NameNode 的整个目的在HDFS中提供一个Checkpoint Node，所以也被叫做checkpoint node。\n功能\n定时的从NameNode获取EditLogs,并更新到FsImage上。 一旦它有新的fsimage文件，它将其拷贝回NameNode上，NameNode在下次重启时会使用这个新的fsimage文件，从而减少重启的时间。 关于NameNode是什么时候将改动 写到edit logs中的? 这个操作实际上是由 DataNode的写操作触发的，当我们往 DataNode写文件时，DataNode会跟 NameNode通信，告诉NameNode什么文 件的第几个block放在它那里，NameNode 这个时候会将这些元数据信息写到edit logs文件中。\n2.3 DataNode DataNode是HDFS架构的从节点，管理各自节点的Block信息。\n功能\n多个数据实际是存储到DataNode上面。 DataNode分别运行在独立的节点上。 DataNode执行客户端级别的读写请求。 向NameNode发送心跳(默认是3s)，报告各自节点的健康状况。 3. HDFS读写流程 3.1 写数据 client将数据分片 client请求namenode，要将多个块写入到HDFS。例如这里的Block A和Block B。 NameNode会给client赋予写权限，并为client提供可以写入数据的DataNode的IP地址。Namenode在选择可写入数据的dataNode的规则是结合了DN的健康状态、复制因子、机架感知等因素随机选择的DN。假如复制因子是3(默认值)，那么会为每个block返回三个IP地址。例如NN为client提供了以下的IP地址列表。 在写入数据之前，client首先 要确认namenode提供的ip列表 是否准备好了接收数据。Client通过连接各个块的ip列表来为 每个块创建流水线。（传递的方式） 流水线建立好以后，client将 会向流水线中写入数据（block 是并行写入的）。Client只会将block A向 DN1复制。其他节点复制是在DN 之间完成的。 当数据复制到所有的DN完成之 后，按照ip地址列表相反的方向，依次反馈写入成功的信息。 DN1将确认信息反馈给client，client再将确认信息反馈给NN， NN更新元数据信息，client关 闭pipline。 3.2 文件读取 Client请求namenode要读取exaple. txt文件。 NN根据自己的元数据信息，反馈给 client一个DataNode的列表(存储B lock A和B)。 Client连接DN，读取BlockA,Block B的数据。 Client合并block A和Block B的数 据。 4. HDFS balancer 集群磁盘数据不均衡导致的原因有很多情况。\n添加新的DataNode节点。 人为干预，修改block副本数。 各个机器磁盘大小不一致。 长时间运行大量的delete操作等。 5. HDFS快照 Hdfs的快照（snapshot）是在某一时间点对指定文件系统拷贝，快照采用只读模式，可以对重要数据进行恢复、防止用户错误性的操作。\n快照分两种：\n一种是：建立文件系统的索引，每次更新文件不会真正的改变文件，而是新开辟一个空间用来保存更改的文件，(hdfs属于该种)\n一种是：拷贝所有的文件系统\n和VM做快照差不多,相当于做了个备份,可以做回滚\n快照创建是瞬间的:成本是0(1)排除查找信息节点的时间 。 额外的内存使用仅仅当对快照进行修改时产生：内存使用时0(M),M是修改文件/目录的数量。 是一个只读的基于时间点文件系统拷贝。快照可以是整个文件系统的也可以是一部分。常用来作为数据备 份，防止用户错误和容灾。 在datanode 上面的blocks 不会复制，做Snapshot 的文件是纪录了block的列表和文件的大小，但是没有数据的复制 Snapshot 并不会影响HDFS 的正常操作: 修改会按照时间的反序记录，这样可以直接读取到最新的数据。 快照数据是 当前数据减去修改的部分计算出来的。 快照会存储在snapshottable的目录下。snapshottable下存储的snapshots 最多为65535个。没有限制snapshottable目录 的数量。管理员可以设置任何的目录成为snapshottable。如果snapshottable里面存着快照，那么文件夹不能删除或者 改名。 6. Hadoop 配额设置 6.1 什么是配额 ​\tHadoop 分布式文件系统(HDFS)允许管理员为每个目录设置配额,限制该目录下占用空间大小,和目录/文件数量.新建立的目录没有配额。最 大的配额是 Long.Max_Value。配额为 1 可以强制目录保持为空。\n​\t目录配额是对目录树上该目录下的名字数量做硬性限制。如果创建文件或目录时超过了配额， 该操作会失败。重命名不会改变该目录的配额;如果重命名操作会导致违反配额限制，该操作 将会失败。如果尝试设置一个配额而现有文件数量已经超出了这个新配额，则设置失败。\n所有超出配额的操作都会失败\n配额和 fsimage 保持一致。当启动时，如果 fsimage 违反了某个配额限制(也许 fsimage 被偷 偷改变了)，则启动失败并生成错误报告。设置或删除一个配额会创建相应的日志记录。\n6.2 配额种类 Name Quotas:设置某一个目录下文件总数 从文件数目上限制\nSpace Quotas:设置某一个目录下可使用空间大小 从空间上限制\n注意：这里需要特别注意的是“Space Quota”的设置所看的不是 Hdfs 的文件大小，而是写入 Hdfs 所有 block 块的大小。包含备份的部分，而且不足一个块也要按照一个块计算\n​\thdfs 的配额管理是跟着目录走，如果目录被重命名，配额依然有效。 麻烦的是，在设置完配额以后，如果超过限制，虽然文件不会写入到 hdfs，但是文件名依然会存在，只是文件 size 为 0。当加大配额设置后，还需要将之前的空文件删除才能进一步写入。如果新设置的 quota 值，小于该目录现有的 Name Quotas 及 Space Quotas，系统并不会给 出错误提示，但是该目录的配置会变成最新设置的 quota。\n设置\n启用设定:hadoop dfsadmin -setQuota 10000 /user/seamon 清除設定: hadoop dfsadmin -clrQuota /user/seamon 可以使用m,g,t 代表 MB,GB,TB 启用设定: hadoop dfsadmin -setSpaceQuota 1g /user/seamon/ 清除設定: hadoop dfsadmin -clrSpaceQuota /user/seamon 7. 复制因子 HDFS为我们提供了可靠的存储，就是因为这个复制因子。默认复制因子是3。\n复制因子是每个block备份的数目，nameNode保证每个block在集群中有复制因子数目的备份，不多也不少。每个block的备份分在不同的dataNode中。\n通常情况下，当复制因数是3时，HDFS的放置策略是一个数据块放置到本地机架的一个节点，另一份数据块放置到本地机架的另一个节点，最后一份数据块放置到不同机架的一个节点。这个策略减少了机架之间的通信而极大提高了写性能。机架发生故障的可能性远小于节点，这个策略并不影响数据的可靠性和可用性，但是，在读数据时，它确实降低了整体带宽，因为数据块仅放置在两个而不是三个机架上，这种策略下，一个文件的复制块没有在机架之间均匀分布，三分之一的复制块在一个节点上；三分之二的复制块在一个机架上，另三分之一的复制块均匀分布在另外的机架上。这个策略提高了写性能，没有降低数据可靠性或读性能。\n为减少全局的带宽和读延迟，HDFS尝试从离要求读的客户端最近的地方读取复制块，如果读者节点与复制块节点在同一机架上，则这个复制块优先用来满足读请求，如果HDFS集群有多个数据中心，则优先使用本地数据中心中的复制块，而不是远方的数据块。\n就近原则\nhttps://www.aboutyun.com/forum.php?mod=viewthread\u0026tid=17306 8. 安全模式 安全模式是hadoop的一种保护机制，用于保证集群中的数据块的安全性。如果HDFS处于安全模式，则表示HDFS是只读状态。\n当集群启动的时候，会首先进入安全模式。当系统处于安全模式时会检查数据块的完整性。假设我们设置的副本数（即参数dfs.replication）是5，那么在datanode上就应该有5个副本存在，假设只存在3个副本，那么比例就是3/5=0.6。在配置文件hdfs-default.xml中定义了一个最小的副本的副本率0.999\ndfs.namenode.safemode.threshold-pct\n我们的副本率0.6明显小于0.99，因此系统会自动的复制副本到其他的dataNode,使得副本率不小于0.999.如果系统中有8个副本，超过我们设定的5个副本，那么系统也会删除多余的3个副本(估计是心跳时由NameNode抉择,指定DataNode去删除)。当副本率达标后,过30秒之后,NameNode自动退出安全模式\n查看安全模式状态：hdfs dfsadmin -safemode get 进入安全模式状态：hdfs dfsadmin -safemode enter 离开安全模式状态：hdfs dfsadmin -safemode leave https://www.cnblogs.com/TiePiHeTao/p/5105682165be5a124a01c2cd06a89c64.html 9.空间回收 ​\t如果一个文件被用户或应用程序删除了，它并不立刻从HDFS中删除，相反，HDFS首先改变它的名字，将其放到/trash目录中，只要它保留在/trash中，这个文件可以迅速恢复。当/trash中的文件到达其生命期后，NameNode从HDFS命名空间中删除这个文件。删除这个文件将释放与之关联的数据块的空间。需要注意的是，用户删除一个文件的时刻与HDFS增加剩余空间的时刻之间相比，有一个适当的滞后。\n只要这个文件还在/trash目录，用户可以恢复一个删除的文件。如果用户想恢复，则他/她可以转到/trash目录，恢复这个文件。/trash目录仅包含最新的被删除文件，/trash目录与其他目录相似，除了一点特征之外：HDFS施加特别的自动删除策略给这个目录下的文件。目前，这个缺省的策略是删除超过6个小时的文件\nhttps://www.aboutyun.com/forum.php?mod=viewthread\u0026tid=17306 https://blog.csdn.net/weixin_42297075/article/details/104365795 https://www.aboutyun.com/thread-18075-1-3.html https://www.cnblogs.com/nucdy/p/5684196.html https://www.aboutyun.com/thread-17301-1-3.html https://www.aboutyun.com/forum.php?mod=viewthread\u0026tid=17304 ","wordCount":"4778","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-08-30T16:30:55.61285171Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/hadoop/hdfs.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search.html title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88.html>hadoop生态圈</a> <span>></span>
<a href=https://xiaokunji.com/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/hadoop.html>Hadoop</a> <span>></span></ul></nav><h1 class=post-title>HDFS</h1><div class=post-description></div><div class=post-meta>创建:&nbsp;<span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;更新:&nbsp;2023-08-30&nbsp;·&nbsp;10 分钟&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/hadoop%E7%94%9F%E6%80%81%E5%9C%88.html>Hadoop生态圈</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#1%e4%bb%8b%e7%bb%8d aria-label=1.介绍><strong>1.介绍</strong></a></li><li><a href=#2hdfs%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86 aria-label=2.HDFS实现原理><strong>2.HDFS实现原理</strong></a><ul><li><a href=#22-sencondary-namenode aria-label="2.2 Sencondary NameNode"><strong>2.2 Sencondary NameNode</strong></a></li><li><a href=#23-datanode aria-label="2.3 DataNode"><strong>2.3 DataNode</strong></a></li></ul></li><li><a href=#3-hdfs%e8%af%bb%e5%86%99%e6%b5%81%e7%a8%8b aria-label="3. HDFS读写流程"><strong>3. HDFS读写流程</strong></a><ul><li><a href=#31-%e5%86%99%e6%95%b0%e6%8d%ae aria-label="3.1 写数据"><strong>3.1 写数据</strong></a></li><li><a href=#32-%e6%96%87%e4%bb%b6%e8%af%bb%e5%8f%96 aria-label="3.2 文件读取"><strong>3.2 文件读取</strong></a></li></ul></li><li><a href=#4-hdfs-balancer aria-label="4. HDFS balancer"><strong>4. HDFS balancer</strong></a></li><li><a href=#5-hdfs%e5%bf%ab%e7%85%a7 aria-label="5. HDFS快照"><strong>5. HDFS快照</strong></a></li><li><a href=#6-hadoop-%e9%85%8d%e9%a2%9d%e8%ae%be%e7%bd%ae aria-label="6. Hadoop 配额设置"><strong>6. Hadoop 配额设置</strong></a><ul><li><a href=#61-%e4%bb%80%e4%b9%88%e6%98%af%e9%85%8d%e9%a2%9d aria-label="6.1 什么是配额"><strong>6.1 什么是配额</strong></a></li><li><a href=#62-%e9%85%8d%e9%a2%9d%e7%a7%8d%e7%b1%bb aria-label="6.2 配额种类"><strong>6.2 配额种类</strong></a></li></ul></li><li><a href=#7-%e5%a4%8d%e5%88%b6%e5%9b%a0%e5%ad%90 aria-label="7. 复制因子"><strong>7. 复制因子</strong></a></li><li><a href=#8-%e5%ae%89%e5%85%a8%e6%a8%a1%e5%bc%8f aria-label="8. 安全模式"><strong>8. 安全模式</strong></a></li><li><a href=#9%e7%a9%ba%e9%97%b4%e5%9b%9e%e6%94%b6 aria-label=9.空间回收><strong>9.空间回收</strong></a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=1介绍><strong>1.介绍</strong><a hidden class=anchor aria-hidden=true href=#1介绍>#</a></h1><p>一句话(官方):分布式存储系统HDFS( Hadoop Distributed File System)。 其实就是一个文件系统，类似于linux的文件系统。有目录，目录下可以存 储文件。但它又是一个分布式的文件系统。</p><p><strong>基本原理</strong></p><ol><li>将文件切分成等大的数据块，分别存储到多台机器上。</li><li>每个数据块存在多个备份。 将数据切分、容错、负载均衡等功能透明化。</li><li>可将HDFS看成是一个巨大、具有容错性的磁盘。</li></ol><p><strong>缺点</strong></p><ol><li>不适合存储大量小文件。</li><li>不适合低延迟数据访问 。</li><li>不支持多用户写入及任意修改文件 。</li></ol><h1 id=2hdfs实现原理><strong>2.HDFS实现原理</strong><a hidden class=anchor aria-hidden=true href=#2hdfs实现原理>#</a></h1><p><strong>数据块</strong></p><ol><li>每个磁盘都有默认的数据块大小，这是磁盘进行数据读/写的最小单位。构建于单个磁盘之 上的文件系统通过磁盘块来管理该文件系统中的块，该文件系统块的大小可以是磁盘块的整数倍。</li><li>HDFS 同样也有块 (block) 的概念，但是大得多，默认为 128 MB 。与单一磁盘上的文件系统相似， HDFS 上的文件也被划分为块大小的多个分块 (chunk) ，作为独立的存储单元。但与其他 文件系统不同的是， HDFS 中小于一个块大小的文件不会占据整个块的空间。(好像老版本的会占用整个空间)</li></ol><p><strong>2.1</strong> <strong>NameNode</strong></p><p>NameNode是HDFS架构中的主节点。 当NameNode启动时会从fsimage中读取数据,缩短启动时间,并会写入editlog,Namenode只有 在启动时候合并fsimage和edits log.</p><p><strong>功能</strong></p><ol><li>管理各个从节点的状态(DataNode)。</li><li>记录存储在HDFS上的所有数据的元数据信息。例如:block存储的位置，文件大小，文件权限，文件层级等等。这些信息以两个文件形式永久保存在本地磁盘上。</li></ol><ul><li><ul><li>命名空间镜像文件(FsImage): fsimage是HDFS文件系统存于硬盘中的元数据检查点，里面记录 了自最后一次检查点之前HDFS文件系统中所有目录和文件的序列化信息</li></ul></li><li><ul><li>编辑日志(edit-logs)文件:保存了自最后一次检查点之后所有针对HDFS文件系统的操作，比如: 增加文件、重命名文件、删除目录等等。</li></ul></li></ul><ol start=3><li><p>记录了存储在HDFS上文件的所有变化，例如文件被删除，namenode会记录到editlog中。</p></li><li><p>接受DataNode的心跳和各个datanode上的block报告信息，确保DataNode是否存活。</p></li><li><p>负责处理所有块的复制因子。</p></li><li><p>如果DataNode节点宕机，NameNode会选择另外一个DataNode均衡复制因子，并做负载均衡。</p></li></ol><h2 id=22-sencondary-namenode><strong>2.2 Sencondary NameNode</strong><a hidden class=anchor aria-hidden=true href=#22-sencondary-namenode>#</a></h2><p>S NameNode是NameNode的助手，不要将其理解成是NameNode的备份。Secondary NameNode 的整个目的在HDFS中提供一个Checkpoint Node，所以也被叫做checkpoint node。</p><p><strong>功能</strong></p><ol><li>定时的从NameNode获取EditLogs,并更新到FsImage上。</li><li>一旦它有新的fsimage文件，它将其拷贝回NameNode上，NameNode在下次重启时会使用这个新的fsimage文件，从而减少重启的时间。</li><li>关于NameNode是什么时候将改动 写到edit logs中的?</li></ol><p>这个操作实际上是由 DataNode的写操作触发的，当我们往 DataNode写文件时，DataNode会跟 NameNode通信，告诉NameNode什么文 件的第几个block放在它那里，NameNode 这个时候会将这些元数据信息写到edit logs文件中。</p><h2 id=23-datanode><strong>2.3 DataNode</strong><a hidden class=anchor aria-hidden=true href=#23-datanode>#</a></h2><p>DataNode是HDFS架构的从节点，管理各自节点的Block信息。</p><p><strong>功能</strong></p><ol><li>多个数据实际是存储到DataNode上面。</li><li>DataNode分别运行在独立的节点上。</li><li>DataNode执行客户端级别的读写请求。</li><li>向NameNode发送心跳(默认是3s)，报告各自节点的健康状况。</li></ol><h1 id=3-hdfs读写流程><strong>3. HDFS读写流程</strong><a hidden class=anchor aria-hidden=true href=#3-hdfs读写流程>#</a></h1><h2 id=31-写数据><strong>3.1 写数据</strong><a hidden class=anchor aria-hidden=true href=#31-写数据>#</a></h2><ol><li>client将数据分片</li><li>client请求namenode，要将多个块写入到HDFS。例如这里的Block A和Block B。</li><li>NameNode会给client赋予写权限，并为client提供可以写入数据的DataNode的IP地址。Namenode在选择可写入数据的dataNode的规则是结合了DN的健康状态、复制因子、机架感知等因素随机选择的DN。假如复制因子是3(默认值)，那么会为每个block返回三个IP地址。例如NN为client提供了以下的IP地址列表。</li><li>在写入数据之前，client首先 要确认namenode提供的ip列表 是否准备好了接收数据。Client通过连接各个块的ip列表来为 每个块创建流水线。（传递的方式）</li><li>流水线建立好以后，client将 会向流水线中写入数据（block 是并行写入的）。Client只会将block A向 DN1复制。其他节点复制是在DN 之间完成的。</li><li>当数据复制到所有的DN完成之 后，按照ip地址列表相反的方向，依次反馈写入成功的信息。</li><li>DN1将确认信息反馈给client，client再将确认信息反馈给NN， NN更新元数据信息，client关 闭pipline。</li></ol><h2 id=32-文件读取><strong>3.2 文件读取</strong><a hidden class=anchor aria-hidden=true href=#32-文件读取>#</a></h2><ol><li>Client请求namenode要读取exaple. txt文件。</li><li>NN根据自己的元数据信息，反馈给 client一个DataNode的列表(存储B lock A和B)。</li><li>Client连接DN，读取BlockA,Block B的数据。</li><li>Client合并block A和Block B的数 据。</li></ol><h1 id=4-hdfs-balancer><strong>4. HDFS balancer</strong><a hidden class=anchor aria-hidden=true href=#4-hdfs-balancer>#</a></h1><p>集群磁盘数据不均衡导致的原因有很多情况。</p><ol><li>添加新的DataNode节点。</li><li>人为干预，修改block副本数。</li><li>各个机器磁盘大小不一致。</li><li>长时间运行大量的delete操作等。</li></ol><h1 id=5-hdfs快照><strong>5. HDFS快照</strong><a hidden class=anchor aria-hidden=true href=#5-hdfs快照>#</a></h1><p>Hdfs的快照（snapshot）是在某一时间点对指定文件系统拷贝，快照采用只读模式，可以对重要数据进行恢复、防止用户错误性的操作。</p><p>快照分两种：</p><p>一种是：建立文件系统的索引，每次更新文件不会真正的改变文件，而是新开辟一个空间用来保存更改的文件，(hdfs属于该种)</p><p>一种是：拷贝所有的文件系统</p><p>和VM做快照差不多,相当于做了个备份,可以做回滚</p><ol><li>快照创建是瞬间的:成本是0(1)排除查找信息节点的时间 。</li><li>额外的内存使用仅仅当对快照进行修改时产生：内存使用时0(M),M是修改文件/目录的数量。</li><li>是一个只读的基于时间点文件系统拷贝。快照可以是整个文件系统的也可以是一部分。常用来作为数据备 份，防止用户错误和容灾。</li><li>在datanode 上面的blocks 不会复制，做Snapshot 的文件是纪录了block的列表和文件的大小，但是没有数据的复制 Snapshot 并不会影响HDFS 的正常操作:</li><li>修改会按照时间的反序记录，这样可以直接读取到最新的数据。</li><li>快照数据是 当前数据减去修改的部分计算出来的。</li><li>快照会存储在snapshottable的目录下。snapshottable下存储的snapshots 最多为65535个。没有限制snapshottable目录 的数量。管理员可以设置任何的目录成为snapshottable。如果snapshottable里面存着快照，那么文件夹不能删除或者 改名。</li></ol><h1 id=6-hadoop-配额设置><strong>6. Hadoop 配额设置</strong><a hidden class=anchor aria-hidden=true href=#6-hadoop-配额设置>#</a></h1><h2 id=61-什么是配额><strong>6.1 什么是配额</strong><a hidden class=anchor aria-hidden=true href=#61-什么是配额>#</a></h2><p>​ Hadoop 分布式文件系统(HDFS)允许管理员为每个目录设置配额,限制该目录下占用空间大小,和目录/文件数量.新建立的目录没有配额。最 大的配额是 Long.Max_Value。配额为 1 可以强制目录保持为空。</p><p>​ 目录配额是对目录树上该目录下的名字数量做硬性限制。如果创建文件或目录时超过了配额， 该操作会失败。重命名不会改变该目录的配额;如果重命名操作会导致违反配额限制，该操作 将会失败。如果尝试设置一个配额而现有文件数量已经超出了这个新配额，则设置失败。</p><p><strong>所有超出配额的操作都会失败</strong></p><p>配额和 fsimage 保持一致。当启动时，如果 fsimage 违反了某个配额限制(也许 fsimage 被偷 偷改变了)，则启动失败并生成错误报告。设置或删除一个配额会创建相应的日志记录。</p><h2 id=62-配额种类><strong>6.2 配额种类</strong><a hidden class=anchor aria-hidden=true href=#62-配额种类>#</a></h2><ol><li>Name Quotas:设置某一个目录下文件总数</li></ol><blockquote><p>从文件数目上限制</p></blockquote><ol start=2><li>Space Quotas:设置某一个目录下可使用空间大小</li></ol><blockquote><p>从空间上限制</p></blockquote><p><strong>注意</strong>：这里需要特别注意的是“Space Quota”的设置所看的不是 Hdfs 的文件大小，而是写入 Hdfs 所有 block 块的大小。包含备份的部分，而且不足一个块也要按照一个块计算</p><blockquote><p>​ hdfs 的配额管理是跟着目录走，如果目录被重命名，配额依然有效。 麻烦的是，在设置完配额以后，如果超过限制，虽然文件不会写入到 hdfs，但是文件名依然会存在，只是文件 size 为 0。当加大配额设置后，还需要将之前的空文件删除才能进一步写入。如果新设置的 quota 值，小于该目录现有的 Name Quotas 及 Space Quotas，系统并不会给 出错误提示，但是该目录的配置会变成最新设置的 quota。</p></blockquote><p><strong>设置</strong></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>启用设定:hadoop dfsadmin -setQuota 10000 /user/seamon
</span></span><span style=display:flex><span>清除設定: hadoop dfsadmin -clrQuota /user/seamon
</span></span><span style=display:flex><span>可以使用m,g,t 代表 MB,GB,TB
</span></span><span style=display:flex><span>启用设定: hadoop dfsadmin -setSpaceQuota 1g /user/seamon/ 
</span></span><span style=display:flex><span>清除設定: hadoop dfsadmin -clrSpaceQuota /user/seamon
</span></span></code></pre></div><h1 id=7-复制因子><strong>7. 复制因子</strong><a hidden class=anchor aria-hidden=true href=#7-复制因子>#</a></h1><p>HDFS为我们提供了可靠的存储，就是因为这个复制因子。默认复制因子是3。</p><p>复制因子是每个block备份的数目，nameNode保证每个block在集群中有复制因子数目的备份，不多也不少。每个block的备份分在不同的dataNode中。</p><p>通常情况下，当复制因数是3时，HDFS的放置策略是一个数据块放置到本地机架的一个节点，另一份数据块放置到本地机架的另一个节点，最后一份数据块放置到不同机架的一个节点。这个策略减少了机架之间的通信而极大提高了写性能。机架发生故障的可能性远小于节点，这个策略并不影响数据的可靠性和可用性，但是，在读数据时，它确实降低了整体带宽，因为数据块仅放置在两个而不是三个机架上，这种策略下，一个文件的复制块没有在机架之间均匀分布，三分之一的复制块在一个节点上；三分之二的复制块在一个机架上，另三分之一的复制块均匀分布在另外的机架上。这个策略提高了写性能，没有降低数据可靠性或读性能。</p><p>为减少全局的带宽和读延迟，HDFS尝试从离要求读的客户端最近的地方读取复制块，如果读者节点与复制块节点在同一机架上，则这个复制块优先用来满足读请求，如果HDFS集群有多个数据中心，则优先使用本地数据中心中的复制块，而不是远方的数据块。</p><p>就近原则</p><blockquote><p><a href="https://www.aboutyun.com/forum.php?mod=viewthread&amp;tid=17306" target=_blank rel=noopener>https://www.aboutyun.com/forum.php?mod=viewthread&tid=17306</a></p></blockquote><h1 id=8-安全模式><strong>8. 安全模式</strong><a hidden class=anchor aria-hidden=true href=#8-安全模式>#</a></h1><p>安全模式是hadoop的一种保护机制，用于保证集群中的数据块的安全性。如果HDFS处于安全模式，则表示HDFS是只读状态。</p><p><strong>当集群启动的时候，会首先进入安全模式</strong>。当系统处于安全模式时会检查数据块的完整性。假设我们设置的副本数（即参数dfs.replication）是5，那么在datanode上就应该有5个副本存在，假设只存在3个副本，那么比例就是3/5=0.6。在配置文件hdfs-default.xml中定义了一个最小的副本的副本率0.999</p><p><code>dfs.namenode.safemode.threshold-pct</code></p><p>我们的副本率0.6明显小于0.99，因此系统会自动的复制副本到其他的dataNode,使得副本率不小于0.999.如果系统中有8个副本，超过我们设定的5个副本，那么系统也会删除多余的3个副本(估计是心跳时由NameNode抉择,指定DataNode去删除)。当副本率达标后,过30秒之后,NameNode自动退出安全模式</p><ul><li>查看安全模式状态：hdfs dfsadmin -safemode get</li><li>进入安全模式状态：hdfs dfsadmin -safemode enter</li><li>离开安全模式状态：hdfs dfsadmin -safemode leave</li></ul><blockquote><p><a href=https://www.cnblogs.com/TiePiHeTao/p/5105682165be5a124a01c2cd06a89c64.html target=_blank rel=noopener>https://www.cnblogs.com/TiePiHeTao/p/5105682165be5a124a01c2cd06a89c64.html</a></p></blockquote><h1 id=9空间回收><strong>9.空间回收</strong><a hidden class=anchor aria-hidden=true href=#9空间回收>#</a></h1><p>​ 如果一个文件被用户或应用程序删除了，它并不立刻从HDFS中删除，相反，HDFS首先改变它的名字，将其放到/trash目录中，只要它保留在/trash中，这个文件可以迅速恢复。当/trash中的文件到达其生命期后，NameNode从HDFS命名空间中删除这个文件。删除这个文件将释放与之关联的数据块的空间。需要注意的是，用户删除一个文件的时刻与HDFS增加剩余空间的时刻之间相比，有一个适当的滞后。</p><p>只要这个文件还在/trash目录，用户可以恢复一个删除的文件。如果用户想恢复，则他/她可以转到/trash目录，恢复这个文件。/trash目录仅包含最新的被删除文件，/trash目录与其他目录相似，除了一点特征之外：HDFS施加特别的自动删除策略给这个目录下的文件。目前，这个缺省的策略是删除超过6个小时的文件</p><blockquote><p><a href="https://www.aboutyun.com/forum.php?mod=viewthread&amp;tid=17306" target=_blank rel=noopener>https://www.aboutyun.com/forum.php?mod=viewthread&tid=17306</a></p><p><a href=https://blog.csdn.net/weixin_42297075/article/details/104365795 target=_blank rel=noopener>https://blog.csdn.net/weixin_42297075/article/details/104365795</a></p><p><a href=https://www.aboutyun.com/thread-18075-1-3.html target=_blank rel=noopener>https://www.aboutyun.com/thread-18075-1-3.html</a></p><p><a href=https://www.cnblogs.com/nucdy/p/5684196.html target=_blank rel=noopener>https://www.cnblogs.com/nucdy/p/5684196.html</a></p><p><a href=https://www.aboutyun.com/thread-17301-1-3.html target=_blank rel=noopener>https://www.aboutyun.com/thread-17301-1-3.html</a></p><p><a href="https://www.aboutyun.com/forum.php?mod=viewthread&amp;tid=17304" target=_blank rel=noopener>https://www.aboutyun.com/forum.php?mod=viewthread&tid=17304</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/hadoop.html>Hadoop</a></li><li><a href=https://xiaokunji.com/zh/tags/hadoop%E7%94%9F%E6%80%81%E5%9C%88.html>Hadoop生态圈</a></li></ul></footer></article></main><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>