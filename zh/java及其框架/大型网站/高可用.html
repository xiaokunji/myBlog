<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>简述如何保证高可用 | 米二</title><meta name=keywords content=" **一、什么是高可用**, **二、如何保障系统的高可用**, 应用高可用, 机房高可用, 同城多活, 异地多活, **三、常见的互联网分层架构**, **四,总结**"><meta name=description content="网站高并发"><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/%E9%AB%98%E5%8F%AF%E7%94%A8.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/%E9%AB%98%E5%8F%AF%E7%94%A8.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="简述如何保证高可用"><meta property="og:description" content="网站高并发"><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/%E9%AB%98%E5%8F%AF%E7%94%A8.html"><meta property="article:section" content="java及其框架"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-11T06:15:14+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="简述如何保证高可用"><meta name=twitter:description content="网站高并发"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"简述如何保证高可用","item":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/%E9%AB%98%E5%8F%AF%E7%94%A8.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"简述如何保证高可用","name":"简述如何保证高可用","description":"网站高并发","keywords":[" **一、什么是高可用**"," **二、如何保障系统的高可用**"," 应用高可用"," 机房高可用"," 同城多活"," 异地多活"," **三、常见的互联网分层架构**"," **四,总结**"],"articleBody":"[toc]\n一、什么是高可用 **高可用HA（**High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。\n二、如何保障系统的高可用 应用高可用 我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。\n保证系统高可用，架构设计的核心准则是：冗余。\n有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。\n在流量达到系统可承受的上限时, 还得用 降级/限流/熔断 来保证系统的可用性\n对于服务状态临界值时怎么保证高可用以及数据的安全?\n引入NG的动态负载均衡, 自动剔除不正常的服务\nNginx 模块nginx_upstream_check_module了，这个模块可以让 Nginx 定期地探测后端服务的一个指定的接口，然后根据返回的状态码，来判断服务是否还存活,当探测不存活的次数达到一定阈值时，就自动将这个后端服务从负载均衡服务器中摘除。\nupstream server { server 192.168.1.1:8080; server 192.168.1.2:8080; // 检测 URL check interval=3000 rise=2 fall=5 timeout=1000 type=http default_down=t 5 check_http_send \"GET /health_check HTTP/1.0 \"; // 检测返回状态码为 200 时认为检测成功 check_http_expect_alive http_2xx; } Nginx 按照上面的方式配置之后，你的业务服务器也要实现一个“/health_check”的接口，在这个接口中返回的 HTTP 状态码，这个返回的状态码可以存储在配置中心中，这样在变更状态码时，就不需要重启服务了\n**在服务刚刚启动时，**可以初始化默认的 HTTP 状态码是 500，这样 Nginx 就不会很快将这个服务节点标记为可用，也就可以等待服务中，依赖的资源初始化完成，避免服务初始启动时的波动\n**在完全初始化之后，**再将 HTTP 状态码变更为 200，Nginx 经过两次探测后，就会标记服务为可用。在服务关闭时，也应该先将 HTTP 状态码变更为 500，等待 Nginx 探测将服务标记为不可用后，前端的流量也就不会继续发往这个服务节点。在等待服务正在处理的请求全部处理完毕之后，再对服务做重启，可以避免直接重启导致正在处理的请求失败的问题。\n或者使用灰度机制(AB区机制)\n发布部署的时候 关闭A区, 发布B区, 待A区发布完全(spring的优雅停机)且测试通过, 再开放A区, 这样A区也能解决服务初始化时的波动 和 关闭服务而丢失服务正在处理事件的情况\n机房高可用 要多机房部署, 机房本身也存在单点问题\n如此就遇到跨机房的数据传输, 数据延迟大体如下:\n北京同地双机房之间的专线延迟一般在 1ms~3ms\n国内异地双机房之间的专线延迟会在 50ms 之内\n同城多活 就是在一个城市部署多个服务节点, 保证存活(包括应用接口, 数据接口等等 )\n鉴于跨机房的数据传输存在延时, 所以应该尽可能的减少跨机房的调用\n总的来说, 所有的操作应该尽量在自己机房处理\n数据库层(mysql) 采用主从同步的方式, 各自机房,查自己的从库即可, 一般有两种方案\n基于存储系统的主从复制，比如 MySQL 和 Redis 基于消息队列的方式 虽然存在跨机房写数据的问题，不过鉴于写数据的请求量不高，所以在性能上是可以容忍的。\n服务间的调用, 也应优先调用自己机房的服务 (使用注册中心分组订阅的能力)\n异地多活 如果发生城市级的天灾人祸时, 同城多活就会出现问题, 所以要在多个城市部署多个节点 来保证存活\n大前提和同城多活一样, 业务处理尽量在自己机房处理\n同城多机房方案可以允许有跨机房数据写入的发生，但是数据的读取，和服务的调用应该尽量保证在同一个机房中。\n异地多活方案则应该避免跨机房同步的数据写入和读取，而是采取异步的方式，将数据从一个机房同步到另一个机房。\n三、常见的互联网分层架构 常见互联网分布式架构如上，分为：\n（1）客户端层：典型调用方是浏览器browser或者手机应用APP\n（2）反向代理层：系统入口，反向代理\n（3）站点应用层：实现核心应用逻辑，返回html或者json\n（4）服务层：如果实现了服务化，就有这一层\n（5）数据-缓存层：缓存加速访问存储\n（6）数据-数据库层：数据库固化数据存储\n整个系统的高可用，又是通过每一层的冗余+自动故障转移来综合实现的。\n和实现高并发一样,在每一层都做处理\n四,总结 高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。\n方法论上，高可用是通过冗余+自动故障转移来实现的。\n整个互联网分层系统架构的高可用，又是通过每一层的冗余+自动故障转移来综合实现的，具体的：\n（1）【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移\n（2）【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移\n（3）【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移\n（4）【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性\n（5）【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移\n（6）【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移\n究竟啥才是互联网架构“高可用” (qq.com) ","wordCount":"2317","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-09-11T06:15:14.573248027Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/%E9%AB%98%E5%8F%AF%E7%94%A8.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99.html>大型网站</a> <span>></span></ul></nav><h1 class=post-title>简述如何保证高可用</h1><div class=post-description>网站高并发</div><div class=post-meta>创建:&nbsp;<span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;更新:&nbsp;2023-09-11&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv>1</span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e4%bb%80%e4%b9%88%e6%98%af%e9%ab%98%e5%8f%af%e7%94%a8 aria-label=一、什么是高可用><strong>一、什么是高可用</strong></a></li><li><a href=#%e4%ba%8c%e5%a6%82%e4%bd%95%e4%bf%9d%e9%9a%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e9%ab%98%e5%8f%af%e7%94%a8 aria-label=二、如何保障系统的高可用><strong>二、如何保障系统的高可用</strong></a><ul><li><a href=#%e5%ba%94%e7%94%a8%e9%ab%98%e5%8f%af%e7%94%a8 aria-label=应用高可用>应用高可用</a></li><li><a href=#%e6%9c%ba%e6%88%bf%e9%ab%98%e5%8f%af%e7%94%a8 aria-label=机房高可用>机房高可用</a><ul><li><a href=#%e5%90%8c%e5%9f%8e%e5%a4%9a%e6%b4%bb aria-label=同城多活>同城多活</a></li><li><a href=#%e5%bc%82%e5%9c%b0%e5%a4%9a%e6%b4%bb aria-label=异地多活>异地多活</a></li></ul></li></ul></li><li><a href=#%e4%b8%89%e5%b8%b8%e8%a7%81%e7%9a%84%e4%ba%92%e8%81%94%e7%bd%91%e5%88%86%e5%b1%82%e6%9e%b6%e6%9e%84 aria-label=三、常见的互联网分层架构><strong>三、常见的互联网分层架构</strong></a></li><li><a href=#%e5%9b%9b%e6%80%bb%e7%bb%93 aria-label=四,总结><strong>四,总结</strong></a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=一什么是高可用><strong>一、什么是高可用</strong><a hidden class=anchor aria-hidden=true href=#一什么是高可用>#</a></h1><p>**高可用HA（**High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。</p><h1 id=二如何保障系统的高可用><strong>二、如何保障系统的高可用</strong><a hidden class=anchor aria-hidden=true href=#二如何保障系统的高可用>#</a></h1><h2 id=应用高可用>应用高可用<a hidden class=anchor aria-hidden=true href=#应用高可用>#</a></h2><p>我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。</p><p><strong>保证系统高可用，架构设计的核心准则是：冗余。</strong></p><p>有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“<strong>自动故障转移</strong>”来实现系统的高可用。</p><p>在流量达到系统可承受的上限时, 还得用 <strong>降级/限流/熔断</strong> 来保证系统的可用性</p><p><strong>对于服务状态临界值时怎么保证高可用以及数据的安全?</strong></p><p>引入NG的动态负载均衡, 自动剔除不正常的服务</p><p>Nginx 模块nginx_upstream_check_module了，这个模块可以让 Nginx 定期地探测后端服务的一个指定的接口，然后根据返回的状态码，来判断服务是否还存活,当探测不存活的次数达到一定阈值时，就自动将这个后端服务从负载均衡服务器中摘除。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#f85149>upstream</span> <span style=color:#f85149>server</span> {
</span></span><span style=display:flex><span>	<span style=color:#f85149>server</span> <span style=color:#f85149>192.168.1.1:8080;</span>
</span></span><span style=display:flex><span>	<span style=color:#f85149>server</span> <span style=color:#f85149>192.168.1.2:8080;</span>
</span></span><span style=display:flex><span>	<span style=color:#8b949e;font-style:italic>// 检测 URL
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	<span style=color:#f85149>check</span> <span style=color:#f85149>interval=3000</span> <span style=color:#f85149>rise=2</span> <span style=color:#f85149>fall=5</span> <span style=color:#f85149>timeout=1000</span> <span style=color:#f85149>type=http</span> <span style=color:#f85149>default_down=t</span> <span style=color:#f85149>5</span> <span style=color:#f85149>check_http_send</span> <span style=color:#7ee787>&#34;GET /health_check HTTP/1.0
</span></span></span><span style=display:flex><span><span style=color:#7ee787>
</span></span></span><span style=display:flex><span><span style=color:#7ee787>&#34;</span><span style=color:#f85149>;</span>
</span></span><span style=display:flex><span>	<span style=color:#8b949e;font-style:italic>// 检测返回状态码为 200 时认为检测成功
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	<span style=color:#f85149>check_http_expect_alive</span> <span style=color:#f85149>http_</span><span style=color:#a5d6ff>2</span><span style=color:#f85149>xx;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nginx 按照上面的方式配置之后，你的业务服务器也要实现一个“/health_check”的接口，在这个接口中返回的 HTTP 状态码，这个返回的状态码可以存储在配置中心中，这样在变更状态码时，就不需要重启服务了</p><p>**在服务刚刚启动时，**可以初始化默认的 HTTP 状态码是 500，这样 Nginx 就不会很快将这个服务节点标记为可用，也就可以等待服务中，依赖的资源初始化完成，避免服务初始启动时的波动</p><p>**在完全初始化之后，**再将 HTTP 状态码变更为 200，Nginx 经过两次探测后，就会标记服务为可用。在服务关闭时，也应该先将 HTTP 状态码变更为 500，等待 Nginx 探测将服务标记为不可用后，前端的流量也就不会继续发往这个服务节点。在等待服务正在处理的请求全部处理完毕之后，再对服务做重启，可以避免直接重启导致正在处理的请求失败的问题。</p><blockquote><p>或者使用灰度机制(AB区机制)</p><p><strong>发布部署的时候</strong> 关闭A区, 发布B区, 待A区发布完全(spring的优雅停机)且测试通过, 再开放A区, 这样A区也能解决<u>服务初始化时的波动</u> 和 <u>关闭服务而丢失服务正在处理事件的情况</u></p></blockquote><h2 id=机房高可用>机房高可用<a hidden class=anchor aria-hidden=true href=#机房高可用>#</a></h2><p>要多机房部署, 机房本身也存在单点问题</p><blockquote><p>如此就遇到跨机房的数据传输, 数据延迟大体如下:</p><p>北京同地双机房之间的专线延迟一般在 1ms~3ms</p><p>国内异地双机房之间的专线延迟会在 50ms 之内</p></blockquote><h3 id=同城多活>同城多活<a hidden class=anchor aria-hidden=true href=#同城多活>#</a></h3><p>就是在一个城市部署多个服务节点, 保证存活(包括应用接口, 数据接口等等 )</p><p>鉴于跨机房的数据传输存在延时, 所以应该<strong>尽可能的减少跨机房的调用</strong></p><blockquote><p>总的来说, 所有的操作应该尽量在自己机房处理</p></blockquote><p><strong>数据库层(mysql)</strong> 采用主从同步的方式, 各自机房,查自己的从库即可, 一般有两种方案</p><ol><li>基于存储系统的主从复制，比如 MySQL 和 Redis</li><li>基于消息队列的方式</li></ol><blockquote><p>虽然存在跨机房写数据的问题，不过鉴于写数据的请求量不高，所以在性能上是可以容忍的。</p></blockquote><p><img loading=lazy src=%E9%AB%98%E5%8F%AF%E7%94%A8.assets/image-20220819150355254-16608926376443.png alt=image-20220819150355254></p><p><strong>服务间的调用</strong>, 也应优先调用自己机房的服务 (使用注册中心分组订阅的能力)</p><p><img loading=lazy src=%E9%AB%98%E5%8F%AF%E7%94%A8.assets/image-20220819150540287-16608927412365.png alt=image-20220819150540287></p><h3 id=异地多活>异地多活<a hidden class=anchor aria-hidden=true href=#异地多活>#</a></h3><p>如果发生城市级的天灾人祸时, 同城多活就会出现问题, 所以要在多个城市部署多个节点 来保证存活</p><blockquote><p>大前提和同城多活一样, 业务处理尽量在自己机房处理</p></blockquote><p>同城多机房方案可以允许有跨机房数据写入的发生，但是数据的读取，和服务的调用应该尽量保证在同一个机房中。</p><p>异地多活方案则应该避免跨机房同步的数据写入和读取，而是采取异步的方式，将数据从一个机房同步到另一个机房。</p><h1 id=三常见的互联网分层架构><strong>三、常见的互联网分层架构</strong><a hidden class=anchor aria-hidden=true href=#三常见的互联网分层架构>#</a></h1><p><img loading=lazy src=%E9%AB%98%E5%8F%AF%E7%94%A8.assets/image-20230908115237760.png alt=image-20230908115237760></p><p>常见互联网分布式架构如上，分为：</p><p>（1）<strong>客户端层</strong>：典型调用方是浏览器browser或者手机应用APP</p><p>（2）<strong>反向代理层</strong>：系统入口，反向代理</p><p>（3）<strong>站点应用层</strong>：实现核心应用逻辑，返回html或者json</p><p>（4）<strong>服务层</strong>：如果实现了服务化，就有这一层</p><p>（5）<strong>数据-缓存层</strong>：缓存加速访问存储</p><p>（6）<strong>数据-数据库层</strong>：数据库固化数据存储</p><p>整个系统的高可用，又是通过每一层的<strong>冗余+自动故障转移</strong>来综合实现的。</p><p><strong>和实现高并发一样,在每一层都做处理</strong></p><h1 id=四总结><strong>四,总结</strong><a hidden class=anchor aria-hidden=true href=#四总结>#</a></h1><p>高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。</p><p>方法论上，高可用是通过<strong>冗余+自动故障转移</strong>来实现的。</p><p>整个互联网分层系统架构的高可用，又是通过每一层的<strong>冗余+自动故障转移</strong>来综合实现的，具体的：</p><p>（1）【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移</p><p>（2）【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移</p><p>（3）【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移</p><p>（4）【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性</p><p>（5）【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移</p><p>（6）【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959728&amp;idx=1&amp;sn=933227840ec8cdc35d3a33ae3fe97ec5" target=_blank rel=noopener>究竟啥才是互联网架构“高可用” (qq.com)</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99.html>大型网站</a></li><li><a href=https://xiaokunji.com/zh/tags/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/%E9%AB%98%E5%B9%B6%E5%8F%91.html><span class=title>« 上一页</span><br><span>简述如何保证高并发</span></a>
<a class=next href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E8%BF%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html><span class=title>下一页 »</span><br><span>简述设计模式</span></a></nav></footer></article></main><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>