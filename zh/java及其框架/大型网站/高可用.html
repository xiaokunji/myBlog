<!DOCTYPE html>
<html dir="auto" lang="zh"><head><meta charset="utf-8"/><meta content="IE=edge" http-equiv="x-ua-compatible"/><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name="viewport"/><meta content="index, follow" name="robots"/><title>简述如何保证高可用 | 米二</title><meta content=" **一、什么是高可用**, **二、如何保障系统的高可用**, 应用高可用, 机房高可用, 同城多活, 异地多活, **三、常见的互联网分层架构**, **四,总结**" name="keywords"/><meta content="网站高并发" name="description"/><meta content="xkj" name="author"/><link href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/%E9%AB%98%E5%8F%AF%E7%94%A8.html" rel="canonical"/><link as="style" crossorigin="anonymous" href="/assets/css/stylesheet.dc6bd2c841ee388e899e13872ae986c0e847e8b957d6714ad6ddc628ef2d17ff.css" integrity="sha256-3GvSyEHuOI6JnhOHKumGwOhH6LlX1nFK1t3GKO8tF/8=" rel="preload stylesheet"/><script crossorigin="anonymous" defer="" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload="hljs.initHighlightingOnLoad()" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js"></script>
<link href="https://xiaokunji.com/img/Q.svg" rel="icon"/><link href="https://xiaokunji.com/img/Q.svg" rel="icon" sizes="16x16" type="image/png"/><link href="https://xiaokunji.com/img/Q.svg" rel="icon" sizes="32x32" type="image/png"/><link href="https://xiaokunji.com/Q.svg" rel="apple-touch-icon"/><link href="https://xiaokunji.com/Q.svg" rel="mask-icon"/><meta content="#2e2e33" name="theme-color"/><meta content="#2e2e33" name="msapplication-TileColor"/><link href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/%E9%AB%98%E5%8F%AF%E7%94%A8.html" hreflang="zh" rel="alternate"/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta content="简述如何保证高可用" property="og:title"/><meta content="网站高并发" property="og:description"/><meta content="article" property="og:type"/><meta content="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/%E9%AB%98%E5%8F%AF%E7%94%A8.html" property="og:url"/><meta content="java及其框架" property="article:section"/><meta content="2023-08-22T00:00:00+00:00" property="article:published_time"/><meta content="2023-09-08T12:01:12+08:00" property="article:modified_time"/><meta content="summary" name="twitter:card"/><meta content="简述如何保证高可用" name="twitter:title"/><meta content="网站高并发" name="twitter:description"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"简述如何保证高可用","item":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/%E9%AB%98%E5%8F%AF%E7%94%A8.html"}]}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"简述如何保证高可用","name":"简述如何保证高可用","description":"网站高并发","keywords":[" **一、什么是高可用**"," **二、如何保障系统的高可用**"," 应用高可用"," 机房高可用"," 同城多活"," 异地多活"," **三、常见的互联网分层架构**"," **四,总结**"],"articleBody":"[toc]\n一、什么是高可用 **高可用HA（**High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。\n二、如何保障系统的高可用 应用高可用 我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。\n保证系统高可用，架构设计的核心准则是：冗余。\n有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。\n在流量达到系统可承受的上限时, 还得用 降级/限流/熔断 来保证系统的可用性\n对于服务状态临界值时怎么保证高可用以及数据的安全?\n引入NG的动态负载均衡, 自动剔除不正常的服务\nNginx 模块nginx_upstream_check_module了，这个模块可以让 Nginx 定期地探测后端服务的一个指定的接口，然后根据返回的状态码，来判断服务是否还存活,当探测不存活的次数达到一定阈值时，就自动将这个后端服务从负载均衡服务器中摘除。\nupstream server { server 192.168.1.1:8080; server 192.168.1.2:8080; // 检测 URL check interval=3000 rise=2 fall=5 timeout=1000 type=http default_down=t 5 check_http_send \"GET /health_check HTTP/1.0 \"; // 检测返回状态码为 200 时认为检测成功 check_http_expect_alive http_2xx; } Nginx 按照上面的方式配置之后，你的业务服务器也要实现一个“/health_check”的接口，在这个接口中返回的 HTTP 状态码，这个返回的状态码可以存储在配置中心中，这样在变更状态码时，就不需要重启服务了\n**在服务刚刚启动时，**可以初始化默认的 HTTP 状态码是 500，这样 Nginx 就不会很快将这个服务节点标记为可用，也就可以等待服务中，依赖的资源初始化完成，避免服务初始启动时的波动\n**在完全初始化之后，**再将 HTTP 状态码变更为 200，Nginx 经过两次探测后，就会标记服务为可用。在服务关闭时，也应该先将 HTTP 状态码变更为 500，等待 Nginx 探测将服务标记为不可用后，前端的流量也就不会继续发往这个服务节点。在等待服务正在处理的请求全部处理完毕之后，再对服务做重启，可以避免直接重启导致正在处理的请求失败的问题。\n或者使用灰度机制(AB区机制)\n发布部署的时候 关闭A区, 发布B区, 待A区发布完全(spring的优雅停机)且测试通过, 再开放A区, 这样A区也能解决服务初始化时的波动 和 关闭服务而丢失服务正在处理事件的情况\n机房高可用 要多机房部署, 机房本身也存在单点问题\n如此就遇到跨机房的数据传输, 数据延迟大体如下:\n北京同地双机房之间的专线延迟一般在 1ms~3ms\n国内异地双机房之间的专线延迟会在 50ms 之内\n同城多活 就是在一个城市部署多个服务节点, 保证存活(包括应用接口, 数据接口等等 )\n鉴于跨机房的数据传输存在延时, 所以应该尽可能的减少跨机房的调用\n总的来说, 所有的操作应该尽量在自己机房处理\n数据库层(mysql) 采用主从同步的方式, 各自机房,查自己的从库即可, 一般有两种方案\n基于存储系统的主从复制，比如 MySQL 和 Redis 基于消息队列的方式 虽然存在跨机房写数据的问题，不过鉴于写数据的请求量不高，所以在性能上是可以容忍的。\n服务间的调用, 也应优先调用自己机房的服务 (使用注册中心分组订阅的能力)\n异地多活 如果发生城市级的天灾人祸时, 同城多活就会出现问题, 所以要在多个城市部署多个节点 来保证存活\n大前提和同城多活一样, 业务处理尽量在自己机房处理\n同城多机房方案可以允许有跨机房数据写入的发生，但是数据的读取，和服务的调用应该尽量保证在同一个机房中。\n异地多活方案则应该避免跨机房同步的数据写入和读取，而是采取异步的方式，将数据从一个机房同步到另一个机房。\n三、常见的互联网分层架构 常见互联网分布式架构如上，分为：\n（1）客户端层：典型调用方是浏览器browser或者手机应用APP\n（2）反向代理层：系统入口，反向代理\n（3）站点应用层：实现核心应用逻辑，返回html或者json\n（4）服务层：如果实现了服务化，就有这一层\n（5）数据-缓存层：缓存加速访问存储\n（6）数据-数据库层：数据库固化数据存储\n整个系统的高可用，又是通过每一层的冗余+自动故障转移来综合实现的。\n和实现高并发一样,在每一层都做处理\n四,总结 高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。\n方法论上，高可用是通过冗余+自动故障转移来实现的。\n整个互联网分层系统架构的高可用，又是通过每一层的冗余+自动故障转移来综合实现的，具体的：\n（1）【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移\n（2）【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移\n（3）【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移\n（4）【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性\n（5）【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移\n（6）【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移\n究竟啥才是互联网架构“高可用” (qq.com) ","wordCount":"2317","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-09-08T12:01:12+08:00","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/%E9%AB%98%E5%8F%AF%E7%94%A8.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class="dark" id="top"><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class="header"><nav class="nav"><div class="logo"><a accesskey="h" href="https://xiaokunji.com/zh/" title="米二 (Alt + H)"><img alt="" aria-label="logo" height="35" src="https://xiaokunji.com/img/Q.svg"/>米二</a><div class="logo-switches"><button accesskey="t" id="theme-toggle" title="(Alt + T)"><svg fill="none" height="18" id="moon" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg><svg fill="none" height="18" id="sun" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="5"></circle><line x1="12" x2="12" y1="1" y2="3"></line><line x1="12" x2="12" y1="21" y2="23"></line><line x1="4.22" x2="5.64" y1="4.22" y2="5.64"></line><line x1="18.36" x2="19.78" y1="18.36" y2="19.78"></line><line x1="1" x2="3" y1="12" y2="12"></line><line x1="21" x2="23" y1="12" y2="12"></line><line x1="4.22" x2="5.64" y1="19.78" y2="18.36"></line><line x1="18.36" x2="19.78" y1="5.64" y2="4.22"></line></svg></button><ul class="lang-switch"><li>|</li><li><a aria-label="English" href="https://xiaokunji.com/en/" title="English">English</a></li></ul></div></div><ul id="menu"><li><a href="https://xiaokunji.com/zh/" title="🏠主页"><span>🏠主页</span></a></li><li><a accesskey="/" href="https://xiaokunji.com/zh/search" title="🔍搜索 (Alt + /)"><span>🔍搜索</span></a></li><li><a href="https://xiaokunji.com/zh/post.html" title="📚文章"><span>📚文章</span></a></li><li><a href="https://xiaokunji.com/zh/archives.html" title="⏱时间轴"><span>⏱时间轴</span></a></li><li><a href="https://xiaokunji.com/zh/tags.html" title="🔖标签"><span>🔖标签</span></a></li><li><a href="https://xiaokunji.com/zh/categories.html" title="📖分类"><span>📖分类</span></a></li><li><a href="https://xiaokunji.com/zh/links.html" title="🤝友链"><span>🤝友链</span></a></li></ul></nav></header><main class="main"><article class="post-single"><header class="post-header"><nav aria-label="breadcrumb"><ul><a href="https://xiaokunji.com/zh/">🏠</a> <span>&gt;</span>
<a href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html">java及其框架</a> <span>&gt;</span>
<a href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99.html">大型网站</a> <span>&gt;</span></ul></nav><h1 class="post-title">简述如何保证高可用</h1><div class="post-description">网站高并发</div><div class="post-meta">创建: <span title="2023-08-22 00:00:00 +0000 UTC">2023-08-22</span> · 更新: 2023-09-08 · xkj
 | 分类:  <ul class="post-categories-meta" style="display:inline"><a href="https://xiaokunji.com/zh/categories/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html">java及其框架</a></ul><span id="busuanzi_container_page_pv"> | 访问: <span id="busuanzi_value_page_pv">1</span></span></div></header><aside class="toc-container wide" id="toc-container"><div class="toc"><details open=""><summary accesskey="c" title="(Alt + C)"><span class="details">目录</span></summary><div class="inner"><ul><li><a aria-label="一、什么是高可用" href="#%e4%b8%80%e4%bb%80%e4%b9%88%e6%98%af%e9%ab%98%e5%8f%af%e7%94%a8"><strong>一、什么是高可用</strong></a></li><li><a aria-label="二、如何保障系统的高可用" href="#%e4%ba%8c%e5%a6%82%e4%bd%95%e4%bf%9d%e9%9a%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e9%ab%98%e5%8f%af%e7%94%a8"><strong>二、如何保障系统的高可用</strong></a><ul><li><a aria-label="应用高可用" href="#%e5%ba%94%e7%94%a8%e9%ab%98%e5%8f%af%e7%94%a8">应用高可用</a></li><li><a aria-label="机房高可用" href="#%e6%9c%ba%e6%88%bf%e9%ab%98%e5%8f%af%e7%94%a8">机房高可用</a><ul><li><a aria-label="同城多活" href="#%e5%90%8c%e5%9f%8e%e5%a4%9a%e6%b4%bb">同城多活</a></li><li><a aria-label="异地多活" href="#%e5%bc%82%e5%9c%b0%e5%a4%9a%e6%b4%bb">异地多活</a></li></ul></li></ul></li><li><a aria-label="三、常见的互联网分层架构" href="#%e4%b8%89%e5%b8%b8%e8%a7%81%e7%9a%84%e4%ba%92%e8%81%94%e7%bd%91%e5%88%86%e5%b1%82%e6%9e%b6%e6%9e%84"><strong>三、常见的互联网分层架构</strong></a></li><li><a aria-label="四,总结" href="#%e5%9b%9b%e6%80%bb%e7%bb%93"><strong>四,总结</strong></a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class="post-content"><p>[toc]</p><h1 id="一什么是高可用"><strong>一、什么是高可用</strong><a aria-hidden="true" class="anchor" hidden="" href="#一什么是高可用">#</a></h1><p>**高可用HA（**High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。</p><h1 id="二如何保障系统的高可用"><strong>二、如何保障系统的高可用</strong><a aria-hidden="true" class="anchor" hidden="" href="#二如何保障系统的高可用">#</a></h1><h2 id="应用高可用">应用高可用<a aria-hidden="true" class="anchor" hidden="" href="#应用高可用">#</a></h2><p>我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。</p><p><strong>保证系统高可用，架构设计的核心准则是：冗余。</strong></p><p>有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“<strong>自动故障转移</strong>”来实现系统的高可用。</p><p>在流量达到系统可承受的上限时, 还得用 <strong>降级/限流/熔断</strong> 来保证系统的可用性</p><p><strong>对于服务状态临界值时怎么保证高可用以及数据的安全?</strong></p><p>引入NG的动态负载均衡, 自动剔除不正常的服务</p><p>Nginx 模块nginx_upstream_check_module了，这个模块可以让 Nginx 定期地探测后端服务的一个指定的接口，然后根据返回的状态码，来判断服务是否还存活,当探测不存活的次数达到一定阈值时，就自动将这个后端服务从负载均衡服务器中摘除。</p><div class="highlight"><pre style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-json" data-lang="json"><span style="display:flex"><span><span style="color:#f85149">upstream</span> <span style="color:#f85149">server</span> {
</span></span><span style="display:flex"><span>	<span style="color:#f85149">server</span> <span style="color:#f85149">192.168.1.1:8080;</span>
</span></span><span style="display:flex"><span>	<span style="color:#f85149">server</span> <span style="color:#f85149">192.168.1.2:8080;</span>
</span></span><span style="display:flex"><span>	<span style="color:#8b949e;font-style:italic">// 检测 URL
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#f85149">check</span> <span style="color:#f85149">interval=3000</span> <span style="color:#f85149">rise=2</span> <span style="color:#f85149">fall=5</span> <span style="color:#f85149">timeout=1000</span> <span style="color:#f85149">type=http</span> <span style="color:#f85149">default_down=t</span> <span style="color:#f85149">5</span> <span style="color:#f85149">check_http_send</span> <span style="color:#7ee787">"GET /health_check HTTP/1.0
</span></span></span><span style="display:flex"><span><span style="color:#7ee787">
</span></span></span><span style="display:flex"><span><span style="color:#7ee787">"</span><span style="color:#f85149">;</span>
</span></span><span style="display:flex"><span>	<span style="color:#8b949e;font-style:italic">// 检测返回状态码为 200 时认为检测成功
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#f85149">check_http_expect_alive</span> <span style="color:#f85149">http_</span><span style="color:#a5d6ff">2</span><span style="color:#f85149">xx;</span>
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>Nginx 按照上面的方式配置之后，你的业务服务器也要实现一个“/health_check”的接口，在这个接口中返回的 HTTP 状态码，这个返回的状态码可以存储在配置中心中，这样在变更状态码时，就不需要重启服务了</p><p>**在服务刚刚启动时，**可以初始化默认的 HTTP 状态码是 500，这样 Nginx 就不会很快将这个服务节点标记为可用，也就可以等待服务中，依赖的资源初始化完成，避免服务初始启动时的波动</p><p>**在完全初始化之后，**再将 HTTP 状态码变更为 200，Nginx 经过两次探测后，就会标记服务为可用。在服务关闭时，也应该先将 HTTP 状态码变更为 500，等待 Nginx 探测将服务标记为不可用后，前端的流量也就不会继续发往这个服务节点。在等待服务正在处理的请求全部处理完毕之后，再对服务做重启，可以避免直接重启导致正在处理的请求失败的问题。</p><blockquote><p>或者使用灰度机制(AB区机制)</p><p><strong>发布部署的时候</strong> 关闭A区, 发布B区, 待A区发布完全(spring的优雅停机)且测试通过, 再开放A区, 这样A区也能解决<u>服务初始化时的波动</u> 和 <u>关闭服务而丢失服务正在处理事件的情况</u></p></blockquote><h2 id="机房高可用">机房高可用<a aria-hidden="true" class="anchor" hidden="" href="#机房高可用">#</a></h2><p>要多机房部署, 机房本身也存在单点问题</p><blockquote><p>如此就遇到跨机房的数据传输, 数据延迟大体如下:</p><p>北京同地双机房之间的专线延迟一般在 1ms~3ms</p><p>国内异地双机房之间的专线延迟会在 50ms 之内</p></blockquote><h3 id="同城多活">同城多活<a aria-hidden="true" class="anchor" hidden="" href="#同城多活">#</a></h3><p>就是在一个城市部署多个服务节点, 保证存活(包括应用接口, 数据接口等等 )</p><p>鉴于跨机房的数据传输存在延时, 所以应该<strong>尽可能的减少跨机房的调用</strong></p><blockquote><p>总的来说, 所有的操作应该尽量在自己机房处理</p></blockquote><p><strong>数据库层(mysql)</strong> 采用主从同步的方式, 各自机房,查自己的从库即可, 一般有两种方案</p><ol><li>基于存储系统的主从复制，比如 MySQL 和 Redis</li><li>基于消息队列的方式</li></ol><blockquote><p>虽然存在跨机房写数据的问题，不过鉴于写数据的请求量不高，所以在性能上是可以容忍的。</p></blockquote><p><img alt="image-20220819150355254" loading="lazy" src="%E9%AB%98%E5%8F%AF%E7%94%A8.assets/image-20220819150355254-16608926376443.png"/></p><p><strong>服务间的调用</strong>, 也应优先调用自己机房的服务 (使用注册中心分组订阅的能力)</p><p><img alt="image-20220819150540287" loading="lazy" src="%E9%AB%98%E5%8F%AF%E7%94%A8.assets/image-20220819150540287-16608927412365.png"/></p><h3 id="异地多活">异地多活<a aria-hidden="true" class="anchor" hidden="" href="#异地多活">#</a></h3><p>如果发生城市级的天灾人祸时, 同城多活就会出现问题, 所以要在多个城市部署多个节点 来保证存活</p><blockquote><p>大前提和同城多活一样, 业务处理尽量在自己机房处理</p></blockquote><p>同城多机房方案可以允许有跨机房数据写入的发生，但是数据的读取，和服务的调用应该尽量保证在同一个机房中。</p><p>异地多活方案则应该避免跨机房同步的数据写入和读取，而是采取异步的方式，将数据从一个机房同步到另一个机房。</p><h1 id="三常见的互联网分层架构"><strong>三、常见的互联网分层架构</strong><a aria-hidden="true" class="anchor" hidden="" href="#三常见的互联网分层架构">#</a></h1><p><img alt="image-20230908115237760" loading="lazy" src="%E9%AB%98%E5%8F%AF%E7%94%A8.assets/image-20230908115237760.png"/></p><p>常见互联网分布式架构如上，分为：</p><p>（1）<strong>客户端层</strong>：典型调用方是浏览器browser或者手机应用APP</p><p>（2）<strong>反向代理层</strong>：系统入口，反向代理</p><p>（3）<strong>站点应用层</strong>：实现核心应用逻辑，返回html或者json</p><p>（4）<strong>服务层</strong>：如果实现了服务化，就有这一层</p><p>（5）<strong>数据-缓存层</strong>：缓存加速访问存储</p><p>（6）<strong>数据-数据库层</strong>：数据库固化数据存储</p><p>整个系统的高可用，又是通过每一层的<strong>冗余+自动故障转移</strong>来综合实现的。</p><p><strong>和实现高并发一样,在每一层都做处理</strong></p><h1 id="四总结"><strong>四,总结</strong><a aria-hidden="true" class="anchor" hidden="" href="#四总结">#</a></h1><p>高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。</p><p>方法论上，高可用是通过<strong>冗余+自动故障转移</strong>来实现的。</p><p>整个互联网分层系统架构的高可用，又是通过每一层的<strong>冗余+自动故障转移</strong>来综合实现的，具体的：</p><p>（1）【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移</p><p>（2）【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移</p><p>（3）【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移</p><p>（4）【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性</p><p>（5）【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移</p><p>（6）【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959728&amp;idx=1&amp;sn=933227840ec8cdc35d3a33ae3fe97ec5" rel="noopener" target="_blank">究竟啥才是互联网架构“高可用” (qq.com)</a></p></blockquote></div><footer class="post-footer"><ul class="post-tags"><li><a href="https://xiaokunji.com/zh/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99.html">大型网站</a></li><li><a href="https://xiaokunji.com/zh/tags/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html">java及其框架</a></li></ul><nav class="paginav"><a class="prev" href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99/%E9%AB%98%E5%B9%B6%E5%8F%91.html"><span class="title">« 上一页</span><br/><span>简述如何保证高并发</span></a>
<a class="next" href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E8%BF%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><span class="title">下一页 »</span><br/><span>简述设计模式</span></a></nav></footer></article></main><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><footer class="footer"><span>Copyright
©
-2024
<a href="https://xiaokunji.com/zh/" style="color:#939393">米二</a>
All Rights Reserved</span>
<span id="busuanzi_container"><span class="fa fa-user">用户数:</span><span id="busuanzi_value_site_uv"></span>
<span class="fa fa-eye">访问数:</span><span id="busuanzi_value_site_pv"></span></span></footer><a accesskey="g" aria-label="go to top" class="top-link" href="#top" id="top-link" title="Go to Top (Alt + G)"><svg fill="currentcolor" viewbox="0 0 12 6" xmlns="http://www.w3.org/2000/svg"><path d="M12 6H0l6-6z"></path></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>