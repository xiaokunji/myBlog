<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>介绍 | 米二</title><meta name=keywords content=" Seata 是什么?, Seata 整体工作流程, XID, 核心组件, 四种模式,  AT 模式, AT 模式的前提, 整体机制, 工作机制, 一阶段,  二阶段-回滚, 二阶段-提交, TCC 模式, 什么是 TCC, Seata TCC 模式, 如何控制异常, 如何处理空回滚, 如何处理幂等, 如何处理悬挂, Saga模式    , A模式  "><meta name=description content="seata原理介绍"><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/seata/%E4%BB%8B%E7%BB%8D.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/seata/%E4%BB%8B%E7%BB%8D.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="介绍"><meta property="og:description" content="seata原理介绍"><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/seata/%E4%BB%8B%E7%BB%8D.html"><meta property="article:section" content="java及其框架"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-04T07:23:55+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="介绍"><meta name=twitter:description content="seata原理介绍"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"介绍","item":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/seata/%E4%BB%8B%E7%BB%8D.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"介绍","name":"介绍","description":"seata原理介绍","keywords":[" Seata 是什么?"," Seata 整体工作流程"," XID"," 核心组件"," 四种模式","  AT 模式"," AT 模式的前提"," 整体机制"," 工作机制"," 一阶段","  二阶段-回滚"," 二阶段-提交"," TCC 模式"," 什么是 TCC"," Seata TCC 模式"," 如何控制异常"," 如何处理空回滚"," 如何处理幂等"," 如何处理悬挂"," Saga模式    "," A模式  "],"articleBody":"[toc]\nSeata 是什么? Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。\nSeata 整体工作流程 Seata 对分布式事务的协调和控制，主要是通过 XID 和 3 个核心组件实现的。\nXID XID 是全局事务的唯一标识，它可以在服务的调用链路中传递，绑定到服务的事务上下文中。\n核心组件 Seata 定义了 3 个核心组件：\nTC（Transaction Coordinator）：事务协调器，它是事务的协调者（这里指的是 Seata 服务器），主要负责维护全局事务和分支事务的状态，驱动全局事务提交或回滚。 TM（Transaction Manager）：事务管理器，它是事务的发起者，负责定义全局事务的范围，并根据 TC 维护的全局事务和分支事务状态，做出开始事务、提交事务、回滚事务的决议。 RM（Resource Manager）：资源管理器，它是资源的管理者（这里可以将其理解为各服务使用的数据库）。它负责管理分支事务上的资源，向 TC 注册分支事务，汇报分支事务状态，驱动分支事务的提交或回滚。 以上三个组件相互协作，TC 以 Seata 服务器（Server）形式独立部署，TM 和 RM 则是以 Seata Client 的形式集成在微服务中运行，其整体工作流程如下图。\nSeata 的整体工作流程如下：\nTM 向 TC 申请开启一个全局事务，全局事务创建成功后，TC 会针对这个全局事务生成一个全局唯一的 XID； XID 通过服务的调用链传递到其他服务; RM 向 TC 注册一个分支事务，并将其纳入 XID 对应全局事务的管辖； TM 根据 TC 收集的各个分支事务的执行结果，向 TC 发起全局事务提交或回滚决议； TC 调度 XID 下管辖的所有分支事务完成提交或回滚操作。 四种模式 Seata 提供了 AT、TCC、SAGA 和 XA 四种事务模式，可以快速有效地对分布式事务进行控制。\n在这四种事务模式中使用最多，最方便的就是 AT 模式。与其他事务模式相比，AT 模式可以应对大多数的业务场景，且基本可以做到无业务入侵，开发人员能够有更多的精力关注于业务逻辑开发。\nAT 模式 AT: Automatic Transaction\nAT 模式的前提 任何应用想要使用 Seata 的 AT 模式对分布式事务进行控制，必须满足以下 2 个前提：\n必须使用支持本地 ACID 事务特性的关系型数据库，例如 MySQL、Oracle 等； 应用程序必须是使用 JDBC 对数据库进行访问的 JAVA 应用。 整体机制 两阶段提交协议的演变：\n一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。 二阶段： 提交异步化，非常快速地完成。 回滚通过一阶段的回滚日志进行反向补偿。 工作机制 以一个示例来说明整个 AT 分支的工作过程。\n业务表：product\nField Type Key id bigint(20) PRI name varchar(100) since varchar(100) AT 分支事务的业务逻辑：\nupdate product set name = 'GTS' where name = 'TXC'; 一阶段 过程：\n解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name = ‘TXC’）等相关的信息。 查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。 select id, name, since from product where name = 'TXC'; 得到前镜像：\nid name since 1 TXC 2014 执行业务 SQL：更新这条记录的 name 为 ‘GTS’。\n查询后镜像：根据前镜像的结果，通过 主键 定位数据。\nselect id, name, since from product where id = 1; 得到后镜像：\nid name since 1 GTS 2014 插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 UNDO_LOG 表中。 { \"branchId\": 641789253, \"undoItems\": [{ \"afterImage\": { \"rows\": [{ \"fields\": [{ \"name\": \"id\", \"type\": 4, \"value\": 1 }, { \"name\": \"name\", \"type\": 12, \"value\": \"GTS\" }, { \"name\": \"since\", \"type\": 12, \"value\": \"2014\" }] }], \"tableName\": \"product\" }, \"beforeImage\": { \"rows\": [{ \"fields\": [{ \"name\": \"id\", \"type\": 4, \"value\": 1 }, { \"name\": \"name\", \"type\": 12, \"value\": \"TXC\" }, { \"name\": \"since\", \"type\": 12, \"value\": \"2014\" }] }], \"tableName\": \"product\" }, \"sqlType\": \"UPDATE\" }], \"xid\": \"xid:xxx\" } 提交前，向 TC 注册分支：申请 product 表中，主键值等于 1 的记录的 全局锁 。 本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。 将本地事务提交的结果上报给 TC。 CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 二阶段-回滚 收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。 通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。 数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。 根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句： update product set name = 'TXC' where id = 1; 提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。 第三点中是无法处理的情况, seata使用 @GlobalLock+@Transactional或 @GlobalTransaction 来加了全局锁, 在回滚完成前, 其他请求将被阻塞, 如果真的出现了这种情况, 可自定义实现FailureHandler做邮件通知或其他\nSeata常见问题 脏写导致数据回滚失败？ 二阶段-提交 收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。 异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。 总结:\n第一阶段是把 所有要修改的数据存在seata的UNDO_LOG表里(修改前的数据),并拿到全局锁\n第二阶段 看执行结果决定是回滚还是提交\n​\t2.1 如果是回滚: 则把UNDO_LOG里对应的数据写回去\n​ 2.2 如果是提交: 则删除UNDO_LOG中的数据\nTCC 模式 什么是 TCC TCC 是分布式事务中的二阶段提交协议，它的全称为 Try-Confirm-Cancel，即资源预留（Try）、确认操作（Confirm）、取消操作（Cancel），他们的具体含义如下：\nTry：对业务资源的检查并预留； Confirm：对业务处理进行提交，即 commit 操作，只要 Try 成功，那么该步骤一定成功； Cancel：对业务处理进行取消，即回滚操作，该步骤回对 Try 预留的资源进行释放。 TCC 是一种侵入式的分布式事务解决方案，以上三个操作都需要业务系统自行实现，对业务系统有着非常大的入侵性，设计相对复杂，但优点是 TCC 完全不依赖数据库，能够实现跨数据库、跨应用资源管理，对这些不同数据访问通过侵入式的编码方式实现一个原子操作，更好地解决了在各种复杂业务场景下的分布式事务问题。\nSeata TCC 模式 Seata TCC 模式跟通用型 TCC 模式原理一致，我们先来使用 Seata TCC 模式实现一个分布式事务：\n假设现有一个业务需要同时使用服务 A 和服务 B 完成一个事务操作，我们在服务 A 定义该服务的一个 TCC 接口：\npublic interface TccActionOne { @TwoPhaseBusinessAction(name = \"DubboTccActionOne\", commitMethod = \"commit\", rollbackMethod = \"rollback\") public boolean prepare(BusinessActionContext actionContext, @BusinessActionContextParameter(paramName = \"a\") String a); public boolean commit(BusinessActionContext actionContext); public boolean rollback(BusinessActionContext actionContext); } 同样，在服务 B 定义该服务的一个 TCC 接口：\npublic interface TccActionTwo { @TwoPhaseBusinessAction(name = \"DubboTccActionTwo\", commitMethod = \"commit\", rollbackMethod = \"rollback\") public void prepare(BusinessActionContext actionContext, @BusinessActionContextParameter(paramName = \"b\") String b); public void commit(BusinessActionContext actionContext); public void rollback(BusinessActionContext actionContext); } 在业务所在系统中开启全局事务并执行服务 A 和服务 B 的 TCC 预留资源方法：\n@GlobalTransactional public String doTransactionCommit(){ //服务A事务参与者 tccActionOne.prepare(null,\"one\"); //服务B事务参与者 tccActionTwo.prepare(null,\"two\"); } 以上就是使用 Seata TCC 模式实现一个全局事务的例子，可以看出，TCC 模式同样使用 @GlobalTransactional 注解开启全局事务，而服务 A 和服务 B 的 TCC 接口为事务参与者，Seata 会把一个 TCC 接口当成一个 Resource，也叫 TCC Resource。\nTCC 接口可以是 RPC，也可以是 JVM 内部调用，意味着一个 TCC 接口，会有发起方和调用方两个身份，以上例子，TCC 接口在服务 A 和服务 B 中是发起方，在业务所在系统中是调用方。如果该 TCC 接口为 Dubbo RPC，那么调用方就是一个 dubbo:reference，发起方则是一个 dubbo:service。\nSeata 启动时会对 TCC 接口进行扫描并解析，如果 TCC 接口是一个发布方，则在 Seata 启动时会向 TC 注册 TCC Resource，每个 TCC Resource 都有一个资源 ID；如果 TCC 接口时一个调用方，Seata 代理调用方，与 AT 模式一样，代理会拦截 TCC 接口的调用，即每次调用 Try 方法，会向 TC 注册一个分支事务，接着才执行原来的 RPC 调用。\n当全局事务决议提交/回滚时，TC 会通过分支注册的的资源 ID 回调到对应参与者服务中执行 TCC Resource 的 Confirm/Cancel 方法。\n如何控制异常 在 TCC 模型执行的过程中，还可能会出现各种异常，其中最为常见的有空回滚、幂等、悬挂等。下面我讲下 Seata 是如何处理这三种异常的。\n如何处理空回滚 什么是空回滚？\n空回滚指的是在一个分布式事务中，在没有调用参与方的 Try 方法的情况下，TM 驱动二阶段回滚调用了参与方的 Cancel 方法。\n那么空回滚是如何产生的呢？\n如上图所示，全局事务开启后，参与者 A 分支注册完成之后会执行参与者一阶段 RPC 方法，如果此时参与者 A 所在的机器发生宕机，网络异常，都会造成 RPC 调用失败，即参与者 A 一阶段方法未成功执行，但是此时全局事务已经开启，Seata 必须要推进到终态，在全局事务回滚时会调用参与者 A 的 Cancel 方法，从而造成空回滚。\n要想防止空回滚，那么必须在 Cancel 方法中识别这是一个空回滚，Seata 是如何做的呢？\nSeata 的做法是新增一个 TCC 事务控制表，包含事务的 XID 和 BranchID 信息，在 Try 方法执行时插入一条记录，表示一阶段执行了，执行 Cancel 方法时读取这条记录，如果记录不存在，说明 Try 方法没有执行。\n如何处理幂等 幂等问题指的是 TC 重复进行二阶段提交，因此 Confirm/Cancel 接口需要支持幂等处理，即不会产生资源重复提交或者重复释放。\n那么幂等问题是如何产生的呢？\n如上图所示，参与者 A 执行完二阶段之后，由于网络抖动或者宕机问题，会造成 TC 收不到参与者 A 执行二阶段的返回结果，TC 会重复发起调用，直到二阶段执行结果成功。\nSeata 是如何处理幂等问题的呢？\n同样的也是在 TCC 事务控制表中增加一个记录状态的字段 status，该字段有 3 个值，分别为：\ntried：1 committed：2 rollbacked：3 二阶段 Confirm/Cancel 方法执行后，将状态改为 committed 或 rollbacked 状态。当重复调用二阶段 Confirm/Cancel 方法时，判断事务状态即可解决幂等问题。\n如何处理悬挂 悬挂指的是二阶段 Cancel 方法比 一阶段 Try 方法优先执行，由于允许空回滚的原因，在执行完二阶段 Cancel 方法之后直接空回滚返回成功，此时全局事务已结束，但是由于 Try 方法随后执行，这就会造成一阶段 Try 方法预留的资源永远无法提交和释放了。\n那么悬挂是如何产生的呢？\n如上图所示，在执行参与者 A 的一阶段 Try 方法时，出现网路拥堵，由于 Seata 全局事务有超时限制，执行 Try 方法超时后，TM 决议全局回滚，回滚完成后如果此时 RPC 请求才到达参与者 A，执行 Try 方法进行资源预留，从而造成悬挂。\nSeata 是怎么处理悬挂的呢？\n在 TCC 事务控制表记录状态的字段 status 中增加一个状态：\nsuspended：4 当执行二阶段 Cancel 方法时，如果发现 TCC 事务控制表有相关记录，说明二阶段 Cancel 方法优先一阶段 Try 方法执行，因此插入一条 status=4 状态的记录，当一阶段 Try 方法后面执行时，判断 status=4 ，则说明有二阶段 Cancel 已执行，并返回 false 以阻止一阶段 Try 方法执行成功。\nSaga模式 Saga 模式是一种补偿协议。在 Saga 模式中，在分布式事务内有多个参与者，每个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向和逆向回滚操作。 如下图所示，T1~T3 都是正向的业务流程，都对应着一个冲正逆向操作 C1~C3。\n在分布式事务执行过程中，会依次执行各参与者的正向操作：\n如果所有正向操作均执行成功，则分布式事务提交；\n如果任何一个正向操作执行失败，则分布式事务会退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。\nSaga 模式的优势：\n在一阶段提交本地数据库事务，无锁，高性能 参与者可以采用事件驱动异步执行，高吞吐 补偿服务即正向服务的\"反向\"操作，易于理解，易于实现 Saga 模式也存在很明显的缺点：在一阶段已经提交了本地数据库事务，且没有进行\"预留\"动作，所以不能保证隔离性，不容易进行并发控制。与 AT 模式和 TCC 模式相比，Saga 模式的适用场景有限。\nA模式 在 XA 模式中，需要在 Seata 定义的分布式事务范围内，利用事务资源实现对 XA 协议的支持，以 XA 协议的机制来管理分支事务。\n本质上，Seata 的 AT、TCC、Saga模式都是补偿型的。事务处理机制构建在框架或应用中。事务资源本身对分布式事务是无感知的。而在 XA 模式下，事务资源对分布式事务是可感知的。\nSeata：Spring Cloud Alibaba分布式事务组件（非常详细） (biancheng.net) Seata 中文官网 深度剖析 Seata TCC 模式（一） Seata之模式简介 - 带翅膀的猫 (chengpengper.cn) 动手实践Seata四种模式（XA、AT、TCC、SAGA）_小钟要学习！！！的博客-CSDN博客_seata xa 模式 ","wordCount":"4761","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-09-04T07:23:55.264023686Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/seata/%E4%BB%8B%E7%BB%8D.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/seata.html>seata</a> <span>></span></ul></nav><h1 class=post-title>介绍</h1><div class=post-description>seata原理介绍</div><div class=post-meta>创建:&nbsp;<span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;更新:&nbsp;2023-09-04&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv>1</span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#seata-%e6%98%af%e4%bb%80%e4%b9%88 aria-label="Seata 是什么?">Seata 是什么?</a></li><li><a href=#seata-%e6%95%b4%e4%bd%93%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b aria-label="Seata 整体工作流程">Seata 整体工作流程</a><ul><li><a href=#xid aria-label=XID>XID</a></li><li><a href=#%e6%a0%b8%e5%bf%83%e7%bb%84%e4%bb%b6 aria-label=核心组件>核心组件</a></li></ul></li><li><a href=#%e5%9b%9b%e7%a7%8d%e6%a8%a1%e5%bc%8f aria-label=四种模式>四种模式</a><ul><li><a href=#at-%e6%a8%a1%e5%bc%8f aria-label="AT 模式">AT 模式</a><ul><li><a href=#at-%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%89%8d%e6%8f%90 aria-label="AT 模式的前提">AT 模式的前提</a></li><li><a href=#%e6%95%b4%e4%bd%93%e6%9c%ba%e5%88%b6 aria-label=整体机制>整体机制</a></li><li><a href=#%e5%b7%a5%e4%bd%9c%e6%9c%ba%e5%88%b6 aria-label=工作机制>工作机制</a><ul><li><a href=#%e4%b8%80%e9%98%b6%e6%ae%b5 aria-label=一阶段>一阶段</a></li><li><a href=#%e4%ba%8c%e9%98%b6%e6%ae%b5-%e5%9b%9e%e6%bb%9a aria-label=二阶段-回滚>二阶段-回滚</a></li><li><a href=#%e4%ba%8c%e9%98%b6%e6%ae%b5-%e6%8f%90%e4%ba%a4 aria-label=二阶段-提交>二阶段-提交</a></li></ul></li></ul></li><li><a href=#tcc-%e6%a8%a1%e5%bc%8f aria-label="TCC 模式">TCC 模式</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af-tcc aria-label="什么是 TCC">什么是 TCC</a></li><li><a href=#seata-tcc-%e6%a8%a1%e5%bc%8f aria-label="Seata TCC 模式">Seata TCC 模式</a></li><li><a href=#%e5%a6%82%e4%bd%95%e6%8e%a7%e5%88%b6%e5%bc%82%e5%b8%b8 aria-label=如何控制异常>如何控制异常</a><ul><li><a href=#%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e7%a9%ba%e5%9b%9e%e6%bb%9a aria-label=如何处理空回滚>如何处理空回滚</a></li><li><a href=#%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e5%b9%82%e7%ad%89 aria-label=如何处理幂等>如何处理幂等</a></li><li><a href=#%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e6%82%ac%e6%8c%82 aria-label=如何处理悬挂>如何处理悬挂</a></li></ul></li></ul></li><li><a href=#saga%e6%a8%a1%e5%bc%8f aria-label=Saga模式>Saga模式</a></li><li><a href=#a%e6%a8%a1%e5%bc%8f aria-label=A模式>A模式</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=seata-是什么>Seata 是什么?<a hidden class=anchor aria-hidden=true href=#seata-是什么>#</a></h1><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><h1 id=seata-整体工作流程>Seata 整体工作流程<a hidden class=anchor aria-hidden=true href=#seata-整体工作流程>#</a></h1><p>Seata 对分布式事务的协调和控制，主要是通过 XID 和 3 个核心组件实现的。</p><h2 id=xid>XID<a hidden class=anchor aria-hidden=true href=#xid>#</a></h2><p>XID 是全局事务的唯一标识，它可以在服务的调用链路中传递，绑定到服务的事务上下文中。</p><h2 id=核心组件>核心组件<a hidden class=anchor aria-hidden=true href=#核心组件>#</a></h2><p>Seata 定义了 3 个核心组件：</p><ul><li>TC（Transaction Coordinator）：事务协调器，它是事务的协调者（这里指的是 Seata 服务器），主要负责维护全局事务和分支事务的状态，驱动全局事务提交或回滚。</li><li>TM（Transaction Manager）：事务管理器，它是事务的发起者，负责定义全局事务的范围，并根据 TC 维护的全局事务和分支事务状态，做出开始事务、提交事务、回滚事务的决议。</li><li>RM（Resource Manager）：资源管理器，它是资源的管理者（这里可以将其理解为各服务使用的数据库）。它负责管理分支事务上的资源，向 TC 注册分支事务，汇报分支事务状态，驱动分支事务的提交或回滚。</li></ul><p>以上三个组件相互协作，TC 以 Seata 服务器（Server）形式独立部署，TM 和 RM 则是以 Seata Client 的形式集成在微服务中运行，其整体工作流程如下图。</p><p><img loading=lazy src=%E4%BB%8B%E7%BB%8D.assets/102A115W-0.png alt=img></p><p>Seata 的整体工作流程如下：</p><ol><li>TM 向 TC 申请开启一个全局事务，全局事务创建成功后，TC 会针对这个全局事务生成一个全局唯一的 XID；</li><li>XID 通过服务的调用链传递到其他服务;</li><li>RM 向 TC 注册一个分支事务，并将其纳入 XID 对应全局事务的管辖；</li><li>TM 根据 TC 收集的各个分支事务的执行结果，向 TC 发起全局事务提交或回滚决议；</li><li>TC 调度 XID 下管辖的所有分支事务完成提交或回滚操作。</li></ol><h1 id=四种模式>四种模式<a hidden class=anchor aria-hidden=true href=#四种模式>#</a></h1><p>Seata 提供了 AT、TCC、SAGA 和 XA 四种事务模式，可以快速有效地对分布式事务进行控制。</p><p>在这四种事务模式中使用最多，最方便的就是 AT 模式。与其他事务模式相比，AT 模式可以应对大多数的业务场景，且基本可以做到无业务入侵，开发人员能够有更多的精力关注于业务逻辑开发。</p><h2 id=at-模式>AT 模式<a hidden class=anchor aria-hidden=true href=#at-模式>#</a></h2><p>AT: Automatic Transaction</p><h3 id=at-模式的前提>AT 模式的前提<a hidden class=anchor aria-hidden=true href=#at-模式的前提>#</a></h3><p>任何应用想要使用 Seata 的 AT 模式对分布式事务进行控制，必须满足以下 2 个前提：</p><ul><li>必须使用支持本地 ACID 事务特性的关系型数据库，例如 MySQL、Oracle 等；</li><li>应用程序必须是使用 JDBC 对数据库进行访问的 JAVA 应用。</li></ul><h3 id=整体机制>整体机制<a hidden class=anchor aria-hidden=true href=#整体机制>#</a></h3><p>两阶段提交协议的演变：</p><ul><li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</li><li>二阶段：<ul><li>提交异步化，非常快速地完成。</li><li>回滚通过一阶段的回滚日志进行反向补偿。</li></ul></li></ul><h3 id=工作机制>工作机制<a hidden class=anchor aria-hidden=true href=#工作机制>#</a></h3><p>以一个示例来说明整个 AT 分支的工作过程。</p><p>业务表：<code>product</code></p><table><thead><tr><th>Field</th><th>Type</th><th>Key</th></tr></thead><tbody><tr><td>id</td><td>bigint(20)</td><td>PRI</td></tr><tr><td>name</td><td>varchar(100)</td><td></td></tr><tr><td>since</td><td>varchar(100)</td><td></td></tr></tbody></table><p>AT 分支事务的业务逻辑：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff7b72>update</span><span style=color:#6e7681> </span>product<span style=color:#6e7681> </span><span style=color:#ff7b72>set</span><span style=color:#6e7681> </span>name<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#39;GTS&#39;</span><span style=color:#6e7681> </span><span style=color:#ff7b72>where</span><span style=color:#6e7681> </span>name<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#39;TXC&#39;</span>;<span style=color:#6e7681>
</span></span></span></code></pre></div><h4 id=一阶段>一阶段<a hidden class=anchor aria-hidden=true href=#一阶段>#</a></h4><p>过程：</p><ol><li>解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name = &lsquo;TXC&rsquo;）等相关的信息。</li><li>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。</li></ol><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff7b72>select</span><span style=color:#6e7681> </span>id,<span style=color:#6e7681> </span>name,<span style=color:#6e7681> </span>since<span style=color:#6e7681> </span><span style=color:#ff7b72>from</span><span style=color:#6e7681> </span>product<span style=color:#6e7681> </span><span style=color:#ff7b72>where</span><span style=color:#6e7681> </span>name<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#39;TXC&#39;</span>;<span style=color:#6e7681>
</span></span></span></code></pre></div><p>得到前镜像：</p><table><thead><tr><th>id</th><th>name</th><th>since</th></tr></thead><tbody><tr><td>1</td><td>TXC</td><td>2014</td></tr></tbody></table><ol start=3><li><p>执行业务 SQL：更新这条记录的 name 为 &lsquo;GTS&rsquo;。</p></li><li><p>查询后镜像：根据前镜像的结果，通过 <strong>主键</strong> 定位数据。</p></li></ol><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff7b72>select</span><span style=color:#6e7681> </span>id,<span style=color:#6e7681> </span>name,<span style=color:#6e7681> </span>since<span style=color:#6e7681> </span><span style=color:#ff7b72>from</span><span style=color:#6e7681> </span>product<span style=color:#6e7681> </span><span style=color:#ff7b72>where</span><span style=color:#6e7681> </span>id<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>1</span>;<span style=color:#6e7681>
</span></span></span></code></pre></div><p>得到后镜像：</p><table><thead><tr><th>id</th><th>name</th><th>since</th></tr></thead><tbody><tr><td>1</td><td>GTS</td><td>2014</td></tr></tbody></table><ol start=5><li>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 <code>UNDO_LOG</code> 表中。</li></ol><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#7ee787>&#34;branchId&#34;</span>: <span style=color:#a5d6ff>641789253</span>,
</span></span><span style=display:flex><span>	<span style=color:#7ee787>&#34;undoItems&#34;</span>: [{
</span></span><span style=display:flex><span>		<span style=color:#7ee787>&#34;afterImage&#34;</span>: {
</span></span><span style=display:flex><span>			<span style=color:#7ee787>&#34;rows&#34;</span>: [{
</span></span><span style=display:flex><span>				<span style=color:#7ee787>&#34;fields&#34;</span>: [{
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;name&#34;</span>: <span style=color:#a5d6ff>&#34;id&#34;</span>,
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;type&#34;</span>: <span style=color:#a5d6ff>4</span>,
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;value&#34;</span>: <span style=color:#a5d6ff>1</span>
</span></span><span style=display:flex><span>				}, {
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;name&#34;</span>: <span style=color:#a5d6ff>&#34;name&#34;</span>,
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;type&#34;</span>: <span style=color:#a5d6ff>12</span>,
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;value&#34;</span>: <span style=color:#a5d6ff>&#34;GTS&#34;</span>
</span></span><span style=display:flex><span>				}, {
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;name&#34;</span>: <span style=color:#a5d6ff>&#34;since&#34;</span>,
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;type&#34;</span>: <span style=color:#a5d6ff>12</span>,
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;value&#34;</span>: <span style=color:#a5d6ff>&#34;2014&#34;</span>
</span></span><span style=display:flex><span>				}]
</span></span><span style=display:flex><span>			}],
</span></span><span style=display:flex><span>			<span style=color:#7ee787>&#34;tableName&#34;</span>: <span style=color:#a5d6ff>&#34;product&#34;</span>
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>		<span style=color:#7ee787>&#34;beforeImage&#34;</span>: {
</span></span><span style=display:flex><span>			<span style=color:#7ee787>&#34;rows&#34;</span>: [{
</span></span><span style=display:flex><span>				<span style=color:#7ee787>&#34;fields&#34;</span>: [{
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;name&#34;</span>: <span style=color:#a5d6ff>&#34;id&#34;</span>,
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;type&#34;</span>: <span style=color:#a5d6ff>4</span>,
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;value&#34;</span>: <span style=color:#a5d6ff>1</span>
</span></span><span style=display:flex><span>				}, {
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;name&#34;</span>: <span style=color:#a5d6ff>&#34;name&#34;</span>,
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;type&#34;</span>: <span style=color:#a5d6ff>12</span>,
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;value&#34;</span>: <span style=color:#a5d6ff>&#34;TXC&#34;</span>
</span></span><span style=display:flex><span>				}, {
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;name&#34;</span>: <span style=color:#a5d6ff>&#34;since&#34;</span>,
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;type&#34;</span>: <span style=color:#a5d6ff>12</span>,
</span></span><span style=display:flex><span>					<span style=color:#7ee787>&#34;value&#34;</span>: <span style=color:#a5d6ff>&#34;2014&#34;</span>
</span></span><span style=display:flex><span>				}]
</span></span><span style=display:flex><span>			}],
</span></span><span style=display:flex><span>			<span style=color:#7ee787>&#34;tableName&#34;</span>: <span style=color:#a5d6ff>&#34;product&#34;</span>
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>		<span style=color:#7ee787>&#34;sqlType&#34;</span>: <span style=color:#a5d6ff>&#34;UPDATE&#34;</span>
</span></span><span style=display:flex><span>	}],
</span></span><span style=display:flex><span>	<span style=color:#7ee787>&#34;xid&#34;</span>: <span style=color:#a5d6ff>&#34;xid:xxx&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=6><li>提交前，向 TC 注册分支：申请 <code>product</code> 表中，主键值等于 1 的记录的 <strong>全局锁</strong> 。</li><li>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</li><li>将本地事务提交的结果上报给 TC。</li></ol><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#ff7b72>CREATE</span><span style=color:#6e7681> </span><span style=color:#ff7b72>TABLE</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>`</span>undo_log<span style=color:#ff7b72;font-weight:700>`</span><span style=color:#6e7681> </span>(<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72;font-weight:700>`</span>id<span style=color:#ff7b72;font-weight:700>`</span><span style=color:#6e7681> </span>bigint(<span style=color:#a5d6ff>20</span>)<span style=color:#6e7681> </span><span style=color:#ff7b72>NOT</span><span style=color:#6e7681> </span><span style=color:#ff7b72>NULL</span><span style=color:#6e7681> </span>AUTO_INCREMENT,<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72;font-weight:700>`</span>branch_id<span style=color:#ff7b72;font-weight:700>`</span><span style=color:#6e7681> </span>bigint(<span style=color:#a5d6ff>20</span>)<span style=color:#6e7681> </span><span style=color:#ff7b72>NOT</span><span style=color:#6e7681> </span><span style=color:#ff7b72>NULL</span>,<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72;font-weight:700>`</span>xid<span style=color:#ff7b72;font-weight:700>`</span><span style=color:#6e7681> </span>varchar(<span style=color:#a5d6ff>100</span>)<span style=color:#6e7681> </span><span style=color:#ff7b72>NOT</span><span style=color:#6e7681> </span><span style=color:#ff7b72>NULL</span>,<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72;font-weight:700>`</span>context<span style=color:#ff7b72;font-weight:700>`</span><span style=color:#6e7681> </span>varchar(<span style=color:#a5d6ff>128</span>)<span style=color:#6e7681> </span><span style=color:#ff7b72>NOT</span><span style=color:#6e7681> </span><span style=color:#ff7b72>NULL</span>,<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72;font-weight:700>`</span>rollback_info<span style=color:#ff7b72;font-weight:700>`</span><span style=color:#6e7681> </span>longblob<span style=color:#6e7681> </span><span style=color:#ff7b72>NOT</span><span style=color:#6e7681> </span><span style=color:#ff7b72>NULL</span>,<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72;font-weight:700>`</span>log_status<span style=color:#ff7b72;font-weight:700>`</span><span style=color:#6e7681> </span>int(<span style=color:#a5d6ff>11</span>)<span style=color:#6e7681> </span><span style=color:#ff7b72>NOT</span><span style=color:#6e7681> </span><span style=color:#ff7b72>NULL</span>,<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72;font-weight:700>`</span>log_created<span style=color:#ff7b72;font-weight:700>`</span><span style=color:#6e7681> </span>datetime<span style=color:#6e7681> </span><span style=color:#ff7b72>NOT</span><span style=color:#6e7681> </span><span style=color:#ff7b72>NULL</span>,<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72;font-weight:700>`</span>log_modified<span style=color:#ff7b72;font-weight:700>`</span><span style=color:#6e7681> </span>datetime<span style=color:#6e7681> </span><span style=color:#ff7b72>NOT</span><span style=color:#6e7681> </span><span style=color:#ff7b72>NULL</span>,<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72;font-weight:700>`</span>ext<span style=color:#ff7b72;font-weight:700>`</span><span style=color:#6e7681> </span>varchar(<span style=color:#a5d6ff>100</span>)<span style=color:#6e7681> </span><span style=color:#ff7b72>DEFAULT</span><span style=color:#6e7681> </span><span style=color:#ff7b72>NULL</span>,<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>PRIMARY</span><span style=color:#6e7681> </span><span style=color:#ff7b72>KEY</span><span style=color:#6e7681> </span>(<span style=color:#ff7b72;font-weight:700>`</span>id<span style=color:#ff7b72;font-weight:700>`</span>),<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>  </span><span style=color:#ff7b72>UNIQUE</span><span style=color:#6e7681> </span><span style=color:#ff7b72>KEY</span><span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>`</span>ux_undo_log<span style=color:#ff7b72;font-weight:700>`</span><span style=color:#6e7681> </span>(<span style=color:#ff7b72;font-weight:700>`</span>xid<span style=color:#ff7b72;font-weight:700>`</span>,<span style=color:#ff7b72;font-weight:700>`</span>branch_id<span style=color:#ff7b72;font-weight:700>`</span>)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>)<span style=color:#6e7681> </span>ENGINE<span style=color:#ff7b72;font-weight:700>=</span>InnoDB<span style=color:#6e7681> </span>AUTO_INCREMENT<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>1</span><span style=color:#6e7681> </span><span style=color:#ff7b72>DEFAULT</span><span style=color:#6e7681> </span>CHARSET<span style=color:#ff7b72;font-weight:700>=</span>utf8;<span style=color:#6e7681>
</span></span></span></code></pre></div><h4 id=二阶段-回滚>二阶段-回滚<a hidden class=anchor aria-hidden=true href=#二阶段-回滚>#</a></h4><ol><li>收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</li><li>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</li><li>数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。</li><li>根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：</li></ol><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff7b72>update</span><span style=color:#6e7681> </span>product<span style=color:#6e7681> </span><span style=color:#ff7b72>set</span><span style=color:#6e7681> </span>name<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#39;TXC&#39;</span><span style=color:#6e7681> </span><span style=color:#ff7b72>where</span><span style=color:#6e7681> </span>id<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>1</span>;<span style=color:#6e7681>
</span></span></span></code></pre></div><ol start=5><li>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</li></ol><blockquote><p>第三点中是无法处理的情况, seata使用 <code>@GlobalLock+@Transactional</code>或 <code>@GlobalTransaction</code> 来加了全局锁, 在回滚完成前, 其他请求将被阻塞, 如果真的出现了这种情况, 可自定义实现FailureHandler做邮件通知或其他</p><p><a href=https://seata.io/zh-cn/docs/overview/faq.html target=_blank rel=noopener>Seata常见问题</a></p><p><a href=https://github.com/seata/seata/issues/2488 target=_blank rel=noopener>脏写导致数据回滚失败？</a></p></blockquote><h4 id=二阶段-提交>二阶段-提交<a hidden class=anchor aria-hidden=true href=#二阶段-提交>#</a></h4><ol><li>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</li><li>异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。</li></ol><blockquote><p><strong>总结</strong>:</p><ol><li><p>第一阶段是把 所有要修改的数据存在seata的UNDO_LOG表里(修改前的数据),并拿到全局锁</p></li><li><p>第二阶段 看执行结果决定是回滚还是提交</p></li></ol><p>​ 2.1 如果是回滚: 则把UNDO_LOG里对应的数据写回去</p><p>​ 2.2 如果是提交: 则删除UNDO_LOG中的数据</p></blockquote><h2 id=tcc-模式>TCC 模式<a hidden class=anchor aria-hidden=true href=#tcc-模式>#</a></h2><h3 id=什么是-tcc>什么是 TCC<a hidden class=anchor aria-hidden=true href=#什么是-tcc>#</a></h3><p>TCC 是分布式事务中的二阶段提交协议，它的全称为 Try-Confirm-Cancel，即资源预留（Try）、确认操作（Confirm）、取消操作（Cancel），他们的具体含义如下：</p><ol><li>Try：对业务资源的检查并预留；</li><li>Confirm：对业务处理进行提交，即 commit 操作，只要 Try 成功，那么该步骤一定成功；</li><li>Cancel：对业务处理进行取消，即回滚操作，该步骤回对 Try 预留的资源进行释放。</li></ol><p>TCC 是一种侵入式的分布式事务解决方案，以上三个操作都需要业务系统自行实现，对业务系统有着非常大的入侵性，设计相对复杂，但优点是 TCC 完全不依赖数据库，能够实现跨数据库、跨应用资源管理，对这些不同数据访问通过侵入式的编码方式实现一个原子操作，更好地解决了在各种复杂业务场景下的分布式事务问题。</p><h3 id=seata-tcc-模式>Seata TCC 模式<a hidden class=anchor aria-hidden=true href=#seata-tcc-模式>#</a></h3><p>Seata TCC 模式跟通用型 TCC 模式原理一致，我们先来使用 Seata TCC 模式实现一个分布式事务：</p><p>假设现有一个业务需要同时使用服务 A 和服务 B 完成一个事务操作，我们在服务 A 定义该服务的一个 TCC 接口：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span> <span style=color:#ff7b72>interface</span> <span style=color:#f0883e;font-weight:700>TccActionOne</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>@TwoPhaseBusinessAction</span><span style=color:#ff7b72;font-weight:700>(</span>name <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>&#34;DubboTccActionOne&#34;</span><span style=color:#ff7b72;font-weight:700>,</span> commitMethod <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>&#34;commit&#34;</span><span style=color:#ff7b72;font-weight:700>,</span> rollbackMethod <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>&#34;rollback&#34;</span><span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>boolean</span> <span style=color:#d2a8ff;font-weight:700>prepare</span><span style=color:#ff7b72;font-weight:700>(</span>BusinessActionContext actionContext<span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#d2a8ff;font-weight:700>@BusinessActionContextParameter</span><span style=color:#ff7b72;font-weight:700>(</span>paramName <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>&#34;a&#34;</span><span style=color:#ff7b72;font-weight:700>)</span> String a<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>boolean</span> <span style=color:#d2a8ff;font-weight:700>commit</span><span style=color:#ff7b72;font-weight:700>(</span>BusinessActionContext actionContext<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>boolean</span> <span style=color:#d2a8ff;font-weight:700>rollback</span><span style=color:#ff7b72;font-weight:700>(</span>BusinessActionContext actionContext<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p>同样，在服务 B 定义该服务的一个 TCC 接口：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span> <span style=color:#ff7b72>interface</span> <span style=color:#f0883e;font-weight:700>TccActionTwo</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>@TwoPhaseBusinessAction</span><span style=color:#ff7b72;font-weight:700>(</span>name <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>&#34;DubboTccActionTwo&#34;</span><span style=color:#ff7b72;font-weight:700>,</span> commitMethod <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>&#34;commit&#34;</span><span style=color:#ff7b72;font-weight:700>,</span> rollbackMethod <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>&#34;rollback&#34;</span><span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>prepare</span><span style=color:#ff7b72;font-weight:700>(</span>BusinessActionContext actionContext<span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#d2a8ff;font-weight:700>@BusinessActionContextParameter</span><span style=color:#ff7b72;font-weight:700>(</span>paramName <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>&#34;b&#34;</span><span style=color:#ff7b72;font-weight:700>)</span> String b<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>commit</span><span style=color:#ff7b72;font-weight:700>(</span>BusinessActionContext actionContext<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>rollback</span><span style=color:#ff7b72;font-weight:700>(</span>BusinessActionContext actionContext<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p>在业务所在系统中开启全局事务并执行服务 A 和服务 B 的 TCC 预留资源方法：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>@GlobalTransactional</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>public</span> String <span style=color:#d2a8ff;font-weight:700>doTransactionCommit</span><span style=color:#ff7b72;font-weight:700>(){</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>//服务A事务参与者
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    tccActionOne<span style=color:#ff7b72;font-weight:700>.</span>prepare<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>,</span><span style=color:#a5d6ff>&#34;one&#34;</span><span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>//服务B事务参与者
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    tccActionTwo<span style=color:#ff7b72;font-weight:700>.</span>prepare<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>,</span><span style=color:#a5d6ff>&#34;two&#34;</span><span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p>以上就是使用 Seata TCC 模式实现一个全局事务的例子，可以看出，TCC 模式同样使用 <code>@GlobalTransactional</code> 注解开启全局事务，而服务 A 和服务 B 的 TCC 接口为事务参与者，Seata 会把一个 TCC 接口当成一个 Resource，也叫 TCC Resource。</p><p>TCC 接口可以是 RPC，也可以是 JVM 内部调用，意味着一个 TCC 接口，会有发起方和调用方两个身份，以上例子，TCC 接口在服务 A 和服务 B 中是发起方，在业务所在系统中是调用方。如果该 TCC 接口为 Dubbo RPC，那么调用方就是一个 dubbo:reference，发起方则是一个 dubbo:service。</p><p><img loading=lazy src=%E4%BB%8B%E7%BB%8D.assets/20220116161933.png alt=img></p><p>Seata 启动时会对 TCC 接口进行扫描并解析，如果 TCC 接口是一个发布方，则在 Seata 启动时会向 TC 注册 TCC Resource，每个 TCC Resource 都有一个资源 ID；如果 TCC 接口时一个调用方，Seata 代理调用方，与 AT 模式一样，代理会拦截 TCC 接口的调用，即每次调用 Try 方法，会向 TC 注册一个分支事务，接着才执行原来的 RPC 调用。</p><p>当全局事务决议提交/回滚时，TC 会通过分支注册的的资源 ID 回调到对应参与者服务中执行 TCC Resource 的 Confirm/Cancel 方法。</p><h3 id=如何控制异常>如何控制异常<a hidden class=anchor aria-hidden=true href=#如何控制异常>#</a></h3><p>在 TCC 模型执行的过程中，还可能会出现各种异常，其中最为常见的有空回滚、幂等、悬挂等。下面我讲下 Seata 是如何处理这三种异常的。</p><h4 id=如何处理空回滚>如何处理空回滚<a hidden class=anchor aria-hidden=true href=#如何处理空回滚>#</a></h4><p>什么是空回滚？</p><p>空回滚指的是在一个分布式事务中，在没有调用参与方的 Try 方法的情况下，TM 驱动二阶段回滚调用了参与方的 Cancel 方法。</p><p>那么空回滚是如何产生的呢？</p><p><img loading=lazy src=%E4%BB%8B%E7%BB%8D.assets/20220116201900.png alt=img></p><p>如上图所示，全局事务开启后，参与者 A 分支注册完成之后会执行参与者一阶段 RPC 方法，如果此时参与者 A 所在的机器发生宕机，网络异常，都会造成 RPC 调用失败，即参与者 A 一阶段方法未成功执行，但是此时全局事务已经开启，Seata 必须要推进到终态，在全局事务回滚时会调用参与者 A 的 Cancel 方法，从而造成空回滚。</p><p>要想防止空回滚，那么必须在 Cancel 方法中识别这是一个空回滚，Seata 是如何做的呢？</p><p>Seata 的做法是新增一个 TCC 事务控制表，包含事务的 XID 和 BranchID 信息，在 Try 方法执行时插入一条记录，表示一阶段执行了，执行 Cancel 方法时读取这条记录，如果记录不存在，说明 Try 方法没有执行。</p><h4 id=如何处理幂等>如何处理幂等<a hidden class=anchor aria-hidden=true href=#如何处理幂等>#</a></h4><p>幂等问题指的是 TC 重复进行二阶段提交，因此 Confirm/Cancel 接口需要支持幂等处理，即不会产生资源重复提交或者重复释放。</p><p>那么幂等问题是如何产生的呢？</p><p><img loading=lazy src=%E4%BB%8B%E7%BB%8D.assets/20220116203816.png alt=img></p><p>如上图所示，参与者 A 执行完二阶段之后，由于网络抖动或者宕机问题，会造成 TC 收不到参与者 A 执行二阶段的返回结果，TC 会重复发起调用，直到二阶段执行结果成功。</p><p>Seata 是如何处理幂等问题的呢？</p><p>同样的也是在 TCC 事务控制表中增加一个记录状态的字段 status，该字段有 3 个值，分别为：</p><ol><li>tried：1</li><li>committed：2</li><li>rollbacked：3</li></ol><p>二阶段 Confirm/Cancel 方法执行后，将状态改为 committed 或 rollbacked 状态。当重复调用二阶段 Confirm/Cancel 方法时，判断事务状态即可解决幂等问题。</p><h4 id=如何处理悬挂>如何处理悬挂<a hidden class=anchor aria-hidden=true href=#如何处理悬挂>#</a></h4><p>悬挂指的是二阶段 Cancel 方法比 一阶段 Try 方法优先执行，由于允许空回滚的原因，在执行完二阶段 Cancel 方法之后直接空回滚返回成功，此时全局事务已结束，但是由于 Try 方法随后执行，这就会造成一阶段 Try 方法预留的资源永远无法提交和释放了。</p><p>那么悬挂是如何产生的呢？</p><p><img loading=lazy src=%E4%BB%8B%E7%BB%8D.assets/20220116205241.png alt=img></p><p>如上图所示，在执行参与者 A 的一阶段 Try 方法时，出现网路拥堵，由于 Seata 全局事务有超时限制，执行 Try 方法超时后，TM 决议全局回滚，回滚完成后如果此时 RPC 请求才到达参与者 A，执行 Try 方法进行资源预留，从而造成悬挂。</p><p>Seata 是怎么处理悬挂的呢？</p><p>在 TCC 事务控制表记录状态的字段 status 中增加一个状态：</p><ol><li>suspended：4</li></ol><p>当执行二阶段 Cancel 方法时，如果发现 TCC 事务控制表有相关记录，说明二阶段 Cancel 方法优先一阶段 Try 方法执行，因此插入一条 status=4 状态的记录，当一阶段 Try 方法后面执行时，判断 status=4 ，则说明有二阶段 Cancel 已执行，并返回 false 以阻止一阶段 Try 方法执行成功。</p><h2 id=saga模式>Saga模式<a hidden class=anchor aria-hidden=true href=#saga模式>#</a></h2><p>Saga 模式是一种补偿协议。在 Saga 模式中，在分布式事务内有多个参与者，每个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向和逆向回滚操作。 如下图所示，T1~T3 都是正向的业务流程，都对应着一个冲正逆向操作 C1~C3。</p><p><img loading=lazy src=https://www.chengpengper.cn/usr/uploads/Seata/172/Saga%E6%A8%A1%E5%BC%8F.png alt=img></p><p>在分布式事务执行过程中，会依次执行各参与者的正向操作：</p><ul><li><p>如果所有正向操作均执行成功，则分布式事务提交；</p></li><li><p>如果任何一个正向操作执行失败，则分布式事务会退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p></li></ul><p>Saga 模式的优势：</p><ul><li>在一阶段提交本地数据库事务，无锁，高性能</li><li>参与者可以采用事件驱动异步执行，高吞吐</li><li>补偿服务即正向服务的"反向"操作，易于理解，易于实现</li></ul><p>Saga 模式也存在很明显的缺点：在一阶段已经提交了本地数据库事务，且没有进行"预留"动作，所以不能保证隔离性，不容易进行并发控制。与 AT 模式和 TCC 模式相比，Saga 模式的适用场景有限。</p><h2 id=a模式>A模式<a hidden class=anchor aria-hidden=true href=#a模式>#</a></h2><p>在 XA 模式中，需要在 Seata 定义的分布式事务范围内，利用事务资源实现对 XA 协议的支持，以 XA 协议的机制来管理分支事务。</p><blockquote><p>本质上，Seata 的 AT、TCC、Saga模式都是补偿型的。事务处理机制构建在框架或应用中。事务资源本身对分布式事务是无感知的。而在 XA 模式下，事务资源对分布式事务是可感知的。</p></blockquote><p><a href=http://c.biancheng.net/springcloud/seata.html target=_blank rel=noopener>Seata：Spring Cloud Alibaba分布式事务组件（非常详细） (biancheng.net)</a></p><p><a href=https://seata.io/zh-cn/docs/overview/what-is-seata.html target=_blank rel=noopener>Seata 中文官网</a></p><p><a href=https://seata.io/zh-cn/blog/seata-tcc.html target=_blank rel=noopener>深度剖析 Seata TCC 模式（一）</a></p><p><a href=https://www.chengpengper.cn/archives/172/ target=_blank rel=noopener>Seata之模式简介 - 带翅膀的猫 (chengpengper.cn)</a></p><p><a href=https://blog.csdn.net/baidu_39378193/article/details/125191418 target=_blank rel=noopener>动手实践Seata四种模式（XA、AT、TCC、SAGA）_小钟要学习！！！的博客-CSDN博客_seata xa 模式</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/Seata.html>Seata</a></li><li><a href=https://xiaokunji.com/zh/tags/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/myBatisPlus/%E4%BB%8B%E7%BB%8D.html><span class=title>« 上一页</span><br><span>介绍</span></a>
<a class=next href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/serviceMesh/Istio/%E4%BB%8B%E7%BB%8D.html><span class=title>下一页 »</span><br><span>介绍</span></a></nav></footer></article></main><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>