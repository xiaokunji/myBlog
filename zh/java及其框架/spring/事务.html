<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>事务 | 米二</title><meta name=keywords content=" 1. 介绍, 2.事务有四个特性：ACID, 3. 事务管理器, 4. 基本事务属性的定义, 4.1 传播行为, 4.2 隔离级别, 5. 编程式事务, 6. AOP失效, 6.1 自调用, 6.2  private 修饰的方法"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/spring/%E4%BA%8B%E5%8A%A1.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/spring/%E4%BA%8B%E5%8A%A1.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="事务"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/spring/%E4%BA%8B%E5%8A%A1.html"><meta property="article:section" content="java及其框架"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-04T11:19:09+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="事务"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"事务","item":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/spring/%E4%BA%8B%E5%8A%A1.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"事务","name":"事务","description":"     ","keywords":[" 1. 介绍"," 2.事务有四个特性：ACID"," 3. 事务管理器"," 4. 基本事务属性的定义"," 4.1 传播行为"," 4.2 隔离级别"," 5. 编程式事务"," 6. AOP失效"," 6.1 自调用"," 6.2  private 修饰的方法"],"articleBody":"[TOC]\n1. 介绍 事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。 在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。\n2.事务有四个特性：ACID 原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。 一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。 隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。 持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。 原文链接：https://blog.csdn.net/trigl/article/details/50968079\n3. 事务管理器 Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。此接口的内容如下：\nPublic interface PlatformTransactionManager()...{ // 由TransactionDefinition得到TransactionStatus对象 TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; // 提交 Void commit(TransactionStatus status) throws TransactionException; // 回滚 Void rollback(TransactionStatus status) throws TransactionException; } JDBC事务 Hibernate事务 Java持久化API事务（JPA） Java原生API事务 (跨越了多个事务管理源) 原文链接：https://blog.csdn.net/trigl/article/details/50968079\n4. 基本事务属性的定义 4.1 传播行为 事务的第一个方面是传播行为（propagation behavior）。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring定义了七种传播行为：\n传播行为 含义 PROPAGATION_REQUIRED 表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务(springboot中注解默认的行为) PROPAGATION_SUPPORTS 表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行 PROPAGATION_MANDATORY 表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常 PROPAGATION_REQUIRED_NEW 表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager PROPAGATION_NOT_SUPPORTED 表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager PROPAGATION_NEVER 表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常 PROPAGATION_NESTED 表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务 原文链接：https://blog.csdn.net/trigl/article/details/50968079\n4.2 隔离级别 事务的第二个维度就是隔离级别（isolation level）。隔离级别定义了一个事务可能受其他并发事务影响的程度。\n并发事务引起的问题 在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题(严重程度依次递增)。 脏读（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。 不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。 幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。 原文链接：https://blog.csdn.net/trigl/article/details/50968079\n数据库用的是mvcc+各种锁来解决的三种问题(简单理解为乐观锁)\n简述三种的情况的处理 不可重复读与幻读的解决方案 隔离级别(围绕三种读的隔离) 隔离级别 含义 ISOLATION_DEFAULT 使用后端数据库默认的隔离级别 (springboot中注解默认级别) ISOLATION_READ_UNCOMMITTED (读未提交)最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 ISOLATION_READ_COMMITTED (读已提交)允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 ISOLATION_REPEATABLE_READ (可重复读)对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生 ISOLATION_SERIALIZABLE 最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的 mysql默认的事务处理级别是’REPEATABLE-READ’,也就是可重复读\noracle默认系统事务隔离级别是READ COMMITTED,也就是读已提交\n原文链接：https://blog.csdn.net/trigl/article/details/50968079\n5. 编程式事务 编程式和声明式事务的区别\n编程式事务允许用户在代码中精确定义事务的边界， 声明式事务（基于AOP）有助于用户将操作与事务规则进行解耦。 (@Transactional) 简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现。\n原文链接：https://blog.csdn.net/trigl/article/details/50968079\n进阶版使用:\n@Component public class TransactionHelper { @Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class) public \u003cT\u003e T run(Supplier\u003cT\u003e command) { return command.get(); } @Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class) public void run(Runnable command) { command.run(); } @Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class) public \u003cT, R\u003e R run(Function\u003cT, R\u003e command, T param) { return command.apply(param); } } // 使用 @Resource private TransactionHelper transactionHelper; private boolean transactionSaveWebsiteMessageByTemplate(List\u003cBaseWebsiteMessageQuery\u003e websiteMessageQuery) { return transactionHelper.run(this::saveWebsiteMessageByTemplate, websiteMessageQuery); } 6. AOP失效 6.1 自调用 自调用: A方法调用B方法, 把事务注解加到B方法上,这就是自调用, 自调用不会触发事务(官方说的)\n这是由AOP原理决定的,动态代理是类的代理,只有出现类的调用才会触发事务, 而类内部的函数调用就不是类的调用了\n解决方案:\n将注解写到A方法上 将B方法抽离出来,再写一个类, 在A方法最后再调用B方法 不用注解,使用声明书事务(就是手动开启事务) 再次模拟一次编程式调用,让A方法在事务内调回来 原理及解决方案 原理介绍 6.2 private 修饰的方法 Spring 自调用事务失效，你是怎么解决的？ - 程序员小航 - 博客园 (cnblogs.com) ","wordCount":"3109","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-09-04T11:19:09.452813662Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/spring/%E4%BA%8B%E5%8A%A1.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/spring.html>spring</a> <span>></span></ul></nav><h1 class=post-title>事务</h1><div class=post-description></div><div class=post-meta>创建:&nbsp;<span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;更新:&nbsp;2023-09-04&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv>1</span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#1-%e4%bb%8b%e7%bb%8d aria-label="1. 介绍">1. 介绍</a></li><li><a href=#2%e4%ba%8b%e5%8a%a1%e6%9c%89%e5%9b%9b%e4%b8%aa%e7%89%b9%e6%80%a7acid aria-label=2.事务有四个特性：ACID>2.事务有四个特性：ACID</a></li><li><a href=#3-%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86%e5%99%a8 aria-label="3. 事务管理器">3. 事务管理器</a></li><li><a href=#4-%e5%9f%ba%e6%9c%ac%e4%ba%8b%e5%8a%a1%e5%b1%9e%e6%80%a7%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label="4. 基本事务属性的定义">4. 基本事务属性的定义</a><ul><li><a href=#41-%e4%bc%a0%e6%92%ad%e8%a1%8c%e4%b8%ba aria-label="4.1 传播行为">4.1 传播行为</a></li><li><a href=#42-%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab aria-label="4.2 隔离级别">4.2 隔离级别</a></li></ul></li><li><a href=#5-%e7%bc%96%e7%a8%8b%e5%bc%8f%e4%ba%8b%e5%8a%a1 aria-label="5. 编程式事务">5. 编程式事务</a></li><li><a href=#6-aop%e5%a4%b1%e6%95%88 aria-label="6. AOP失效">6. AOP失效</a><ul><li><a href=#61-%e8%87%aa%e8%b0%83%e7%94%a8 aria-label="6.1 自调用">6.1 自调用</a></li><li><a href=#62--private-%e4%bf%ae%e9%a5%b0%e7%9a%84%e6%96%b9%e6%b3%95 aria-label="6.2  private 修饰的方法">6.2 private 修饰的方法</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[TOC]</p><h1 id=1-介绍>1. 介绍<a hidden class=anchor aria-hidden=true href=#1-介绍>#</a></h1><p>事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。
在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。</p><h1 id=2事务有四个特性acid>2.事务有四个特性：ACID<a hidden class=anchor aria-hidden=true href=#2事务有四个特性acid>#</a></h1><ol><li>原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</li><li>一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。</li><li>隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。</li><li>持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。</li></ol><blockquote><p>原文链接：https://blog.csdn.net/trigl/article/details/50968079</p></blockquote><h1 id=3-事务管理器>3. 事务管理器<a hidden class=anchor aria-hidden=true href=#3-事务管理器>#</a></h1><p>Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。
Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。此接口的内容如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Public interface PlatformTransactionManager()...{  
</span></span><span style=display:flex><span>    // 由TransactionDefinition得到TransactionStatus对象
</span></span><span style=display:flex><span>    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; 
</span></span><span style=display:flex><span>    // 提交
</span></span><span style=display:flex><span>    Void commit(TransactionStatus status) throws TransactionException;  
</span></span><span style=display:flex><span>    // 回滚
</span></span><span style=display:flex><span>    Void rollback(TransactionStatus status) throws TransactionException;  
</span></span><span style=display:flex><span>    } 
</span></span></code></pre></div><ol><li>JDBC事务</li><li>Hibernate事务</li><li>Java持久化API事务（JPA）</li><li>Java原生API事务 (跨越了多个事务管理源)</li></ol><blockquote><p>原文链接：https://blog.csdn.net/trigl/article/details/50968079</p></blockquote><h1 id=4-基本事务属性的定义>4. 基本事务属性的定义<a hidden class=anchor aria-hidden=true href=#4-基本事务属性的定义>#</a></h1><h2 id=41-传播行为>4.1 传播行为<a hidden class=anchor aria-hidden=true href=#41-传播行为>#</a></h2><p>事务的第一个方面是传播行为（propagation behavior）。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring定义了七种传播行为：</p><table><thead><tr><th>传播行为</th><th>含义</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务(springboot中注解默认的行为)</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常</td></tr><tr><td>PROPAGATION_REQUIRED_NEW</td><td>表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager</td></tr><tr><td>PROPAGATION_NEVER</td><td>表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常</td></tr><tr><td>PROPAGATION_NESTED</td><td>表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务</td></tr></tbody></table><blockquote><p>原文链接：https://blog.csdn.net/trigl/article/details/50968079</p></blockquote><h2 id=42-隔离级别>4.2 隔离级别<a hidden class=anchor aria-hidden=true href=#42-隔离级别>#</a></h2><p>事务的第二个维度就是隔离级别（isolation level）。隔离级别定义了一个事务可能受其他并发事务影响的程度。</p><ol><li>并发事务引起的问题
在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题(<strong>严重程度依次递增</strong>)。<ul><li>脏读（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。</li><li>不可重复读（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。</li><li>幻读（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。</li></ul></li></ol><blockquote><p>原文链接：https://blog.csdn.net/trigl/article/details/50968079</p><p>数据库用的是mvcc+各种锁来解决的三种问题(简单理解为乐观锁)</p><p><a href=https://www.cnblogs.com/hansc-blog/p/9358524.html target=_blank rel=noopener>简述三种的情况的处理</a></p><p><a href=https://blog.csdn.net/silyvin/article/details/77482920 target=_blank rel=noopener>不可重复读与幻读的解决方案</a></p></blockquote><ol start=2><li>隔离级别(围绕三种读的隔离)</li></ol><table><thead><tr><th>隔离级别</th><th>含义</th></tr></thead><tbody><tr><td>ISOLATION_DEFAULT</td><td>使用后端数据库默认的隔离级别 (springboot中注解默认级别)</td></tr><tr><td>ISOLATION_READ_UNCOMMITTED</td><td>(读未提交)最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</td></tr><tr><td>ISOLATION_READ_COMMITTED</td><td>(读已提交)允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</td></tr><tr><td>ISOLATION_REPEATABLE_READ</td><td>(可重复读)对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</td></tr><tr><td>ISOLATION_SERIALIZABLE</td><td>最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</td></tr></tbody></table><blockquote><p>mysql默认的事务处理级别是&rsquo;REPEATABLE-READ&rsquo;,也就是可重复读</p><p>oracle默认系统事务隔离级别是READ COMMITTED,也就是读已提交</p></blockquote><blockquote><p>原文链接：https://blog.csdn.net/trigl/article/details/50968079</p></blockquote><h1 id=5-编程式事务>5. 编程式事务<a hidden class=anchor aria-hidden=true href=#5-编程式事务>#</a></h1><p>编程式和声明式事务的区别</p><ul><li>编程式事务允许用户在代码中精确定义事务的边界，</li><li>声明式事务（基于AOP）有助于用户将操作与事务规则进行解耦。 (@Transactional)</li></ul><p>简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现。</p><p>原文链接：https://blog.csdn.net/trigl/article/details/50968079</p><p><strong>进阶版使用</strong>:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>@Component</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>public</span> <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>TransactionHelper</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>@Transactional</span><span style=color:#ff7b72;font-weight:700>(</span>propagation <span style=color:#ff7b72;font-weight:700>=</span> Propagation<span style=color:#ff7b72;font-weight:700>.</span>REQUIRED<span style=color:#ff7b72;font-weight:700>,</span> rollbackFor <span style=color:#ff7b72;font-weight:700>=</span> Exception<span style=color:#ff7b72;font-weight:700>.</span>class<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> T <span style=color:#d2a8ff;font-weight:700>run</span><span style=color:#ff7b72;font-weight:700>(</span>Supplier<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> command<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> command<span style=color:#ff7b72;font-weight:700>.</span>get<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>@Transactional</span><span style=color:#ff7b72;font-weight:700>(</span>propagation <span style=color:#ff7b72;font-weight:700>=</span> Propagation<span style=color:#ff7b72;font-weight:700>.</span>REQUIRED<span style=color:#ff7b72;font-weight:700>,</span> rollbackFor <span style=color:#ff7b72;font-weight:700>=</span> Exception<span style=color:#ff7b72;font-weight:700>.</span>class<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>run</span><span style=color:#ff7b72;font-weight:700>(</span>Runnable command<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        command<span style=color:#ff7b72;font-weight:700>.</span>run<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>@Transactional</span><span style=color:#ff7b72;font-weight:700>(</span>propagation <span style=color:#ff7b72;font-weight:700>=</span> Propagation<span style=color:#ff7b72;font-weight:700>.</span>REQUIRED<span style=color:#ff7b72;font-weight:700>,</span> rollbackFor <span style=color:#ff7b72;font-weight:700>=</span> Exception<span style=color:#ff7b72;font-weight:700>.</span>class<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>,</span> R<span style=color:#ff7b72;font-weight:700>&gt;</span> R <span style=color:#d2a8ff;font-weight:700>run</span><span style=color:#ff7b72;font-weight:700>(</span>Function<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>,</span> R<span style=color:#ff7b72;font-weight:700>&gt;</span> command<span style=color:#ff7b72;font-weight:700>,</span> T param<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> command<span style=color:#ff7b72;font-weight:700>.</span>apply<span style=color:#ff7b72;font-weight:700>(</span>param<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 使用
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#d2a8ff;font-weight:700>@Resource</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>private</span> TransactionHelper transactionHelper<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span> 	<span style=color:#ff7b72>private</span> <span style=color:#ff7b72>boolean</span> <span style=color:#d2a8ff;font-weight:700>transactionSaveWebsiteMessageByTemplate</span><span style=color:#ff7b72;font-weight:700>(</span>List<span style=color:#ff7b72;font-weight:700>&lt;</span>BaseWebsiteMessageQuery<span style=color:#ff7b72;font-weight:700>&gt;</span> websiteMessageQuery<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> transactionHelper<span style=color:#ff7b72;font-weight:700>.</span>run<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#ff7b72>this</span><span style=color:#ff7b72;font-weight:700>::</span>saveWebsiteMessageByTemplate<span style=color:#ff7b72;font-weight:700>,</span> websiteMessageQuery<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><h1 id=6-aop失效>6. AOP失效<a hidden class=anchor aria-hidden=true href=#6-aop失效>#</a></h1><h2 id=61-自调用>6.1 自调用<a hidden class=anchor aria-hidden=true href=#61-自调用>#</a></h2><p><strong>自调用</strong>: A方法调用B方法, 把事务注解加到B方法上,这就是自调用, 自调用不会触发事务(官方说的)</p><p>这是由AOP原理决定的,<strong>动态代理是类的代理,只有出现类的调用才会触发事务</strong>, 而类内部的函数调用就不是类的调用了</p><p>解决方案:</p><ol><li>将注解写到A方法上</li><li>将B方法抽离出来,再写一个类, 在A方法最后再调用B方法</li><li>不用注解,使用声明书事务(就是手动开启事务)</li><li>再次模拟一次编程式调用,让A方法在事务内调回来</li></ol><blockquote><p><a href=!https://www.cnblogs.com/liuzhihang/p/spring-self-call.html>原理及解决方案</a></p><p><a href=!https://www.jianshu.com/p/9ccab5a00bac>原理介绍</a></p></blockquote><h2 id=62--private-修饰的方法>6.2 private 修饰的方法<a hidden class=anchor aria-hidden=true href=#62--private-修饰的方法>#</a></h2><blockquote><p><a href=https://www.cnblogs.com/liuzhihang/p/spring-self-call.html target=_blank rel=noopener>Spring 自调用事务失效，你是怎么解决的？ - 程序员小航 - 博客园 (cnblogs.com)</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/Spring.html>Spring</a></li><li><a href=https://xiaokunji.com/zh/tags/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B.html><span class=title>« 上一页</span><br><span>使用案例</span></a>
<a class=next href=https://xiaokunji.com/zh/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1.html><span class=title>下一页 »</span><br><span>事务</span></a></nav></footer></article></main><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>