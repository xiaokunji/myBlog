<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>泛型 | 米二</title><meta name=keywords content=" 一. 为啥要泛型?, 二. 什么是泛型？, 三. 泛型的使用"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="泛型"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B.html"><meta property="article:section" content="java及其框架"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-04T12:01:52+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="泛型"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"泛型","item":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"泛型","name":"泛型","description":"     ","keywords":[" 一. 为啥要泛型?"," 二. 什么是泛型？"," 三. 泛型的使用"],"articleBody":"[toc]\n一. 为啥要泛型? 简单的说,我 new一个list,我想放字符串,数字等多种数据类型,怎么办? 那就整个泛型!(理解意思就行)\nhttps://www.cnblogs.com/lwbqqyumidi/p/3837629.html 二. 什么是泛型？ 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。\n来自 https://www.cnblogs.com/lwbqqyumidi/p/3837629.html 三. 泛型的使用 泛型类 //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型(见名知意), T : Type K V : Key Value E : Element ? : 泛型通配符(后面会讲到) 来自 https://segmentfault.com/a/1190000014824002 //在实例化泛型类时，必须指定T的具体类型 public class Generic\u003cT\u003e{ //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; } public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; } } 注意：\n泛型的类型参数只能是类类型，不能是简单类型。\n不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。 if(ex_num instanceof Generic){ } 来自https://blog.csdn.net/s10461/article/details/53941091#commentBox 泛型接口 //定义一个泛型接口 public interface Generator\u003cT\u003e { public T next(); } 来自 https://blog.csdn.net/s10461/article/details/53941091#commentBox 泛型方法 /** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */ public \u003cT\u003e T genericMethod(Class\u003cT\u003e tClass)throws Exception{ T instance = tClass.newInstance(); return instance; } public class GenericTest { //这个类是个泛型类，在上面已经介绍过 public class Generic\u003cT\u003e{ private T key; public Generic(T key) { this.key = key; } //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。 //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。 //所以在这个方法中才可以继续使用 T 这个泛型。 public T getKey(){ return key; } /** * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息\"cannot reslove symbol E\" * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。 public E setKey(E key){ this.key = keu } */ } /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public K showKeyName(Generic container){ * ... * } */ public \u003cT\u003e T showKeyName(Generic\u003cT\u003e container){ System.out.println(\"container key :\" + container.getKey()); //当然这个例子举的不太合适，只是为了说明泛型方法的特性。 T test = container.getKey(); return test; } //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic这个泛型类做形参而已。 public void showKeyValue1(Generic\u003cNumber\u003e obj){ Log.d(\"泛型测试\",\"key value is \" + obj.getKey()); } //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符? //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类 public void showKeyValue2(Generic\u003c?\u003e obj){ Log.d(\"泛型测试\",\"key value is \" + obj.getKey()); } /** * 这个方法是有问题的，编译器会为我们提示错误信息：\"UnKnown class 'E' \" * 虽然我们声明了,也表明了这是一个可以处理泛型的类型的泛型方法。 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。 public T showKeyName(Generic container){ ... } */ /** * 这个方法也是有问题的，编译器会为我们提示错误信息：\"UnKnown class 'T' \" * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。 * 所以这也不是一个正确的泛型方法声明。 public void showkey(T genericObj){ } */ public static void main(String[] args) { } } 类中的泛型方法 当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下\npublic class GenericFruit { class Fruit{ @Override public String toString() { return \"fruit\"; } } class Apple extends Fruit{ @Override public String toString() { return \"apple\"; } } class Person{ @Override public String toString() { return \"Person\"; } } class GenerateTest\u003cT\u003e{ public void show_1(T t){ System.out.println(t.toString()); } //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。 public \u003cE\u003e void show_3(E t){ System.out.println(t.toString()); } //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public \u003cT\u003e void show_2(T t){ System.out.println(t.toString()); } } public static void main(String[] args) { Apple apple = new Apple(); Person person = new Person(); GenerateTest\u003cFruit\u003e generateTest = new GenerateTest\u003cFruit\u003e(); //apple是Fruit的子类，所以这里可以 generateTest.show_1(apple); //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person //generateTest.show_1(person); //使用这两个方法都可以成功 generateTest.show_2(apple); generateTest.show_2(person); //使用这两个方法也都可以成功 generateTest.show_3(apple); generateTest.show_3(person); } } 来自 https://blog.csdn.net/s10461/article/details/53941091#commentBox 泛型方法与可变参数 public \u003cT\u003e void printMsg( T... args){ for(T t : args){ Log.d(\"泛型测试\",\"t is \" + t); } } 注意: 泛型没有多态,没有数组\n不能创建一个确切的泛型类型的数组 也就是说下面的这个例子是不可以的：\n`List\u003cString\u003e[] ls = new ArrayList\u003cString\u003e[10];` 来自 \u003chttps://blog.csdn.net/s10461/article/details/53941091#commentBox\u003e 静态方法与泛型 public class StaticGenerator\u003cT\u003e { .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t){..},此时编译器会提示错误信息： \"StaticGenerator cannot be refrenced from static context\" */ public static \u003cT\u003e void show(T t){ } } 来自 https://blog.csdn.net/s10461/article/details/53941091#commentBox 通配符 ?\n在某些源码中看到有 ? ,这是什么意思呢? public static void Collections.copy(List dest, List\u003c? extends T\u003e src) { ... } 类型通配符一般是使用？代替具体的类型实参，注意了，重要说三遍！ 此处’？’是类型实参，而不是类型形参 ! 此处’？’是类型实参，而不是类型形参 ！ 此处’？’是类型实参，而不是类型形参 ！ 再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。 可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。\n类型通配符上限和类型通配符下限\n类型通配符上限通过形如Box\u003c? extends Number\u003e形式定义，相对应的，类型通配符下限为Box\u003c? super Number\u003e形式，其含义与类型通配符上限正好相反 上限: 只允许继承了Number的类型 下限: 只允许实现了Number的类型 (有利于控制类型嘛,不让你瞎几把 放参数)\n来自 https://www.cnblogs.com/lwbqqyumidi/p/3837629.html 解释一下项目中产生的疑惑:\npublic static boolean isBlank(Collection\u003c?\u003e c) { // 1 // c.add(\"3\") 会报错 return null == c || c.isEmpty(); } public static \u003cT\u003e boolean isBlank(Collection\u003cT\u003e c) { // 2 //c.add(\"3\") return null == c || c.isEmpty(); } 可以看到两种方法都做到了泛型判空,(随你输入啥集合,都能判断).但是这两种写法有什么区别呢?\n用通配符的情况下,泛型参数是不能被修改的 (我都不知道你是啥类型,一个范围都没有,我改个鸡毛)\nhttps://blog.csdn.net/sinat_32023305/article/details/83215751 基本上所有能用类型通配符（?）解决的问题都能用泛型方法解决，并且泛型方法可以解决的更好.\n通配符使用场景:\n一般只读就用?，要修改就用泛型方法， 在多个参数、返回值之间存在类型依赖关系就应该使用泛型方法，否则就应该是通配符? 具体讲就是，如果一个方法的返回值、某些参数的类型依赖另一个参数的类型就应该使用泛型方法，因为被依赖的类型如果是不确定的?，那么其他元素就无法依赖它），\n例如： void func(List\u003c? extends T\u003e list, T t);\n即第一个参数依赖第二个参数的类型（第一个参数list的类型参数必须是第二个参数的类型或者其子类）；\n可以看到，Java支持泛型方法和?混用；\n这个方法也可以写成： void func(List list, T t);\n// 明显意义是一样的，只不过这个list可以修改，而上一个list无法修改 总之就是一旦返回值、形参之间存在类型依赖关系就只能使用泛型方法； 否则就应该使用 ? ；\n一个最典型的应用就是容器赋值方法（Java的API）：public static void Collections.copy(List dest, List\u003c? extends T\u003e src) { ... }\n！！从src拷贝到dest，那么dest最好是src的类型或者其父类，因为这样才能类型兼容，并且src只是读取，没必要做修改，因此使用?还可以强制避免你对src做不必要的修改，增加的安全性\n来自 https://blog.csdn.net/sinat_32023305/article/details/83215751 ","wordCount":"3485","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-09-04T12:01:52.664300798Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80.html>java基础</a> <span>></span></ul></nav><h1 class=post-title>泛型</h1><div class=post-description></div><div class=post-meta>创建:&nbsp;<span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;更新:&nbsp;2023-09-04&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv>1</span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80-%e4%b8%ba%e5%95%a5%e8%a6%81%e6%b3%9b%e5%9e%8b aria-label="一. 为啥要泛型?">一. 为啥要泛型?</a></li><li><a href=#%e4%ba%8c-%e4%bb%80%e4%b9%88%e6%98%af%e6%b3%9b%e5%9e%8b aria-label="二. 什么是泛型？">二. 什么是泛型？</a></li><li><a href=#%e4%b8%89-%e6%b3%9b%e5%9e%8b%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label="三. 泛型的使用">三. 泛型的使用</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=一-为啥要泛型>一. 为啥要泛型?<a hidden class=anchor aria-hidden=true href=#一-为啥要泛型>#</a></h1><p>简单的说,我 new一个list,我想放字符串,数字等多种数据类型,怎么办? 那就整个泛型!(理解意思就行)</p><blockquote><p><a href=https://www.cnblogs.com/lwbqqyumidi/p/3837629.html target=_blank rel=noopener>https://www.cnblogs.com/lwbqqyumidi/p/3837629.html</a></p></blockquote><h1 id=二-什么是泛型>二. 什么是泛型？<a hidden class=anchor aria-hidden=true href=#二-什么是泛型>#</a></h1><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><blockquote><p>来自 <a href=https://www.cnblogs.com/lwbqqyumidi/p/3837629.html target=_blank rel=noopener>https://www.cnblogs.com/lwbqqyumidi/p/3837629.html</a></p></blockquote><h1 id=三-泛型的使用>三. 泛型的使用<a hidden class=anchor aria-hidden=true href=#三-泛型的使用>#</a></h1><ol><li>泛型类
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型(见名知意),<ul><li>T : Type</li><li>K V : Key Value</li><li>E : Element</li><li>? : 泛型通配符(后面会讲到)</li></ul></li></ol><blockquote><p>来自 <a href=https://segmentfault.com/a/1190000014824002 target=_blank rel=noopener>https://segmentfault.com/a/1190000014824002</a></p></blockquote><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#8b949e;font-style:italic>//在实例化泛型类时，必须指定T的具体类型
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>public</span> <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>Generic</span><span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;{</span> 
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>//key这个成员变量的类型为T,T的类型由外部指定  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>private</span> T key<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72>public</span> <span style=color:#d2a8ff;font-weight:700>Generic</span><span style=color:#ff7b72;font-weight:700>(</span>T key<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span> <span style=color:#8b949e;font-style:italic>//泛型构造方法形参key的类型也为T，T的类型由外部指定
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#ff7b72>this</span><span style=color:#ff7b72;font-weight:700>.</span>key <span style=color:#ff7b72;font-weight:700>=</span> key<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72>public</span> T <span style=color:#d2a8ff;font-weight:700>getKey</span><span style=color:#ff7b72;font-weight:700>(){</span> <span style=color:#8b949e;font-style:italic>//泛型方法getKey的返回值类型为T，T的类型由外部指定
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#ff7b72>return</span> key<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><blockquote><p>注意：</p><ol><li><p>泛型的类型参数只能是类类型，不能是简单类型。</p></li><li><p>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。
<code>if(ex_num instanceof Generic&lt;Number>){ }</code></p></li></ol><p>来自<a href=https://blog.csdn.net/s10461/article/details/53941091#commentBox target=_blank rel=noopener>https://blog.csdn.net/s10461/article/details/53941091#commentBox</a></p></blockquote><ol start=2><li>泛型接口</li></ol><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#8b949e;font-style:italic>//定义一个泛型接口
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	<span style=color:#ff7b72>public</span> <span style=color:#ff7b72>interface</span> <span style=color:#f0883e;font-weight:700>Generator</span><span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72>public</span> T <span style=color:#d2a8ff;font-weight:700>next</span><span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>	<span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><blockquote><p>来自 <a href=https://blog.csdn.net/s10461/article/details/53941091#commentBox target=_blank rel=noopener>https://blog.csdn.net/s10461/article/details/53941091#commentBox</a></p></blockquote><ol start=3><li>泛型方法</li></ol><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 泛型方法的基本介绍
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * @param tClass 传入的泛型实参
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * @return T 返回值为T类型
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 说明：
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>public</span> <span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> T <span style=color:#d2a8ff;font-weight:700>genericMethod</span><span style=color:#ff7b72;font-weight:700>(</span>Class<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> tClass<span style=color:#ff7b72;font-weight:700>)</span><span style=color:#ff7b72>throws</span> Exception<span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        T instance <span style=color:#ff7b72;font-weight:700>=</span> tClass<span style=color:#ff7b72;font-weight:700>.</span>newInstance<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> instance<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>public</span> <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>GenericTest</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>   <span style=color:#8b949e;font-style:italic>//这个类是个泛型类，在上面已经介绍过
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>   <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>Generic</span><span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;{</span>     
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>private</span> T key<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>	        <span style=color:#ff7b72>public</span> <span style=color:#d2a8ff;font-weight:700>Generic</span><span style=color:#ff7b72;font-weight:700>(</span>T key<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>this</span><span style=color:#ff7b72;font-weight:700>.</span>key <span style=color:#ff7b72;font-weight:700>=</span> key<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	        <span style=color:#8b949e;font-style:italic>//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#8b949e;font-style:italic>//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#8b949e;font-style:italic>//所以在这个方法中才可以继续使用 T 这个泛型。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#ff7b72>public</span> T <span style=color:#d2a8ff;font-weight:700>getKey</span><span style=color:#ff7b72;font-weight:700>(){</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> key<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	        <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&#34;cannot reslove symbol E&#34;
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>        public E setKey(E key){
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>             this.key = keu
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>        }
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>        */</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	    <span style=color:#8b949e;font-style:italic>/** 
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 这才是一个真正的泛型方法。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 这个T可以出现在这个泛型方法的任意位置.
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 泛型的数量也可以为任意多个 
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container){
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     *        ...
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     *        }
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> T <span style=color:#d2a8ff;font-weight:700>showKeyName</span><span style=color:#ff7b72;font-weight:700>(</span>Generic<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> container<span style=color:#ff7b72;font-weight:700>){</span>
</span></span><span style=display:flex><span>        System<span style=color:#ff7b72;font-weight:700>.</span>out<span style=color:#ff7b72;font-weight:700>.</span>println<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#a5d6ff>&#34;container key :&#34;</span> <span style=color:#ff7b72;font-weight:700>+</span> container<span style=color:#ff7b72;font-weight:700>.</span>getKey<span style=color:#ff7b72;font-weight:700>());</span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>//当然这个例子举的不太合适，只是为了说明泛型方法的特性。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        T test <span style=color:#ff7b72;font-weight:700>=</span> container<span style=color:#ff7b72;font-weight:700>.</span>getKey<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> test<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	    <span style=color:#8b949e;font-style:italic>//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>showKeyValue1</span><span style=color:#ff7b72;font-weight:700>(</span>Generic<span style=color:#ff7b72;font-weight:700>&lt;</span>Number<span style=color:#ff7b72;font-weight:700>&gt;</span> obj<span style=color:#ff7b72;font-weight:700>){</span>
</span></span><span style=display:flex><span>        Log<span style=color:#ff7b72;font-weight:700>.</span>d<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#a5d6ff>&#34;泛型测试&#34;</span><span style=color:#ff7b72;font-weight:700>,</span><span style=color:#a5d6ff>&#34;key value is &#34;</span> <span style=color:#ff7b72;font-weight:700>+</span> obj<span style=color:#ff7b72;font-weight:700>.</span>getKey<span style=color:#ff7b72;font-weight:700>());</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	    <span style=color:#8b949e;font-style:italic>//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#8b949e;font-style:italic>//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>showKeyValue2</span><span style=color:#ff7b72;font-weight:700>(</span>Generic<span style=color:#ff7b72;font-weight:700>&lt;?&gt;</span> obj<span style=color:#ff7b72;font-weight:700>){</span>
</span></span><span style=display:flex><span>        Log<span style=color:#ff7b72;font-weight:700>.</span>d<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#a5d6ff>&#34;泛型测试&#34;</span><span style=color:#ff7b72;font-weight:700>,</span><span style=color:#a5d6ff>&#34;key value is &#34;</span> <span style=color:#ff7b72;font-weight:700>+</span> obj<span style=color:#ff7b72;font-weight:700>.</span>getKey<span style=color:#ff7b72;font-weight:700>());</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	     <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 这个方法是有问题的，编译器会为我们提示错误信息：&#34;UnKnown class &#39;E&#39; &#34;
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container){
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>        ...
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>    }  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>    */</span>
</span></span><span style=display:flex><span>	    <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 这个方法也是有问题的，编译器会为我们提示错误信息：&#34;UnKnown class &#39;T&#39; &#34;
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 所以这也不是一个正确的泛型方法声明。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>    public void showkey(T genericObj){
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>	    }
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>    */</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>static</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>main</span><span style=color:#ff7b72;font-weight:700>(</span>String<span style=color:#ff7b72;font-weight:700>[]</span> args<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><ol start=4><li>类中的泛型方法</li></ol><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#ff7b72>public</span> <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>GenericFruit</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>Fruit</span><span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>public</span> String <span style=color:#d2a8ff;font-weight:700>toString</span><span style=color:#ff7b72;font-weight:700>()</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> <span style=color:#a5d6ff>&#34;fruit&#34;</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>Apple</span> <span style=color:#ff7b72>extends</span> Fruit<span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>public</span> String <span style=color:#d2a8ff;font-weight:700>toString</span><span style=color:#ff7b72;font-weight:700>()</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> <span style=color:#a5d6ff>&#34;apple&#34;</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>Person</span><span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#d2a8ff;font-weight:700>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>public</span> String <span style=color:#d2a8ff;font-weight:700>toString</span><span style=color:#ff7b72;font-weight:700>()</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> <span style=color:#a5d6ff>&#34;Person&#34;</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>GenerateTest</span><span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>show_1</span><span style=color:#ff7b72;font-weight:700>(</span>T t<span style=color:#ff7b72;font-weight:700>){</span>
</span></span><span style=display:flex><span>            System<span style=color:#ff7b72;font-weight:700>.</span>out<span style=color:#ff7b72;font-weight:700>.</span>println<span style=color:#ff7b72;font-weight:700>(</span>t<span style=color:#ff7b72;font-weight:700>.</span>toString<span style=color:#ff7b72;font-weight:700>());</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	        <span style=color:#8b949e;font-style:italic>//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#8b949e;font-style:italic>//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#ff7b72>public</span> <span style=color:#ff7b72;font-weight:700>&lt;</span>E<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>show_3</span><span style=color:#ff7b72;font-weight:700>(</span>E t<span style=color:#ff7b72;font-weight:700>){</span>
</span></span><span style=display:flex><span>            System<span style=color:#ff7b72;font-weight:700>.</span>out<span style=color:#ff7b72;font-weight:700>.</span>println<span style=color:#ff7b72;font-weight:700>(</span>t<span style=color:#ff7b72;font-weight:700>.</span>toString<span style=color:#ff7b72;font-weight:700>());</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	        <span style=color:#8b949e;font-style:italic>//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#ff7b72>public</span> <span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>show_2</span><span style=color:#ff7b72;font-weight:700>(</span>T t<span style=color:#ff7b72;font-weight:700>){</span>
</span></span><span style=display:flex><span>            System<span style=color:#ff7b72;font-weight:700>.</span>out<span style=color:#ff7b72;font-weight:700>.</span>println<span style=color:#ff7b72;font-weight:700>(</span>t<span style=color:#ff7b72;font-weight:700>.</span>toString<span style=color:#ff7b72;font-weight:700>());</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>static</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>main</span><span style=color:#ff7b72;font-weight:700>(</span>String<span style=color:#ff7b72;font-weight:700>[]</span> args<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        Apple apple <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> Apple<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>        Person person <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> Person<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>	        GenerateTest<span style=color:#ff7b72;font-weight:700>&lt;</span>Fruit<span style=color:#ff7b72;font-weight:700>&gt;</span> generateTest <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> GenerateTest<span style=color:#ff7b72;font-weight:700>&lt;</span>Fruit<span style=color:#ff7b72;font-weight:700>&gt;();</span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>//apple是Fruit的子类，所以这里可以
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        generateTest<span style=color:#ff7b72;font-weight:700>.</span>show_1<span style=color:#ff7b72;font-weight:700>(</span>apple<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#8b949e;font-style:italic>//generateTest.show_1(person);
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	        <span style=color:#8b949e;font-style:italic>//使用这两个方法都可以成功
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        generateTest<span style=color:#ff7b72;font-weight:700>.</span>show_2<span style=color:#ff7b72;font-weight:700>(</span>apple<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>        generateTest<span style=color:#ff7b72;font-weight:700>.</span>show_2<span style=color:#ff7b72;font-weight:700>(</span>person<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>	        <span style=color:#8b949e;font-style:italic>//使用这两个方法也都可以成功
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        generateTest<span style=color:#ff7b72;font-weight:700>.</span>show_3<span style=color:#ff7b72;font-weight:700>(</span>apple<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>        generateTest<span style=color:#ff7b72;font-weight:700>.</span>show_3<span style=color:#ff7b72;font-weight:700>(</span>person<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><blockquote><p>来自 <a href=https://blog.csdn.net/s10461/article/details/53941091#commentBox target=_blank rel=noopener>https://blog.csdn.net/s10461/article/details/53941091#commentBox</a></p></blockquote><ol start=5><li>泛型方法与可变参数</li></ol><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#ff7b72>public</span> <span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>printMsg</span><span style=color:#ff7b72;font-weight:700>(</span> T<span style=color:#ff7b72;font-weight:700>...</span> args<span style=color:#ff7b72;font-weight:700>){</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72>for</span><span style=color:#ff7b72;font-weight:700>(</span>T t <span style=color:#ff7b72;font-weight:700>:</span> args<span style=color:#ff7b72;font-weight:700>){</span>
</span></span><span style=display:flex><span>	        Log<span style=color:#ff7b72;font-weight:700>.</span>d<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#a5d6ff>&#34;泛型测试&#34;</span><span style=color:#ff7b72;font-weight:700>,</span><span style=color:#a5d6ff>&#34;t is &#34;</span> <span style=color:#ff7b72;font-weight:700>+</span> t<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	<span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><blockquote><p>注意: 泛型没有多态,没有数组</p></blockquote><pre><code> 不能创建一个确切的泛型类型的数组
</code></pre><p>也就是说下面的这个例子是不可以的：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#f85149>`</span>List<span style=color:#ff7b72;font-weight:700>&lt;</span>String<span style=color:#ff7b72;font-weight:700>&gt;[]</span> ls <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> ArrayList<span style=color:#ff7b72;font-weight:700>&lt;</span>String<span style=color:#ff7b72;font-weight:700>&gt;[</span>10<span style=color:#ff7b72;font-weight:700>];</span><span style=color:#f85149>`</span>   
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    来自 <span style=color:#ff7b72;font-weight:700>&lt;</span>https<span style=color:#ff7b72;font-weight:700>:</span><span style=color:#8b949e;font-style:italic>//blog.csdn.net/s10461/article/details/53941091#commentBox&gt; 
</span></span></span></code></pre></div><ol start=6><li>静态方法与泛型</li></ol><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#ff7b72>public</span> <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>StaticGenerator</span><span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>....</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>....</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 如：public static void show(T t){..},此时编译器会提示错误信息：
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>          &#34;StaticGenerator cannot be refrenced from static context&#34;
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>static</span> <span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>show</span><span style=color:#ff7b72;font-weight:700>(</span>T t<span style=color:#ff7b72;font-weight:700>){</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><blockquote><p>来自 <a href=https://blog.csdn.net/s10461/article/details/53941091#commentBox target=_blank rel=noopener>https://blog.csdn.net/s10461/article/details/53941091#commentBox</a></p></blockquote><ol start=7><li><p>通配符 ?</p><ol><li><p>在某些源码中看到有 ? ,这是什么意思呢?
<code>public static &lt;T> void Collections.copy(List&lt;T> dest, List&lt;? extends T> src) { ... }</code>
类型通配符一般是使用？代替具体的类型实参，注意了，重要说三遍！
此处’？’是类型实参，而不是类型形参 !
此处’？’是类型实参，而不是类型形参 ！
此处’？’是类型实参，而不是类型形参 ！
再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。
可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p></li><li><p>类型通配符上限和类型通配符下限</p></li></ol><p>类型通配符上限通过形如Box&lt;? extends Number>形式定义，相对应的，类型通配符下限为Box&lt;? super Number>形式，其含义与类型通配符上限正好相反
上限: 只允许继承了Number的类型
下限: 只允许实现了Number的类型
(有利于控制类型嘛,不让你瞎几把 放参数)</p></li></ol><blockquote><p>来自 <a href=https://www.cnblogs.com/lwbqqyumidi/p/3837629.html target=_blank rel=noopener>https://www.cnblogs.com/lwbqqyumidi/p/3837629.html</a></p></blockquote><p>解释一下项目中产生的疑惑:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#ff7b72>public</span> <span style=color:#ff7b72>static</span>   <span style=color:#ff7b72>boolean</span> <span style=color:#d2a8ff;font-weight:700>isBlank</span><span style=color:#ff7b72;font-weight:700>(</span>Collection<span style=color:#ff7b72;font-weight:700>&lt;?&gt;</span> c<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span> <span style=color:#8b949e;font-style:italic>// 1
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	               <span style=color:#8b949e;font-style:italic>// c.add(&#34;3&#34;)  会报错
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	        <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>null</span> <span style=color:#ff7b72;font-weight:700>==</span> c <span style=color:#ff7b72;font-weight:700>||</span> c<span style=color:#ff7b72;font-weight:700>.</span>isEmpty<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>	    
</span></span><span style=display:flex><span>	<span style=color:#ff7b72>public</span> <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72>boolean</span> <span style=color:#d2a8ff;font-weight:700>isBlank</span><span style=color:#ff7b72;font-weight:700>(</span>Collection<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> c<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span> <span style=color:#8b949e;font-style:italic>// 2
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	                <span style=color:#8b949e;font-style:italic>//c.add(&#34;3&#34;)
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>	        <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>null</span> <span style=color:#ff7b72;font-weight:700>==</span> c <span style=color:#ff7b72;font-weight:700>||</span> c<span style=color:#ff7b72;font-weight:700>.</span>isEmpty<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>	    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p>可以看到两种方法都做到了泛型判空,(随你输入啥集合,都能判断).但是这两种写法有什么区别呢?</p><p>用通配符的情况下,泛型参数是不能被修改的 (我都不知道你是啥类型,一个范围都没有,我改个鸡毛)</p><blockquote><p><a href=https://blog.csdn.net/sinat_32023305/article/details/83215751 target=_blank rel=noopener>https://blog.csdn.net/sinat_32023305/article/details/83215751</a></p></blockquote><p>基本上所有能用类型通配符（?）解决的问题都能用泛型方法解决，并且泛型方法可以解决的更好.</p><p>通配符使用场景:</p><ul><li>一般只读就用?，要修改就用泛型方法，</li><li>在多个参数、返回值之间存在类型依赖关系就应该使用泛型方法，否则就应该是通配符?</li></ul><p>具体讲就是，如果一个方法的返回值、某些参数的类型依赖另一个参数的类型就应该使用泛型方法，因为被依赖的类型如果是不确定的?，那么其他元素就无法依赖它），</p><p>例如：<code>&lt;T> void func(List&lt;? extends T> list, T t);</code></p><p>即第一个参数依赖第二个参数的类型（第一个参数list的类型参数必须是第二个参数的类型或者其子类）；</p><p>可以看到，Java支持泛型方法和?混用；</p><p>这个方法也可以写成：<code>&lt;T, E extends T> void func(List&lt;E> list, T t);</code></p><p>// 明显意义是一样的，只不过这个list可以修改，而上一个list无法修改
总之就是一旦返回值、形参之间存在类型依赖关系就只能使用泛型方法；  否则就应该使用 ? ；</p><p>一个最典型的应用就是容器赋值方法（Java的API）：<code>public static &lt;T> void Collections.copy(List&lt;T> dest, List&lt;? extends T> src) { ... }</code></p><p>！！从src拷贝到dest，那么dest最好是src的类型或者其父类，因为这样才能类型兼容，并且src只是读取，没必要做修改，因此使用?还可以强制避免你对src做不必要的修改，增加的安全性</p><blockquote><p>来自 <a href=https://blog.csdn.net/sinat_32023305/article/details/83215751 target=_blank rel=noopener>https://blog.csdn.net/sinat_32023305/article/details/83215751</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/Java%E5%9F%BA%E7%A1%80.html>Java基础</a></li><li><a href=https://xiaokunji.com/zh/tags/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E6%9D%82%E9%A1%B9/%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%A8%A1%E5%BC%8F.html><span class=title>« 上一页</span><br><span>多租户模式</span></a>
<a class=next href=https://xiaokunji.com/zh/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%8C%83%E5%BC%8F.html><span class=title>下一页 »</span><br><span>范式</span></a></nav></footer></article></main><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>