<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>类加载机制 | 米二</title><meta name=keywords content=" 1. 什么是类的加载机制, 2. 类的生命周期, 2.1 加载：查找并加载类的二进制数据, 2.2 连接, 2.3 初始化, 2.4 结束生命周期, 3. 类加载器, 4. 类的加载, 5、双亲委派模型, 5.1 为什么需要双亲委派, 5.2 双亲委派机制, 5.3 为什么需要破坏双亲委派"><meta name=description content="jvm类加载机制"><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="类加载机制"><meta property="og:description" content="jvm类加载机制"><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"><meta property="article:section" content="java及其框架"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-11T06:15:14+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="类加载机制"><meta name=twitter:description content="jvm类加载机制"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"类加载机制","item":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"类加载机制","name":"类加载机制","description":"jvm类加载机制","keywords":[" 1. 什么是类的加载机制"," 2. 类的生命周期"," 2.1 加载：查找并加载类的二进制数据"," 2.2 连接"," 2.3 初始化"," 2.4 结束生命周期"," 3. 类加载器"," 4. 类的加载"," 5、双亲委派模型"," 5.1 为什么需要双亲委派"," 5.2 双亲委派机制"," 5.3 为什么需要破坏双亲委派"],"articleBody":"[toc]\n1. 什么是类的加载机制 ​\t类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。\n类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误\n加载.class文件的方式\n从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件 2. 类的生命周期 其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。\n2.1 加载：查找并加载类的二进制数据 加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：\n1、通过一个类的全限定名来获取其定义的二进制字节流。\n2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。\n相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。\n2.2 连接 验证：确保被加载的类的正确性 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：\n文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。\n元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。\n字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。\n符号引用验证：确保解析动作能正确执行。\n验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。\n准备：为类的静态变量分配内存，并将其初始化为默认值\n准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：\n(1)、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。\n(2)、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。\n假设一个类变量的定义为：public static int value = 3；\n那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。\n· 这里还需要注意如下几点：\n对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。\n详见地址 ​\t(3)、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。\n假设上面的类变量value被定义为： public static final int value = 3；\n编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。回忆上一篇博文中对象被动引用的第2个例子，便是这种情况。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中\n解析：把类中的符号引用转换为直接引用 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。\n符号引用: 就是一组符号来描述目标，可以是任何字面量。\n直接引用: 就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。\n2.3 初始化 ​\t初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：\n①声明类变量是指定初始值\n②使用静态代码块为类变量指定初始值\nJVM初始化步骤\n假如这个类还没有被加载和连接，则程序先加载并连接该类 假如该类的直接父类还没有被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：\n创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如Class.forName(“com.shengsiyuan.Test”)） 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类 2.4 结束生命周期 在如下几种情况下，Java虚拟机将结束生命周期\n执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 3. 类加载器 类加载器可以大致划分为以下三类：\n启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。\n扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\\jre\\lib目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。\n应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：\n1）在执行非置信代码之前，自动验证数字签名。\n2）动态地创建符合用户特定需要的定制化构建类。\n3）从特定的场所取得java class，例如数据库中和网络中。\n启动类加载器 它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；\n其他类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。\n这几种类加载器的层次关系如下图所示\n注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的\nJVM类加载机制\n全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 4. 类的加载 类加载有三种方式：\n1、命令行启动应用时候由JVM初始化加载\n2、通过Class.forName()方法动态加载\n3、通过ClassLoader.loadClass()方法动态加载\n5、双亲委派模型 ​\t双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。\n5.1 为什么需要双亲委派 对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在Java虚拟机中的唯一性。\n判断一个类是否相同，通常用equals()方法，isInstance()方法和isAssignableFrom()方法。来判断，对于同一个类，如果没有采用相同的类加载器来加载，在调用的时候，会产生意想不到的结果\nspring Boot项目,加入热部署依赖后,就会出现这种问题,明明是同一个类,却报错java.lang.ClassCastException,因为热部署是通过自定义的类加载器的方式,动态的刷新内存做到的\n详见地址 5.2 双亲委派机制 1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。\n2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。\n3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；\n4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。\n双亲委派模型意义：\n系统类防止内存中出现多份同样的字节码\n保证Java程序安全稳定运行\nClassLoader源码分析：\npublic Class\u003c?\u003e loadClass(String name)throws ClassNotFoundException { return loadClass(name, false); } protected synchronized Class\u003c?\u003e loadClass(String name, boolean resolve)throws ClassNotFoundException { // 首先判断该类型是否已经被加载 Class c = findLoadedClass(name); if (c == null) { //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载 try { if (parent != null) { //如果存在父类加载器，就委派给父类加载器加载 c = parent.loadClass(name, false); } else { //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name) c = findBootstrapClass0(name); } } catch (ClassNotFoundException e) { // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能 c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } 5.3 为什么需要破坏双亲委派 ​\t因为在某些情况下父类加载器需要委托子类加载器去加载class文件。受到加载范围的限制，父类加载器无法加载到需要的文件，以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。\n详情地址 参考地址:\n类的加载机制 双亲委派机制 ","wordCount":"5414","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-09-11T06:15:14.493248002Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80.html>java基础</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM.html>jvm</a> <span>></span></ul></nav><h1 class=post-title>类加载机制</h1><div class=post-description>jvm类加载机制</div><div class=post-meta>创建:&nbsp;<span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;更新:&nbsp;2023-09-11&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv>1</span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#1-%e4%bb%80%e4%b9%88%e6%98%af%e7%b1%bb%e7%9a%84%e5%8a%a0%e8%bd%bd%e6%9c%ba%e5%88%b6 aria-label="1. 什么是类的加载机制">1. 什么是类的加载机制</a></li><li><a href=#2-%e7%b1%bb%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f aria-label="2. 类的生命周期">2. 类的生命周期</a><ul><li><a href=#21-%e5%8a%a0%e8%bd%bd%e6%9f%a5%e6%89%be%e5%b9%b6%e5%8a%a0%e8%bd%bd%e7%b1%bb%e7%9a%84%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%95%b0%e6%8d%ae aria-label="2.1 加载：查找并加载类的二进制数据">2.1 加载：查找并加载类的二进制数据</a></li><li><a href=#22-%e8%bf%9e%e6%8e%a5 aria-label="2.2 连接">2.2 连接</a></li><li><a href=#23-%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label="2.3 初始化">2.3 初始化</a></li><li><a href=#24-%e7%bb%93%e6%9d%9f%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f aria-label="2.4 结束生命周期">2.4 结束生命周期</a></li></ul></li><li><a href=#3-%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8 aria-label="3. 类加载器">3. 类加载器</a></li><li><a href=#4-%e7%b1%bb%e7%9a%84%e5%8a%a0%e8%bd%bd aria-label="4. 类的加载">4. 类的加载</a></li><li><a href=#5%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be%e6%a8%a1%e5%9e%8b aria-label=5、双亲委派模型>5、双亲委派模型</a><ul><li><a href=#51-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be aria-label="5.1 为什么需要双亲委派">5.1 为什么需要双亲委派</a></li><li><a href=#52-%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be%e6%9c%ba%e5%88%b6 aria-label="5.2 双亲委派机制">5.2 双亲委派机制</a></li><li><a href=#53-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e7%a0%b4%e5%9d%8f%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be aria-label="5.3 为什么需要破坏双亲委派">5.3 为什么需要破坏双亲委派</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=1-什么是类的加载机制>1. 什么是类的加载机制<a hidden class=anchor aria-hidden=true href=#1-什么是类的加载机制>#</a></h1><p>​ 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的<strong>方法区</strong>内，然后在<strong>堆区</strong>创建一个<code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p><img loading=lazy src=%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.assets/331425-20160621125941772-1913742708.png alt=img></p><blockquote><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，<u>JVM规范允许类加载器在预料某个类将要被使用时就预先加载它</u>，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p></blockquote><blockquote><p>加载.class文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul></blockquote><h1 id=2-类的生命周期>2. 类的生命周期<a hidden class=anchor aria-hidden=true href=#2-类的生命周期>#</a></h1><p><img loading=lazy src=%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.assets/331425-20160621125943209-1443333281.png alt=wps257C.tmp></p><p>其中类加载的过程包括了<strong>加载、验证、准备、解析、初始化</strong>五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><h2 id=21-加载查找并加载类的二进制数据>2.1 加载：查找并加载类的二进制数据<a hidden class=anchor aria-hidden=true href=#21-加载查找并加载类的二进制数据>#</a></h2><p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><p>1、通过一个类的全限定名来获取其定义的二进制字节流。</p><p>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p><p>3、在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口。</p><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><h2 id=22-连接>2.2 连接<a hidden class=anchor aria-hidden=true href=#22-连接>#</a></h2><ol><li><strong>验证</strong>：确保被加载的类的正确性</li></ol><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ul><li><p>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p></li><li><p>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了<code>java.lang.Object</code>之外。</p></li><li><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p></li><li><p>符号引用验证：确保解析动作能正确执行。</p></li></ul><blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p></blockquote><ol start=2><li><p><strong>准备</strong>：为类的静态变量分配内存，并将其初始化为默认值</p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><p>(1)、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p><p>(2)、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p><p>假设一个类变量的定义为：public static int value = 3；</p><p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p></li></ol><blockquote><p>· 这里还需要注意如下几点：</p><ul><li><p>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</p><p><a href=https://www.cnblogs.com/ityouknow/p/5603287.html target=_blank rel=noopener>详见地址</a></p></li></ul></blockquote><p>​ (3)、如果类字段的字段属性表中存在<code>ConstantValue</code>属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为<code>ConstValue</code>属性所指定的值。</p><blockquote><p>假设上面的类变量value被定义为： public static final int value = 3；</p><p>编译时Javac将会为value生成<code>ConstantValue</code>属性，在准备阶段虚拟机就会根据<code>ConstantValue</code>的设置将value赋值为3。回忆上一篇博文中对象被动引用的第2个例子，便是这种情况。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中</p></blockquote><ol start=3><li><strong>解析</strong>：把类中的符号引用转换为直接引用</li></ol><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><blockquote><p>符号引用: 就是一组符号来描述目标，可以是任何字面量。</p><p>直接引用: 就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p></blockquote><h2 id=23-初始化>2.3 初始化<a hidden class=anchor aria-hidden=true href=#23-初始化>#</a></h2><p>​ 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><p>①声明类变量是指定初始值</p><p>②使用静态代码块为类变量指定初始值</p><p>JVM初始化步骤</p><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（如<code>Class.forName(“com.shengsiyuan.Test”)</code>）</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</li></ul><h2 id=24-结束生命周期>2.4 结束生命周期<a hidden class=anchor aria-hidden=true href=#24-结束生命周期>#</a></h2><p>在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li>执行了<code>System.exit()</code>方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h1 id=3-类加载器>3. 类加载器<a hidden class=anchor aria-hidden=true href=#3-类加载器>#</a></h1><p>类加载器可以大致划分为以下三类：</p><p><strong>启动类加载器</strong>：<code>Bootstrap ClassLoader</code>，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被<code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p><p><strong>扩展类加载器</strong>：<code>Extension ClassLoader</code>，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载DK\jre\lib目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p><p><strong>应用程序类加载器</strong>：<code>Application ClassLoader</code>，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的<code>ClassLoader</code>只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的<code>ClassLoader</code>，便可以做到如下几点：</p><p>1）在执行非置信代码之前，自动验证数字签名。</p><p>2）动态地创建符合用户特定需要的定制化构建类。</p><p>3）从特定的场所取得java class，例如数据库中和网络中。</p><blockquote><p>启动类加载器 它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；</p><p>其他类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，<u>这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</u></p></blockquote><p>这几种类加载器的层次关系如下图所示</p><blockquote><p><strong>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的</strong></p></blockquote><p><img loading=lazy src=%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.assets/331425-20160621125944459-1013316302.jpg alt=img></p><p><strong>JVM类加载机制</strong></p><ul><li>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul><h1 id=4-类的加载>4. 类的加载<a hidden class=anchor aria-hidden=true href=#4-类的加载>#</a></h1><p>类加载有三种方式：</p><p>1、命令行启动应用时候由JVM初始化加载</p><p>2、通过<code>Class.forName()</code>方法动态加载</p><p>3、通过<code>ClassLoader.loadClass()</code>方法动态加载</p><h1 id=5双亲委派模型>5、双亲委派模型<a hidden class=anchor aria-hidden=true href=#5双亲委派模型>#</a></h1><p>​ 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><h2 id=51-为什么需要双亲委派>5.1 为什么需要双亲委派<a hidden class=anchor aria-hidden=true href=#51-为什么需要双亲委派>#</a></h2><p>对于任意一个类，都需要由<strong>加载它的类加载器</strong>和这个<strong>类本身</strong>来一同确立其在Java虚拟机中的<strong>唯一性</strong>。</p><p>判断一个类是否相同，通常用equals()方法，isInstance()方法和isAssignableFrom()方法。来判断，对于同一个类，如果没有采用相同的类加载器来加载，在调用的时候，会产生意想不到的结果</p><blockquote><p>spring Boot项目,加入热部署依赖后,就会出现这种问题,明明是同一个类,却报错<code>java.lang.ClassCastException</code>,因为热部署是通过自定义的类加载器的方式,动态的刷新内存做到的</p></blockquote><p><a href=https://www.cnblogs.com/joemsu/p/9310226.html#_caption_2 target=_blank rel=noopener>详见地址</a></p><h2 id=52-双亲委派机制>5.2 双亲委派机制<a hidden class=anchor aria-hidden=true href=#52-双亲委派机制>#</a></h2><p>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p><p>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</p><p>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</p><p>4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p><p><strong>双亲委派模型意义</strong>：</p><ul><li><p>系统类防止内存中出现多份同样的字节码</p></li><li><p>保证Java程序安全稳定运行</p></li></ul><p><strong>ClassLoader源码分析：</strong></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span> Class<span style=color:#ff7b72;font-weight:700>&lt;?&gt;</span> loadClass<span style=color:#ff7b72;font-weight:700>(</span>String name<span style=color:#ff7b72;font-weight:700>)</span><span style=color:#ff7b72>throws</span> ClassNotFoundException <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> loadClass<span style=color:#ff7b72;font-weight:700>(</span>name<span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#79c0ff>false</span><span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>protected</span> <span style=color:#ff7b72>synchronized</span> Class<span style=color:#ff7b72;font-weight:700>&lt;?&gt;</span> loadClass<span style=color:#ff7b72;font-weight:700>(</span>String name<span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#ff7b72>boolean</span> resolve<span style=color:#ff7b72;font-weight:700>)</span><span style=color:#ff7b72>throws</span> ClassNotFoundException <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#8b949e;font-style:italic>// 首先判断该类型是否已经被加载
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>            Class c <span style=color:#ff7b72;font-weight:700>=</span> findLoadedClass<span style=color:#ff7b72;font-weight:700>(</span>name<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>c <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                <span style=color:#8b949e;font-style:italic>//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                <span style=color:#ff7b72>try</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>parent <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                         <span style=color:#8b949e;font-style:italic>//如果存在父类加载器，就委派给父类加载器加载
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                        c <span style=color:#ff7b72;font-weight:700>=</span> parent<span style=color:#ff7b72;font-weight:700>.</span>loadClass<span style=color:#ff7b72;font-weight:700>(</span>name<span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#79c0ff>false</span><span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72;font-weight:700>}</span> <span style=color:#ff7b72>else</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#8b949e;font-style:italic>//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                        c <span style=color:#ff7b72;font-weight:700>=</span> findBootstrapClass0<span style=color:#ff7b72;font-weight:700>(</span>name<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72;font-weight:700>}</span> <span style=color:#ff7b72>catch</span> <span style=color:#ff7b72;font-weight:700>(</span>ClassNotFoundException e<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                 <span style=color:#8b949e;font-style:italic>// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                    c <span style=color:#ff7b72;font-weight:700>=</span> findClass<span style=color:#ff7b72;font-weight:700>(</span>name<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>resolve<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                resolveClass<span style=color:#ff7b72;font-weight:700>(</span>c<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> c<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><h2 id=53-为什么需要破坏双亲委派>5.3 为什么需要破坏双亲委派<a hidden class=anchor aria-hidden=true href=#53-为什么需要破坏双亲委派>#</a></h2><p>​ 因为在某些情况下父类加载器需要委托子类加载器去加载class文件。受到加载范围的限制，父类加载器无法加载到需要的文件，以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了<code>MySQL Connector</code>，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。</p><p><a href=https://www.cnblogs.com/joemsu/p/9310226.html#_caption_2 target=_blank rel=noopener>详情地址</a></p><blockquote><p>参考地址:</p><p><a href=https://www.cnblogs.com/ityouknow/p/5603287.html target=_blank rel=noopener>类的加载机制</a></p><p><a href=https://www.cnblogs.com/joemsu/p/9310226.html#_caption_2 target=_blank rel=noopener>双亲委派机制</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/JVM.html>JVM</a></li><li><a href=https://xiaokunji.com/zh/tags/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html><span class=title>« 上一页</span><br><span>垃圾回收器</span></a>
<a class=next href=https://xiaokunji.com/zh/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.html><span class=title>下一页 »</span><br><span>逻辑架构图</span></a></nav></footer></article></main><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>