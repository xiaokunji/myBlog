<!DOCTYPE html>
<html dir="auto" lang="zh"><head><meta charset="utf-8"/><meta content="IE=edge" http-equiv="x-ua-compatible"/><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name="viewport"/><meta content="index, follow" name="robots"/><title>垃圾回收器 | 米二</title><meta content=" 查询默认垃圾收集器, ZGC, CMS, CMS存在的问题, CMS收集器的工作流程(步骤)是什么样的?" name="keywords"/><meta content="jdk的垃圾回收器" name="description"/><meta content="xkj" name="author"/><link href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html" rel="canonical"/><link as="style" crossorigin="anonymous" href="/assets/css/stylesheet.dc6bd2c841ee388e899e13872ae986c0e847e8b957d6714ad6ddc628ef2d17ff.css" integrity="sha256-3GvSyEHuOI6JnhOHKumGwOhH6LlX1nFK1t3GKO8tF/8=" rel="preload stylesheet"/><script crossorigin="anonymous" defer="" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload="hljs.initHighlightingOnLoad()" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js"></script>
<link href="https://xiaokunji.com/img/Q.svg" rel="icon"/><link href="https://xiaokunji.com/img/Q.svg" rel="icon" sizes="16x16" type="image/png"/><link href="https://xiaokunji.com/img/Q.svg" rel="icon" sizes="32x32" type="image/png"/><link href="https://xiaokunji.com/Q.svg" rel="apple-touch-icon"/><link href="https://xiaokunji.com/Q.svg" rel="mask-icon"/><meta content="#2e2e33" name="theme-color"/><meta content="#2e2e33" name="msapplication-TileColor"/><link href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html" hreflang="zh" rel="alternate"/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta content="垃圾回收器" property="og:title"/><meta content="jdk的垃圾回收器" property="og:description"/><meta content="article" property="og:type"/><meta content="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html" property="og:url"/><meta content="java及其框架" property="article:section"/><meta content="2023-08-22T00:00:00+00:00" property="article:published_time"/><meta content="2024-10-25T18:39:13+08:00" property="article:modified_time"/><meta content="summary" name="twitter:card"/><meta content="垃圾回收器" name="twitter:title"/><meta content="jdk的垃圾回收器" name="twitter:description"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"垃圾回收器","item":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html"}]}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"垃圾回收器","name":"垃圾回收器","description":"jdk的垃圾回收器","keywords":[" 查询默认垃圾收集器"," ZGC"," CMS"," CMS存在的问题"," CMS收集器的工作流程(步骤)是什么样的?"],"articleBody":"[TOC]\n查询默认垃圾收集器 java -XX:+PrintCommandLineFlags -version\n结果如下:\n-XX:InitialHeapSize=257798976 -XX:MaxHeapSize=4124783616 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC -XX:+PrintCommandLineFlags java version \"1.8.0_211\" Java(TM) SE Runtime Environment (build 1.8.0_211-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode) 可以看到 jdk1.8 使用的ParallelGC , Parallel 垃圾收集器，即 PS Scavenge(Parallel Scavenge) 和 PS MarkSweep( Parallel Old)。\n注意这里的 + 号，有 +/- 号表示启用/关闭，没有的表示是配置属性。\nJDK8 及以前使用的是Parallel 垃圾收集器，jdk9 到 jdk16使用的都是 G1 收集器。\n虽然推出了 ZGC, 但 可能是由于稳定性考虑没有马上更换\nCMS默认情况下没有用在任何版本的回收器, CMS 使用标记清除算法，如果用作默认确实不怎么合适。\n【Java】JVM - 各版本默认垃圾收集器 - 掘金 (juejin.cn) 【Java】JVM - 垃圾收集器 - 掘金 (juejin.cn) 彻夜研究了2天终于知道 JDK8 默认的GC 收集器了 - 掘金 (juejin.cn) ZGC ZGC 很牛逼，它的目标(特性)是：\n停顿时间不超过 10ms； 停顿时间不会随着堆的大小，或者活跃对象的大小而增加； 支持 8MB~4TB 级别的堆，未来支持 16TB。 与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，\n不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。\nZGC通过染色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移\n应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。\n新一代垃圾回收器ZGC的探索与实践 - 美团技术团队 (meituan.com) 指针染色 一种用于标记对象状态的技术。在一个指针中，除了存储对象的实际地址外，还有额外的位被用来存储关于该对象的元数据信息。这些信息可能包括：\n对象是否被移动了（即它是否在回收过程中被移动到了新的位置）。 对象的存活状态。 对象是否被锁定或有其他特殊状态。 通过在指针中嵌入这些信息，ZGC 在标记和转移阶段会更快，因为通过指针上的颜色就能区分出对象状态，不用额外做内存访问。\n读屏障 当程序尝试读取一个对象时，读屏障会触发以下操作：\n检查指针染色：读屏障首先检查指向对象的指针的颜色信息。\n处理移动的对象：如果指针表示对象已经被移动（例如，在垃圾回收过程中），读屏障将确保返回对象的新位置。\n确保一致性：通过这种方式，ZGC 能够在并发移动对象时保持内存访问的一致性，从而减少对应用程序停顿的需要。\n读屏障也解决了三色标记法中的漏标/错标的问题\n深入理解 JVM 的垃圾收集器：CMS、G1、ZGC | 二哥的Java进阶之路 G1 G1（Garbage First）垃圾回收器不同于其他几款垃圾回收器，其采用独特的内存管理策略，实现对整个堆空间的垃圾回收。\nG1垃圾回收器主要将堆内存划分为多个大小相等的区域（称为Region），各个区域根据需要扮演不同的角色，可以被定义为Eden区、Survivor区、Old区和Humongous区（存放大对象，老年代的一部分），采用复制算法针对每个区域进行垃圾回收，同样也支持动态的调整内存大小。同时各个Region不需要连续的存储，颠覆了以往堆内存结构的连续性，具备强大的灵活性，也进一步提高了内存利用率。\nG1垃圾回收器在设计时，充分结合了Parallel Scavenge和CMS垃圾回收器的优点，解决Parallel Scavenge和CMS存在的问题，G1也称垃圾优先回收器，不会像其它垃圾回收器一样等到空间快满时才会进行回收，而是提前触发回收（少量多次），每次垃圾回收时间短，吞吐量高，\n1. G1垃圾回收模式 在G1垃圾回收器中，主要采用了两种垃圾回收模式：Young GC和Mixed GC\nYoung GC（年轻代回收）：主要针对年轻代区域的垃圾回收，包括Eden区和Survivor区。当所有Eden区使用率达到最大阀值（默认60%）或者G1计算出来的回收时间接近用户设定的最大暂停时间时，会触发一次Young GC，回收Eden区和Survivor区，复制移动到另外的Survivor幸存者（年龄+1）或Old老年代区（提前晋升的） Mixed GC（混合回收）：Mixed GC是G1垃圾回收器独有的，也称混合回收，针对年轻代和部分老年代区域的垃圾回收。当老年代的占有率达到阀值（默认45%）或年轻代被分配大对象时，会触发一次Mixed GC，回收所有年轻代和一部分老年代区（选取的策略是垃圾对象最多的老年代区域，确保释放更多内存空间，即回收价值高的），控制最大暂停时间。\n2. 年轻代回收（Young GC）原理 G1垃圾回收器年轻代回收时，采用了三种关键技术，分别是记忆集、卡表和写屏障。接下来我们层层递进，研究一下这些技术分别解决了什么问题。\n当G1触发Young GC时，只会扫描年轻代区域（Eden区 + Survivor区）的对象，从GC Root根对象出发时，很容易扫描出年轻代的对象以及年轻代对象引用的其它年轻代的对象。\n但这样会产生一个问题，如果年轻代的对象被老年代的对象引用了，应该如何识别出来呢？\n2.1 记忆集（RememberedSet） 其实G1垃圾回收器内部维护了一种引用详情表，称为记忆集的数据结构，记录了非回收区域（老年代）对象引用回收区域（年轻代）对象的关系。\n记忆集仅记录跨代的对象引用关系，不会记录年轻代区域之间的对象引用\n在Young GC回收年轻代对象时，会将记忆集中的对象也加入到GC Root中，避免年轻代的对象被错误的回收\njava基础-记忆集 | 米二 2.2 卡表（Card Table）与卡页（Card Page） 在G1垃圾回收器中，为了进一步压缩记忆集占用的内存，其将所有的Region区域按大小划分为多个分块，称为卡页（Card Page），对每个卡页进行编号\n同时每个Region区域都会有额外配备一小块内存，这块内存称为卡表（Card Table），用于记录整个堆空间中有哪些卡页引用了自己Region区域的对象，卡表的底层数据结构是字节数组，每一个字节对应一个卡页，当某个卡页中的对象引用自己Region区域的对象时，会将卡表对应编号位置的字节修改为1，为1的字节被称之为脏卡\n此时生成记忆集就会比较容易，只用遍历各个Region的卡表，找到所有字节为1的脏卡，形成记忆集。\n当年轻代垃圾回收标记存活对象时，G1将此记忆集中的所有对象也加入到GC Root根对象集合中，确保被老年代引用的年轻代对象标记为存活。\n2.3 写屏障（Write Barrier） 更新卡表状态的底层采用了写屏障技术（具体为写后屏障），当执行对象引用相关的代码时，会在其代码前后插入对应的指令\n写屏障类似与之前学过的AOP，会在引用对象赋值前后做一些额外的动作，主要分为两个：\n写前屏障：引用对象赋值前的特殊处理 写后屏障：引用对象赋值后的特殊处理 JVM中的写屏障要与并发乱序执行中的内存屏障不一样，这里要区分它们\n写后屏障指令判断到老年代对象引用年轻代对象时，会更改卡表中对应的字节为脏卡，同时会将脏卡放入到一个脏卡队列中，JVM会通过单独的线程，定期读取脏卡队列中的数据，更新记忆集\n可能会有小伙伴会产生好奇，在更新完卡表之后，为何不直接把脏卡写入记忆集呢？\n这是由于写屏障指令是由用户线程完成的，如果有大量的用户线程修改对象引用关系，会产生线程安全问题，则需要对记忆集进行加锁，加锁之后势必会影响执行效率。\n因此这里将脏卡先放入脏卡队列，采用单独的线程异步消费，避免影响用户线程\n3、混合回收（Mixed GC）原理 混合回收是针对年轻代和部分老年代区域的垃圾回收，当老年代内存占用率达到设定阈值，或分配大对象时，将会触发混合回收Mixed GC。\n由于Old老年代区往往存在较多对象，G1垃圾回收器为提升执行效率，减少STW，部分耗时较长的阶段采用了与用户线程并发执行，总体分为初始标记、并发标记、最终标记、清理和转移等五个阶段。\n只有并发标记不会暂停用户线程, (即不会出现STW)\n同时为进一步提升处理速度，以及解决并发阶段可能存在的对象引用变化问题，采用三色标记和SATB技术。\n简述各阶段的作用\n初始标记: 标记GCroot下直接关联的对象\n并发标记: 扫描初始标记中对象的关联对象以及关联链条\n最终标记: 处理并发标记的漏标的对象\n清理: 清除无用的对象\n转移: 转移存活对象, 使内存空间变得连续(region之间转移)\n3.1 初始标记阶段 初始标记阶段G1垃圾回收器会暂停用户线程，通过极短的时间仅标记出GC Root根对象直接关联的对象，速度较快。\n使用了三色标记法, 三色指的的黑白灰，简单的说，将所有对象渲染成不同的颜色，便于区分。\n白色（垃圾对象）：白色代表该对象不在GC Root的引用链上，在标记开始时，堆内存中的所有对象默认都是白色，当标记结束，如果对象仍然为白色，则被认为是垃圾对象 灰色（待处理对象）：灰色代表该对象在GC Root的引用链上，但该对象所有引用的对象还未被标记过，是一个过渡颜色，最终会被标记为黑色 黑色（存活对象）：黑色代表该对象在GC Root的引用链上，且该对象所有引用的对象均已被标记过，代表存活对象\nCMS垃圾回收器也使用到了三色标记算法\njava常见面试题 -三色标记法| 米二 3.2 并发标记阶段 并发标记阶段从GC Root直接关联的对象进行完整遍历，标记出所有存活的对象，耗时较长，但本阶段与用户线程可同时并发执行，不会暂停用户线程。\n在本阶段G1垃圾回收器会从灰色队列中获取到未标记完成的灰色对象，标记其引用关联的所有下一级对象（结束后自身会被标记为黑色），将其引用的下一级对象标记为灰色，放入灰色队列，重复这一过程，直到队列为空\n但是，并发标记阶段由于用户线程并没有暂停，会产生新问题，即用户线程若在此期间修改了对象的引用关系，就会导致标记结果不准确，这里其实会误判两种情况：多标和漏标\n多标：即本应该被回收的垃圾对象，却被标记为黑色存活对象。当已被标记的黑色对象或灰色对象，其引用被删除，就会造成多标\n漏标：即本应该被标记为黑色的存活对象，却没有被正常标记为黑色，被垃圾回收。当未处理完的灰色对象断开了它引用的白色对象，且已处理完的黑色对象重新引用了该白色对象，则该白色对象会被漏标\n多标的问题其实并不严重，顶多产生浮动垃圾，等到下一次垃圾回收时也会被回收，但漏标却是很致命的，已经影响到了程序的正常运行，而G1垃圾回收器采用了SATB原始快照技术解决了这一漏标问题\n1）SATB（Snapshot At The Beginning） SATB主要为解决并发标记阶段可能产生的对象引用变化问题，SATB即一个原始快照，类似于拍照一样，记录某一时刻所有的对象，\n可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。\n3.3 最终标记阶段 最终标记阶段会暂停用户线程，主要用于修正并发标记期间产生变动的对象，总体耗时短于并发标记阶段。\n最终标记阶段首先会暂停用户线程，将所有线程的SATB队列合并到全局SATB队列，逐一消费。\n在全局SATB队列中的对象，默认按照黑色存活对象处理，同时处理它们引用的其它对象。\n缺点：显而易见，SATB也会造成多标的情况，将可以被回收的垃圾对象标记为存活对象，产生了浮动垃圾，这些浮动垃圾需要等到下一轮垃圾回收时被回收。\n3.4 清理阶段 清理阶段也会暂停用户线程，在最终标记阶段完成之后，G1垃圾回收器会整理Region区域，调整对应的记忆集，若识别到某个Region不存在任何存活对象时，会直接清理掉该Region，释放内存\n3.5 转移阶段 转移阶段同样也会暂停用户线程，需要将某一个Region区域存活的对象复制到另一个Region，主要包括以下步骤：\n区域选择：G1垃圾回收器会针对各个Region的回收价值进行排序，评估最大暂停时间，选择特定的Region进行回收（一般是垃圾对象最多的区域）\n对象复制转移：选定好Region后，首先会将GC Root根对象直接关联的对象转移到新的Region区域，然后依次转移其引用的对象\n更新引用关系：对象转移到新的Region区域后，会清理到之前的Region。若其它Region区域中的对象引用了转移后的对象，则会重新设置它们的引用关系，避免对象移动位置后引用出错\n深入JVM：详解G1垃圾回收器原理-CSDN博客 CMS CMS存在的问题 使用的标记-清除算法，可能存在大量空间碎片。 并发清理, 内存不够会出现Concurrent Mode Failure失败而导致垃圾收集器降级为Serial Old, 产生STW 对CPU资源非常敏感。在并发阶段，会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4 CMS收集器的工作流程(步骤)是什么样的? 初始标记: 只标记和GC Roots能直连的对象,速度快,会发生(stop the world) 并发标记: 和应用线程并发执行,遍历初始标记阶段标记过的对象,标记这些对象的可达对象。 重新标记: 由于并发标记是和应用线程是并发执行的,所以有些标记过的对象发生了变化。这个过程比初始标记用时长,但是比并发标记阶段用时短。会发生(stop the world) 并发清除: 和应用线程一起运行。基于标记对象,直接清理对象。 总结CMS常见面试题_入门小站的博客-CSDN博客_cms面试题 关于CMS收集器的问题？ - 知乎 (zhihu.com) JVM 面试必问的 CMS，你懂了吗？_web13618542420的博客-CSDN博客 ","wordCount":"5380","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2024-10-25T18:39:13+08:00","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class="dark" id="top"><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class="header"><nav class="nav"><div class="logo"><a accesskey="h" href="https://xiaokunji.com/zh/" title="米二 (Alt + H)"><img alt="" aria-label="logo" height="35" src="https://xiaokunji.com/img/Q.svg"/>米二</a><div class="logo-switches"><button accesskey="t" id="theme-toggle" title="(Alt + T)"><svg fill="none" height="18" id="moon" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg><svg fill="none" height="18" id="sun" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="5"></circle><line x1="12" x2="12" y1="1" y2="3"></line><line x1="12" x2="12" y1="21" y2="23"></line><line x1="4.22" x2="5.64" y1="4.22" y2="5.64"></line><line x1="18.36" x2="19.78" y1="18.36" y2="19.78"></line><line x1="1" x2="3" y1="12" y2="12"></line><line x1="21" x2="23" y1="12" y2="12"></line><line x1="4.22" x2="5.64" y1="19.78" y2="18.36"></line><line x1="18.36" x2="19.78" y1="5.64" y2="4.22"></line></svg></button><ul class="lang-switch"><li>|</li><li><a aria-label="English" href="https://xiaokunji.com/en/" title="English">English</a></li></ul></div></div><ul id="menu"><li><a href="https://xiaokunji.com/zh/" title="🏠主页"><span>🏠主页</span></a></li><li><a accesskey="/" href="https://xiaokunji.com/zh/search" title="🔍搜索 (Alt + /)"><span>🔍搜索</span></a></li><li><a href="https://xiaokunji.com/zh/post.html" title="📚文章"><span>📚文章</span></a></li><li><a href="https://xiaokunji.com/zh/archives.html" title="⏱时间轴"><span>⏱时间轴</span></a></li><li><a href="https://xiaokunji.com/zh/tags.html" title="🔖标签"><span>🔖标签</span></a></li><li><a href="https://xiaokunji.com/zh/categories.html" title="📖分类"><span>📖分类</span></a></li><li><a href="https://xiaokunji.com/zh/links.html" title="🤝友链"><span>🤝友链</span></a></li></ul></nav></header><main class="main"><article class="post-single"><header class="post-header"><nav aria-label="breadcrumb"><ul><a href="https://xiaokunji.com/zh/">🏠</a> <span>&gt;</span>
<a href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html">java及其框架</a> <span>&gt;</span>
<a href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80.html">java基础</a> <span>&gt;</span>
<a href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM.html">jvm</a> <span>&gt;</span></ul></nav><h1 class="post-title">垃圾回收器</h1><div class="post-description">jdk的垃圾回收器</div><div class="post-meta">创建: <span title="2023-08-22 00:00:00 +0000 UTC">2023-08-22</span> · 更新: 2024-10-25 · xkj
 | 分类:  <ul class="post-categories-meta" style="display:inline"><a href="https://xiaokunji.com/zh/categories/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html">java及其框架</a></ul><span id="busuanzi_container_page_pv"> | 访问: <span id="busuanzi_value_page_pv">1</span></span></div></header><aside class="toc-container wide" id="toc-container"><div class="toc"><details open=""><summary accesskey="c" title="(Alt + C)"><span class="details">目录</span></summary><div class="inner"><ul><li><a aria-label="查询默认垃圾收集器" href="#%e6%9f%a5%e8%af%a2%e9%bb%98%e8%ae%a4%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8">查询默认垃圾收集器</a></li><li><a aria-label="ZGC" href="#zgc">ZGC</a><ul><ul><li><a aria-label="指针染色" href="#%e6%8c%87%e9%92%88%e6%9f%93%e8%89%b2">指针染色</a></li><li><a aria-label="读屏障" href="#%e8%af%bb%e5%b1%8f%e9%9a%9c">读屏障</a></li></ul></ul></li><li><a aria-label="G1" href="#g1">G1</a><ul><li><a aria-label="1. G1垃圾回收模式" href="#1-g1%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%a8%a1%e5%bc%8f">1. G1垃圾回收模式</a></li><li><a aria-label="2. 年轻代回收（Young GC）原理" href="#2-%e5%b9%b4%e8%bd%bb%e4%bb%a3%e5%9b%9e%e6%94%b6young-gc%e5%8e%9f%e7%90%86">2. 年轻代回收（Young GC）原理</a><ul><li><a aria-label="2.1 记忆集（RememberedSet）" href="#21-%e8%ae%b0%e5%bf%86%e9%9b%86rememberedset">2.1 记忆集（RememberedSet）</a></li><li><a aria-label="2.2 卡表（Card Table）与卡页（Card Page）" href="#22-%e5%8d%a1%e8%a1%a8card-table%e4%b8%8e%e5%8d%a1%e9%a1%b5card-page">2.2 卡表（Card Table）与卡页（Card Page）</a></li><li><a aria-label="2.3 写屏障（Write Barrier）" href="#23-%e5%86%99%e5%b1%8f%e9%9a%9cwrite-barrier">2.3 写屏障（Write Barrier）</a></li></ul></li><li><a aria-label="3、混合回收（Mixed GC）原理" href="#3%e6%b7%b7%e5%90%88%e5%9b%9e%e6%94%b6mixed-gc%e5%8e%9f%e7%90%86">3、混合回收（Mixed GC）原理</a><ul><ul><ul><li><a aria-label="3.1 初始标记阶段" href="#31-%e5%88%9d%e5%a7%8b%e6%a0%87%e8%ae%b0%e9%98%b6%e6%ae%b5">3.1 初始标记阶段</a></li></ul></ul><li><a aria-label="3.2 并发标记阶段" href="#32-%e5%b9%b6%e5%8f%91%e6%a0%87%e8%ae%b0%e9%98%b6%e6%ae%b5">3.2 并发标记阶段</a><ul><ul><ul><li><a aria-label="1）SATB（Snapshot At The Beginning）" href="#1satbsnapshot-at-the-beginning">1）SATB（Snapshot At The Beginning）</a></li></ul></ul></ul></li><li><a aria-label="3.3 最终标记阶段" href="#33-%e6%9c%80%e7%bb%88%e6%a0%87%e8%ae%b0%e9%98%b6%e6%ae%b5">3.3 最终标记阶段</a></li><li><a aria-label="3.4 清理阶段" href="#34-%e6%b8%85%e7%90%86%e9%98%b6%e6%ae%b5">3.4 清理阶段</a></li><li><a aria-label="3.5 转移阶段" href="#35-%e8%bd%ac%e7%a7%bb%e9%98%b6%e6%ae%b5">3.5 转移阶段</a></li></ul></li></ul></li><li><a aria-label="CMS" href="#cms">CMS</a><ul><li><a aria-label="CMS存在的问题" href="#cms%e5%ad%98%e5%9c%a8%e7%9a%84%e9%97%ae%e9%a2%98">CMS存在的问题</a></li><li><a aria-label="CMS收集器的工作流程(步骤)是什么样的?" href="#cms%e6%94%b6%e9%9b%86%e5%99%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b%e6%ad%a5%e9%aa%a4%e6%98%af%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84">CMS收集器的工作流程(步骤)是什么样的?</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class="post-content"><p>[TOC]</p><h1 id="查询默认垃圾收集器">查询默认垃圾收集器<a aria-hidden="true" class="anchor" hidden="" href="#查询默认垃圾收集器">#</a></h1><p><code>java -XX:+PrintCommandLineFlags -version</code></p><p>结果如下:</p><div class="highlight"><pre style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-cmd" data-lang="cmd"><span style="display:flex"><span>-XX:InitialHeapSize=257798976 
</span></span><span style="display:flex"><span>-XX:MaxHeapSize=4124783616
</span></span><span style="display:flex"><span>-XX:+UseCompressedClassPointers 
</span></span><span style="display:flex"><span>-XX:+UseCompressedOops 
</span></span><span style="display:flex"><span>-XX:-UseLargePagesIndividualAllocation 
</span></span><span style="display:flex"><span>-XX:+UseParallelGC
</span></span><span style="display:flex"><span>-XX:+PrintCommandLineFlags
</span></span><span style="display:flex"><span>java version <span style="color:#a5d6ff">"1.8.0_211"</span>
</span></span><span style="display:flex"><span>Java(TM) SE Runtime Environment (build 1.8.0_211-b12)
</span></span><span style="display:flex"><span>Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)
</span></span></code></pre></div><p>可以看到 jdk1.8 使用的<code>ParallelGC</code> , Parallel 垃圾收集器，即 PS Scavenge(Parallel Scavenge) 和 PS MarkSweep( Parallel Old)。</p><blockquote><p>注意这里的 <code>+</code> 号，有 <code>+/- </code>号表示启用/关闭，没有的表示是配置属性。</p></blockquote><p><strong>JDK8 及以前使用的是Parallel 垃圾收集器，jdk9 到 jdk16使用的都是 G1 收集器。</strong></p><blockquote><p>虽然推出了 ZGC, 但 可能是由于稳定性考虑没有马上更换</p><p><strong>CMS默认情况下没有用在任何版本的回收器</strong>, CMS 使用标记清除算法，如果用作默认确实不怎么合适。</p></blockquote><p><a href="https://juejin.cn/post/7001406102621388831#heading-17" rel="noopener" target="_blank">【Java】JVM - 各版本默认垃圾收集器 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6993308706410594311" rel="noopener" target="_blank">【Java】JVM - 垃圾收集器 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6850418109662052365" rel="noopener" target="_blank">彻夜研究了2天终于知道 JDK8 默认的GC 收集器了 - 掘金 (juejin.cn)</a></p><h1 id="zgc">ZGC<a aria-hidden="true" class="anchor" hidden="" href="#zgc">#</a></h1><p>ZGC 很牛逼，它的目标(特性)是：</p><ul><li>停顿时间不超过 10ms；</li><li>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</li><li>支持 8MB~4TB 级别的堆，未来支持 16TB。</li></ul><p>与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，</p><p>不过ZGC对该算法做了重大改进：<strong>ZGC在标记、转移和重定位阶段几乎都是并发的</strong>，这是ZGC实现停顿时间小于10ms目标的最关键原因。</p><p>ZGC通过<strong>染色指针和读屏障技术</strong>，解决了转移过程中准确访问对象的问题，实现了并发转移</p><p><strong>应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。</strong></p><p><a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html" rel="noopener" target="_blank">新一代垃圾回收器ZGC的探索与实践 - 美团技术团队 (meituan.com)</a></p><h3 id="指针染色">指针染色<a aria-hidden="true" class="anchor" hidden="" href="#指针染色">#</a></h3><p>一种用于标记对象状态的技术。在一个指针中，除了存储对象的实际地址外，还有额外的位被用来存储关于该对象的元数据信息。这些信息可能包括：</p><ul><li>对象是否被移动了（即它是否在回收过程中被移动到了新的位置）。</li><li>对象的存活状态。</li><li>对象是否被锁定或有其他特殊状态。</li></ul><p>通过在指针中嵌入这些信息，ZGC 在标记和转移阶段会更快，因为通过指针上的颜色就能区分出对象状态，不用额外做内存访问。</p><h3 id="读屏障">读屏障<a aria-hidden="true" class="anchor" hidden="" href="#读屏障">#</a></h3><p>当程序尝试读取一个对象时，读屏障会触发以下操作：</p><ul><li><p>检查指针染色：读屏障首先检查指向对象的指针的颜色信息。</p></li><li><p>处理移动的对象：如果指针表示对象已经被移动（例如，在垃圾回收过程中），读屏障将确保返回对象的新位置。</p></li><li><p>确保一致性：通过这种方式，ZGC 能够在并发移动对象时保持内存访问的一致性，从而减少对应用程序停顿的需要。</p><blockquote><p>读屏障也解决了三色标记法中的漏标/错标的问题</p></blockquote></li></ul><p><a href="https://javabetter.cn/jvm/gc-collector.html#zgc" rel="noopener" target="_blank">深入理解 JVM 的垃圾收集器：CMS、G1、ZGC | 二哥的Java进阶之路</a></p><h1 id="g1">G1<a aria-hidden="true" class="anchor" hidden="" href="#g1">#</a></h1><p>G1（Garbage First）垃圾回收器不同于其他几款垃圾回收器，其采用独特的内存管理策略，实现对整个堆空间的垃圾回收。</p><p>G1垃圾回收器主要将堆内存划分为多个大小相等的区域（称为Region），各个区域根据需要扮演不同的角色，可以被定义为Eden区、Survivor区、Old区和Humongous区（存放大对象，老年代的一部分），采用复制算法针对每个区域进行垃圾回收，同样也支持动态的调整内存大小。同时各个Region不需要连续的存储，颠覆了以往堆内存结构的连续性，具备强大的灵活性，也进一步提高了内存利用率。</p><p>G1垃圾回收器在设计时，充分结合了Parallel Scavenge和CMS垃圾回收器的优点，解决Parallel Scavenge和CMS存在的问题，<strong>G1也称垃圾优先回收器，不会像其它垃圾回收器一样等到空间快满时才会进行回收，而是提前触发回收（少量多次）</strong>，每次垃圾回收时间短，吞吐量高，</p><h2 id="1-g1垃圾回收模式">1. G1垃圾回收模式<a aria-hidden="true" class="anchor" hidden="" href="#1-g1垃圾回收模式">#</a></h2><p>在G1垃圾回收器中，主要采用了两种垃圾回收模式：<strong>Young GC和Mixed GC</strong></p><p><strong>Young GC（年轻代回收）</strong>：主要<strong>针对年轻代区域</strong>的垃圾回收，包括Eden区和Survivor区。当所有Eden区使用率达到最大阀值（默认60%）或者G1计算出来的回收时间接近用户设定的最大暂停时间时，会触发一次Young GC，回收Eden区和Survivor区，复制移动到另外的Survivor幸存者（年龄+1）或Old老年代区（提前晋升的）
<strong>Mixed GC（混合回收）</strong>：Mixed GC是G1垃圾回收器独有的，也称混合回收，<strong>针对年轻代和部分老年代区域</strong>的垃圾回收。当老年代的占有率达到阀值（默认45%）或年轻代被分配大对象时，会触发一次Mixed GC，回收所有年轻代和一部分老年代区（选取的策略是垃圾对象最多的老年代区域，确保释放更多内存空间，即回收价值高的），控制最大暂停时间。</p><h2 id="2-年轻代回收young-gc原理">2. 年轻代回收（Young GC）原理<a aria-hidden="true" class="anchor" hidden="" href="#2-年轻代回收young-gc原理">#</a></h2><p>G1垃圾回收器年轻代回收时，采用了三种关键技术，分别是<strong>记忆集、卡表和写屏障</strong>。接下来我们层层递进，研究一下这些技术分别解决了什么问题。</p><p>当G1触发Young GC时，只会扫描年轻代区域（Eden区 + Survivor区）的对象，从GC Root根对象出发时，很容易扫描出年轻代的对象以及年轻代对象引用的其它年轻代的对象。</p><p>但这样会产生一个问题，如果年轻代的对象被老年代的对象引用了，应该如何识别出来呢？</p><h3 id="21-记忆集rememberedset">2.1 记忆集（RememberedSet）<a aria-hidden="true" class="anchor" hidden="" href="#21-记忆集rememberedset">#</a></h3><p>其实G1垃圾回收器内部维护了一种引用详情表，称为记忆集的数据结构，记录了非回收区域（老年代）对象引用回收区域（年轻代）对象的关系。</p><blockquote><p>记忆集仅记录跨代的对象引用关系，不会记录年轻代区域之间的对象引用</p></blockquote><p>在Young GC回收年轻代对象时，会将记忆集中的对象也加入到GC Root中，避免年轻代的对象被错误的回收</p><p><a href="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java/java%E5%9F%BA%E7%A1%80.html#4-jvm%e4%b8%ad%e7%9a%84%e8%ae%b0%e5%bf%86%e9%9b%86remembered-set%e6%98%af%e4%bb%80%e4%b9%88" rel="noopener" target="_blank">java基础-记忆集 | 米二</a></p><h3 id="22-卡表card-table与卡页card-page">2.2 卡表（Card Table）与卡页（Card Page）<a aria-hidden="true" class="anchor" hidden="" href="#22-卡表card-table与卡页card-page">#</a></h3><p>在G1垃圾回收器中，为了进一步压缩记忆集占用的内存，其将所有的Region区域按大小划分为多个分块，称为卡页（Card Page），对每个卡页进行编号</p><p><img alt="" loading="lazy" src="%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8.assets/2024-10-25-18-08-12-image.png"/></p><p>同时每个Region区域都会有额外配备一小块内存，这块内存称为卡表（Card Table），用于记录整个堆空间中有哪些卡页引用了自己Region区域的对象，卡表的底层数据结构是字节数组，每一个字节对应一个卡页，当某个卡页中的对象引用自己Region区域的对象时，会将卡表对应编号位置的字节修改为1，为1的字节被称之为脏卡</p><p><img alt="" loading="lazy" src="%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8.assets/2024-10-25-18-08-19-image.png"/></p><p>此时生成记忆集就会比较容易，只用遍历各个Region的卡表，找到所有字节为1的脏卡，形成记忆集。</p><p>当年轻代垃圾回收标记存活对象时，G1将此记忆集中的所有对象也加入到GC Root根对象集合中，确保被老年代引用的年轻代对象标记为存活。</p><h3 id="23-写屏障write-barrier">2.3 写屏障（Write Barrier）<a aria-hidden="true" class="anchor" hidden="" href="#23-写屏障write-barrier">#</a></h3><p>更新卡表状态的底层采用了写屏障技术（具体为写后屏障），当执行对象引用相关的代码时，会在其代码前后插入对应的指令</p><blockquote><p>写屏障类似与之前学过的AOP，会在引用对象赋值前后做一些额外的动作，主要分为两个：</p><p>写前屏障：引用对象赋值前的特殊处理
写后屏障：引用对象赋值后的特殊处理
JVM中的写屏障要与并发乱序执行中的内存屏障不一样，这里要区分它们</p></blockquote><p>写后屏障指令判断到老年代对象引用年轻代对象时，会更改卡表中对应的字节为脏卡，同时会将脏卡放入到一个<strong>脏卡队列中，JVM会通过单独的线程，定期读取脏卡队列中的数据，更新记忆集</strong></p><p><img alt="" loading="lazy" src="%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8.assets/2024-10-25-18-09-04-image.png"/></p><blockquote><p>可能会有小伙伴会产生好奇，在更新完卡表之后，为何不直接把脏卡写入记忆集呢？</p><p>这是由于写屏障指令是由用户线程完成的，如果有大量的用户线程修改对象引用关系，会产生线程安全问题，则需要对记忆集进行加锁，加锁之后势必会影响执行效率。</p><p>因此这里将脏卡先放入脏卡队列，采用单独的线程异步消费，避免影响用户线程</p></blockquote><h2 id="3混合回收mixed-gc原理">3、混合回收（Mixed GC）原理<a aria-hidden="true" class="anchor" hidden="" href="#3混合回收mixed-gc原理">#</a></h2><p>混合回收是针对年轻代和部分老年代区域的垃圾回收，<strong>当老年代内存占用率达到设定阈值，或分配大对象时，将会触发混合回收Mixed GC</strong>。</p><p>由于Old老年代区往往存在较多对象，G1垃圾回收器为提升执行效率，减少STW，部分耗时较长的阶段采用了与用户线程并发执行，总体分为<strong>初始标记、并发标记、最终标记、清理和转移等五个阶段</strong>。</p><blockquote><p>只有并发标记不会暂停用户线程, (即不会出现STW)</p></blockquote><p>同时为进一步提升处理速度，以及解决并发阶段可能存在的对象引用变化问题，采用<strong>三色标记和SATB技术</strong>。</p><blockquote><p>简述各阶段的作用</p><ol><li><p>初始标记: 标记GCroot下直接关联的对象</p></li><li><p>并发标记: 扫描初始标记中对象的关联对象以及关联链条</p></li><li><p>最终标记: 处理并发标记的漏标的对象</p></li><li><p>清理: 清除无用的对象</p></li><li><p>转移: 转移存活对象, 使内存空间变得连续(region之间转移)</p></li></ol></blockquote><h5 id="31-初始标记阶段">3.1 初始标记阶段<a aria-hidden="true" class="anchor" hidden="" href="#31-初始标记阶段">#</a></h5><p>初始标记阶段G1垃圾回收器<strong>会暂停用户线程</strong>，通过极短的时间<strong>仅标记出<code>GC Root</code>根对象直接关联的对象</strong>，速度较快。</p><p>使用了三色标记法, 三色指的的黑白灰，简单的说，将所有对象渲染成不同的颜色，便于区分。</p><p><strong>白色（垃圾对象）</strong>：白色代表该对象不在GC Root的引用链上，在标记开始时，堆内存中的所有对象默认都是白色，当标记结束，如果对象仍然为白色，则被认为是垃圾对象
<strong>灰色（待处理对象）</strong>：灰色代表该对象在GC Root的引用链上，但该对象所有引用的对象还未被标记过，是一个过渡颜色，最终会被标记为黑色
<strong>黑色（存活对象）</strong>：黑色代表该对象在GC Root的引用链上，且该对象所有引用的对象均已被标记过，代表存活对象</p><blockquote><p>CMS垃圾回收器也使用到了三色标记算法</p></blockquote><p><a href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95.html#26-%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95" rel="noopener" target="_blank">java常见面试题 -三色标记法| 米二</a></p><h3 id="32-并发标记阶段">3.2 并发标记阶段<a aria-hidden="true" class="anchor" hidden="" href="#32-并发标记阶段">#</a></h3><p>并发标记阶段从GC Root直接关联的对象进行完整遍历，标记出所有存活的对象，耗时较长，但本阶段与用户线程可同时并发执行，不会暂停用户线程。</p><p>在本阶段G1垃圾回收器会从灰色队列中获取到未标记完成的灰色对象，标记其引用关联的所有下一级对象（结束后自身会被标记为黑色），将其引用的下一级对象标记为灰色，放入灰色队列，重复这一过程，直到队列为空</p><p>但是，并发标记阶段由于用户线程并没有暂停，会产生新问题，即用户线程若在此期间修改了对象的引用关系，就会导致标记结果不准确，这里其实会误判两种情况：多标和漏标</p><ul><li><p>多标：即本应该被回收的垃圾对象，却被标记为黑色存活对象。当已被标记的黑色对象或灰色对象，其引用被删除，就会造成多标</p></li><li><p>漏标：即本应该被标记为黑色的存活对象，却没有被正常标记为黑色，被垃圾回收。当未处理完的灰色对象断开了它引用的白色对象，且已处理完的黑色对象重新引用了该白色对象，则该白色对象会被漏标</p></li></ul><p>多标的问题其实并不严重，顶多产生浮动垃圾，等到下一次垃圾回收时也会被回收，但漏标却是很致命的，已经影响到了程序的正常运行，而G1垃圾回收器采用了SATB原始快照技术解决了这一漏标问题</p><h6 id="1satbsnapshot-at-the-beginning">1）SATB（Snapshot At The Beginning）<a aria-hidden="true" class="anchor" hidden="" href="#1satbsnapshot-at-the-beginning">#</a></h6><p><strong>SATB主要为解决并发标记阶段可能产生的对象引用变化问题</strong>，SATB即一个原始快照，类似于拍照一样，记录某一时刻所有的对象，</p><blockquote><p>可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p></blockquote><h3 id="33-最终标记阶段">3.3 最终标记阶段<a aria-hidden="true" class="anchor" hidden="" href="#33-最终标记阶段">#</a></h3><p>最终标记阶段<strong>会暂停用户线程</strong>，主要用于修正并发标记期间产生变动的对象，总体耗时短于并发标记阶段。</p><p>最终标记阶段首先会暂停用户线程，将所有线程的SATB队列合并到全局SATB队列，逐一消费。</p><p>在全局SATB队列中的对象，默认按照黑色存活对象处理，同时处理它们引用的其它对象。</p><p><strong>缺点</strong>：显而易见，SATB也会造成多标的情况，将可以被回收的垃圾对象标记为存活对象，产生了浮动垃圾，这些浮动垃圾需要等到下一轮垃圾回收时被回收。</p><h3 id="34-清理阶段">3.4 清理阶段<a aria-hidden="true" class="anchor" hidden="" href="#34-清理阶段">#</a></h3><p>清理阶段也<strong>会暂停用户线程</strong>，在最终标记阶段完成之后，G1垃圾回收器会整理Region区域，调整对应的记忆集，若识别到某个Region不存在任何存活对象时，会直接清理掉该Region，释放内存</p><h3 id="35-转移阶段">3.5 转移阶段<a aria-hidden="true" class="anchor" hidden="" href="#35-转移阶段">#</a></h3><p>转移阶段同样也<strong>会暂停用户线程</strong>，需要将某一个Region区域存活的对象复制到另一个Region，主要包括以下步骤：</p><ol><li><p>区域选择：G1垃圾回收器会针对各个Region的回收价值进行排序，评估最大暂停时间，选择特定的Region进行回收（一般是垃圾对象最多的区域）</p></li><li><p>对象复制转移：选定好Region后，首先会将GC Root根对象直接关联的对象转移到新的Region区域，然后依次转移其引用的对象</p></li><li><p>更新引用关系：对象转移到新的Region区域后，会清理到之前的Region。若其它Region区域中的对象引用了转移后的对象，则会重新设置它们的引用关系，避免对象移动位置后引用出错</p></li></ol><p><a href="https://blog.csdn.net/mm1274889792/article/details/139030273" rel="noopener" target="_blank">深入JVM：详解G1垃圾回收器原理-CSDN博客</a></p><h1 id="cms">CMS<a aria-hidden="true" class="anchor" hidden="" href="#cms">#</a></h1><h2 id="cms存在的问题">CMS存在的问题<a aria-hidden="true" class="anchor" hidden="" href="#cms存在的问题">#</a></h2><ol><li>使用的标记-清除算法，可能存在大量空间碎片。</li><li>并发清理, 内存不够会出现<code>Concurrent Mode Failure</code>失败而导致垃圾收集器降级为Serial Old, 产生STW</li><li>对CPU资源非常敏感。在并发阶段，会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4</li></ol><h2 id="cms收集器的工作流程步骤是什么样的">CMS收集器的工作流程(步骤)是什么样的?<a aria-hidden="true" class="anchor" hidden="" href="#cms收集器的工作流程步骤是什么样的">#</a></h2><ol><li><strong>初始标记</strong>: 只标记和GC Roots能直连的对象,速度快,会发生(stop the world)</li><li><strong>并发标记</strong>: 和应用线程并发执行,遍历初始标记阶段标记过的对象,标记这些对象的可达对象。</li><li><strong>重新标记</strong>: 由于并发标记是和应用线程是并发执行的,所以有些标记过的对象发生了变化。这个过程比初始标记用时长,但是比并发标记阶段用时短。会发生(stop the world)</li><li><strong>并发清除</strong>: 和应用线程一起运行。基于标记对象,直接清理对象。</li></ol><p><a href="https://blog.csdn.net/weixin_37335761/article/details/110881797" rel="noopener" target="_blank">总结CMS常见面试题_入门小站的博客-CSDN博客_cms面试题</a></p><p><a href="https://www.zhihu.com/question/410337357" rel="noopener" target="_blank">关于CMS收集器的问题？ - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/web13618542420/article/details/126743417" rel="noopener" target="_blank">JVM 面试必问的 CMS，你懂了吗？_web13618542420的博客-CSDN博客</a></p></div><footer class="post-footer"><ul class="post-tags"><li><a href="https://xiaokunji.com/zh/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html">垃圾回收</a></li><li><a href="https://xiaokunji.com/zh/tags/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html">java及其框架</a></li></ul><nav class="paginav"><a class="prev" href="https://xiaokunji.com/zh/hadoop%E7%94%9F%E6%80%81%E5%9C%88/Flume/%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8E%9F%E7%90%86.html"><span class="title">« 上一页</span><br/><span>介绍与原理</span></a>
<a class="next" href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html"><span class="title">下一页 »</span><br/><span>类加载机制</span></a></nav></footer></article></main><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><footer class="footer"><span>Copyright
©
-2024
<a href="https://xiaokunji.com/zh/" style="color:#939393">米二</a>
All Rights Reserved</span>
<span id="busuanzi_container"><span class="fa fa-user">用户数:</span><span id="busuanzi_value_site_uv"></span>
<span class="fa fa-eye">访问数:</span><span id="busuanzi_value_site_pv"></span></span></footer><a accesskey="g" aria-label="go to top" class="top-link" href="#top" id="top-link" title="Go to Top (Alt + G)"><svg fill="currentcolor" viewbox="0 0 12 6" xmlns="http://www.w3.org/2000/svg"><path d="M12 6H0l6-6z"></path></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>