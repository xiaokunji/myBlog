<!DOCTYPE html>
<html dir="auto" lang="zh"><head><meta charset="utf-8"/><meta content="IE=edge" http-equiv="x-ua-compatible"/><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name="viewport"/><meta content="index, follow" name="robots"/><title>ForkJoin | 米二</title><meta content=" 前言, 1. 工作窃取算法, 2. 源码解释, 2.1 ForkJoinTask, 2.2 ForkJoinWorkerThread, 2.3 ForkJoinPool, 2.4 WorkQueue, 2.5 runState, 总结" name="keywords"/><meta content=" java 的forkjoin" name="description"/><meta content="xkj" name="author"/><link href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/fork_join.html" rel="canonical"/><link as="style" crossorigin="anonymous" href="/assets/css/stylesheet.4854cfba8bbd19d516e66f000ebd4a04b6abc27ae655bf07762207e2dfbf60ea.css" integrity="sha256-SFTPuou9GdUW5m8ADr1KBLarwnrmVb8HdiIH4t+/YOo=" rel="preload stylesheet"/><script crossorigin="anonymous" defer="" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload="hljs.initHighlightingOnLoad()" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js"></script>
<link href="https://xiaokunji.com/img/Q.svg" rel="icon"/><link href="https://xiaokunji.com/img/Q.svg" rel="icon" sizes="16x16" type="image/png"/><link href="https://xiaokunji.com/img/Q.svg" rel="icon" sizes="32x32" type="image/png"/><link href="https://xiaokunji.com/Q.svg" rel="apple-touch-icon"/><link href="https://xiaokunji.com/Q.svg" rel="mask-icon"/><meta content="#2e2e33" name="theme-color"/><meta content="#2e2e33" name="msapplication-TileColor"/><link href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/fork_join.html" hreflang="zh" rel="alternate"/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta content="ForkJoin" property="og:title"/><meta content=" java 的forkjoin" property="og:description"/><meta content="article" property="og:type"/><meta content="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/fork_join.html" property="og:url"/><meta content="java及其框架" property="article:section"/><meta content="2023-08-22T00:00:00+00:00" property="article:published_time"/><meta content="2023-08-31T00:23:09+08:00" property="article:modified_time"/><meta content="summary" name="twitter:card"/><meta content="ForkJoin" name="twitter:title"/><meta content=" java 的forkjoin" name="twitter:description"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"ForkJoin","item":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/fork_join.html"}]}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"ForkJoin","name":"ForkJoin","description":" java 的forkjoin","keywords":[" 前言"," 1. 工作窃取算法"," 2. 源码解释"," 2.1 ForkJoinTask"," 2.2 ForkJoinWorkerThread"," 2.3 ForkJoinPool"," 2.4 WorkQueue"," 2.5 runState"," 总结"],"articleBody":"[toc]\n前言 它通过 「 分而治之 」 的方法尝试将所有可用的处理器内核使用起来帮助加速并行处理。\n在实际使用过程中，这种 「 分而治之 」的方法意味着框架首先要 fork ，递归地将任务分解为较小的独立子任务，直到它们足够简单以便异步执行。然后，join 部分开始工作，将所有子任务的结果递归地连接成单个结果，或者在返回 void 的任务的情况下，程序只是等待每个子任务执行完毕。\nFork/Join框架是一个实现了ExecutorService接口的多线程处理器，它专为那些可以通过递归分解成更细小的任务而设计，最大化的利用多核处理器来提高应用程序的性能。\n与其他ExecutorService相关的实现相同的是，Fork/Join框架会将任务分配给线程池中的线程。而与之不同的是，Fork/Join框架在执行任务时使用了工作窃取算法。\nForkJoin 有两大核心思想：\n分治算法； 工作密取：为了充分利用 cpu 资源，一个工作线程执行完自己队列的任务之后，不会空闲，而是从其它队列里寻找任务。 使用场景:\nForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。\nForkJoinPool 主要用于实现“分而治之”的算法，特别是分治之后递归调用的函数，例如 quick sort 等。\nForkJoinPool 最适合的是计算密集型的任务，如果存在 I/O，线程间同步，sleep() 等会造成线程长时间阻塞的情况时，最好配合使用 ManagedBlocker。\nManagedBlocker 它可以控制在阻塞时增加并行数, 这样就不会卡死了\n18 Fork/Join框架 · 深入浅出Java多线程 (redspider.group) 一文秒懂 Java Fork/Join - Java 一文秒懂 - 简单教程，简单编程 (twle.cn) 在Java8 parallelStream()中使用I/O + ManagedBlocker有什么问题吗? - IT宝库 (itbaoku.cn) 关于ForkJoinPool使用ManagedBlocker防线程阻塞而降低吞吐量的说明_heng_zou的博客-CSDN博客_forkjoin 阻塞 ManagedBlocker的使用和深入理解ForkJoin 有待提升\n1. 工作窃取算法 工作窃取算法指的是在多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。\n工作窃取流程如下图所示：\n值得注意的是，当一个线程窃取另一个线程的时候，为了减少两个任务线程之间的竞争，我们通常使用双端队列来存储任务。被窃取的任务线程都从双端队列的头部拿任务执行，而窃取其他任务的线程从双端队列的尾部执行任务。\n另外，当一个线程在窃取任务时要是没有其他可用的任务了，这个线程会进入阻塞状态以等待再次“工作”。\n工作窃取算法的优点： 充分利用线程进行并行计算，减少了线程间的竞争。\n工作窃取算法的缺点： 在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。\n2. 源码解释 2.1 ForkJoinTask ForkJoinTask代表运行在ForkJoinPool中的任务。\n主要方法：\nfork() 在当前线程运行的线程池中安排一个异步执行。简单的理解就是再创建一个子任务。 join() 当任务完成的时候返回计算结果。 invoke() 开始执行任务，如果必要，等待计算完成。 子类：\nRecursiveAction 一个递归无结果的ForkJoinTask（没有返回值） RecursiveTask 一个递归有结果的ForkJoinTask（有返回值） ForkJoinTask是一个类似普通线程的实体，但是比普通线程轻量得多。\nfork()方法:使用线程池中的空闲线程异步提交任务\n// 本文所有代码都引自Java 8 public final ForkJoinTask\u003cV\u003e fork() { Thread t; // ForkJoinWorkerThread是执行ForkJoinTask的专有线程，由ForkJoinPool管理 // 先判断当前线程是否是ForkJoin专有线程，如果是，则将任务push到当前线程所负责的队列里去 if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ((ForkJoinWorkerThread)t).workQueue.push(this); else // 如果不是则将线程加入队列 // 没有显式创建ForkJoinPool的时候走这里，提交任务到默认的common线程池中 ForkJoinPool.common.externalPush(this); return this; } 其实fork()只做了一件事，那就是把任务推入当前工作线程的工作队列里。\njoin()方法：等待处理任务的线程处理完毕，获得返回值。来看下join()的源码：\npublic final V join() { int s; // doJoin()方法来获取当前任务的执行状态 if ((s = doJoin() \u0026 DONE_MASK) != NORMAL) // 任务异常，抛出异常 reportException(s); // 任务正常完成，获取返回值 return getRawResult(); } /** * doJoin()方法用来返回当前任务的执行状态 **/ private int doJoin() { int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w; // 先判断任务是否执行完毕，执行完毕直接返回结果（执行状态） return (s = status) \u003c 0 ? s : // 如果没有执行完毕，先判断是否是ForkJoinWorkThread线程 ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ? // 如果是，先判断任务是否处于工作队列顶端（意味着下一个就执行它） // tryUnpush()方法判断任务是否处于当前工作队列顶端，是返回true // doExec()方法执行任务 (w = (wt = (ForkJoinWorkerThread)t).workQueue). // 如果是处于顶端并且任务执行完毕，返回结果 tryUnpush(this) \u0026\u0026 (s = doExec()) \u003c 0 ? s : // 如果不在顶端或者在顶端却没未执行完毕，那就调用awitJoin()执行任务 // awaitJoin()：使用自旋使任务执行完成，返回结果 wt.pool.awaitJoin(w, this, 0L) : // 如果不是ForkJoinWorkThread线程，执行externalAwaitDone()返回任务结果 externalAwaitDone(); } 我们在之前介绍过说Thread.join()会使线程阻塞，而ForkJoinPool.join()会使线程免于阻塞，下面是ForkJoinPool.join()的流程图：\n2.2 ForkJoinWorkerThread ForkJoinWorkerThread代表ForkJoinPool线程池中的一个执行任务的线程。\n/** * Default ForkJoinWorkerThreadFactory implementation; creates a * new ForkJoinWorkerThread. */ static final class DefaultForkJoinWorkerThreadFactory implements ForkJoinWorkerThreadFactory { public final ForkJoinWorkerThread newThread(ForkJoinPool pool) { return new ForkJoinWorkerThread(pool); } } 2.3 ForkJoinPool ForkJoinPool是用于执行ForkJoinTask任务的执行（线程）池。\nForkJoinPool管理着执行池中的线程和任务队列，此外，执行池是否还接受任务，显示线程的运行状态也是在这里处理。\n我们来大致看下ForkJoinPool的源码：\n@sun.misc.Contended public class ForkJoinPool extends AbstractExecutorService { // 任务队列 volatile WorkQueue[] workQueues; // 线程的运行状态 volatile int runState; // 创建ForkJoinWorkerThread的默认工厂，可以通过构造函数重写 public static final ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory; // 公用的线程池，其运行状态不受shutdown()和shutdownNow()的影响 static final ForkJoinPool common; // 私有构造方法，没有任何安全检查和参数校验，由makeCommonPool直接调用 // 其他构造方法都是源自于此方法 // parallelism: 并行度， // 默认调用java.lang.Runtime.availableProcessors() 方法返回可用处理器的数量 private ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, // 工作线程工厂 UncaughtExceptionHandler handler, // 拒绝任务的handler int mode, // 同步模式 String workerNamePrefix) { // 线程名prefix this.workerNamePrefix = workerNamePrefix; this.factory = factory; this.ueh = handler; this.config = (parallelism \u0026 SMASK) | mode; long np = (long)(-parallelism); // offset ctl counts this.ctl = ((np \u003c\u003c AC_SHIFT) \u0026 AC_MASK) | ((np \u003c\u003c TC_SHIFT) \u0026 TC_MASK); } /** * Creates and returns the common pool, respecting user settings * specified via system properties. * jdk8 提供了一个简单的pool,(默认并行数是cpu核数-1), Lambda中(所有)的并行流用的就是这个方法,所以乱用并行流可能会导致线程阻塞卡死 */ private static ForkJoinPool makeCommonPool() { int parallelism = -1; ForkJoinWorkerThreadFactory factory = null; UncaughtExceptionHandler handler = null; try { // ignore exceptions in accessing/parsing properties String pp = System.getProperty (\"java.util.concurrent.ForkJoinPool.common.parallelism\"); String fp = System.getProperty (\"java.util.concurrent.ForkJoinPool.common.threadFactory\"); String hp = System.getProperty (\"java.util.concurrent.ForkJoinPool.common.exceptionHandler\"); if (pp != null) parallelism = Integer.parseInt(pp); if (fp != null) factory = ((ForkJoinWorkerThreadFactory)ClassLoader. getSystemClassLoader().loadClass(fp).newInstance()); if (hp != null) handler = ((UncaughtExceptionHandler)ClassLoader. getSystemClassLoader().loadClass(hp).newInstance()); } catch (Exception ignore) { } if (factory == null) { if (System.getSecurityManager() == null) factory = defaultForkJoinWorkerThreadFactory; else // use security-managed default factory = new InnocuousForkJoinWorkerThreadFactory(); } if (parallelism \u003c 0 \u0026\u0026 // default 1 less than #cores (parallelism = Runtime.getRuntime().availableProcessors() - 1) \u003c= 0) parallelism = 1; if (parallelism \u003e MAX_CAP) parallelism = MAX_CAP; return new ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,\"ForkJoinPool.commonPool-worker-\"); } } 2.4 WorkQueue 双端队列，ForkJoinTask们存放在这里。\n当工作线程在处理自己的工作队列时，会从队列首取任务来执行（FIFO）；如果是窃取其他队列的任务时，窃取的任务位于所属任务队列的队尾（LIFO）。\nForkJoinPool与传统线程池最显著的区别就是它维护了一个工作队列数组（volatile WorkQueue[] workQueues，ForkJoinPool中的每个工作线程都维护着一个工作队列）。\narray 初始容量 8192； 第一个任务放在 4096，似乎是因为操作系统内存的原因； 8191 的位置放入任务之后，还是会回到 0 的位置； 初始 base = top = 4096； 从上面放入一个任务 top + 1，不会从下面放入任务； LIFO 模式自己线程从上面取走任务 top - 1； FIFO 模式自己线程从下面取走任务 base + 1； 被其它线程从下面窃取任务，base + 1，其它线程不会从上面窃取任务； 数组 size 由 top - base 获得； 从 8191 回到 0 之后，top 和 base 会继续往上加，索引值通过取余获得。 static final int INITIAL_QUEUE_CAPACITY = 1 \u003c\u003c 13; // 2^13 = 8192 static final int MAXIMUM_QUEUE_CAPACITY = 1 \u003c\u003c 26; // 2^26 = 67108864 如果队列长度不够了,会自动两倍扩容的\n/** * Callback from ForkJoinWorkerThread constructor to establish and * record its WorkQueue. * * @param wt the worker thread * @return the worker's queue */ final WorkQueue registerWorker(ForkJoinWorkerThread wt) { UncaughtExceptionHandler handler; wt.setDaemon(true); // configure thread if ((handler = ueh) != null) wt.setUncaughtExceptionHandler(handler); WorkQueue w = new WorkQueue(this, wt); int i = 0; // assign a pool index int mode = config \u0026 MODE_MASK; int rs = lockRunState(); try { WorkQueue[] ws; int n; // skip if no array if ((ws = workQueues) != null \u0026\u0026 (n = ws.length) \u003e 0) { int s = indexSeed += SEED_INCREMENT; // unlikely to collide int m = n - 1; i = ((s \u003c\u003c 1) | 1) \u0026 m; // odd-numbered indices if (ws[i] != null) { // collision int probes = 0; // step by approx half n int step = (n \u003c= 4) ? 2 : ((n \u003e\u003e\u003e 1) \u0026 EVENMASK) + 2; while (ws[i = (i + step) \u0026 m] != null) { if (++probes \u003e= n) { // 这里用 copyOf 进行复制, 这段代码太难读了,以后再来分析吧 workQueues = ws = Arrays.copyOf(ws, n \u003c\u003c= 1); m = n - 1; probes = 0; } } } w.hint = s; // use as random seed w.config = i | mode; w.scanState = i; // publication fence ws[i] = w; } } finally { unlockRunState(rs, rs \u0026 ~RSLOCK); } wt.setName(workerNamePrefix.concat(Integer.toString(i \u003e\u003e\u003e 1))); return w; } 2.5 runState ForkJoinPool的运行状态。SHUTDOWN状态用负数表示，其他用2的幂次表示。\n总结 对于一个 new ForkJoinPool()，执行任务全流程如下：\nForkJoinPool 初始化 parallelism size = cpu 逻辑核心数，没有队列，没有线程；\n向 ForkJoinPool 提交一个任务；\n初始化队列数组，容量为 2 * Max { parallelism size, 2 ^ n }；\n创建一个没有线程的队列，容量为 2 ^ 13，随机放在队列数组的某一个偶数索引处；\n任务存入这个队列索引值为 2 ^ 12 处；\n再创建一个有线程的队列，容量为 2 ^ 13，随机放在队列数组的某一个奇数索引处；\n线程启动；\n线程从随机一个队列开始，遍历所有队列，最终扫描找到前面提交的任务，并从其所在队列取出；\n线程执行任务，拆分出两个子任务；\n如果用 invokeAll 提交，则一个进入线程所在队列，另一个直接在线程里执行； 如果用 fork 提交，则两个都进入线程所在队列； 提交的子任务触发创建新的线程，及与其对应的队列，还是在奇数索引处；\n提交的子任务可能仍然被当前线程执行，可能被其它线程窃取；\n线程在子任务处 join，join 期间会尝试从窃取自己任务的线程那里窃取任务执行；\n优先窃取队列底部； 队列没有任务则窃取其正在 join 的任务； 还没有则阻塞自己等待被唤醒，在阻塞之前会补偿一个活跃线程； 提交的子任务不管被哪个线程执行，仍会重复上述拆分、提交、窃取、阻塞流程；\n当任务被拆分的足够细，则会真正开始计算；\n计算完成从递归一层一层返回；\n最终所有子任务都完成，得到结果；\n如果不再提交任务，所有线程扫描不到任务进入 inactive 状态；\n最终，所有线程销毁，所有奇数索引位的队列回收，ForkJoinPool 中只剩下一个最初创建的在偶数索引位的队列。\nthread_fork/join并发框架2 - dengzy - 博客园 (cnblogs.com) [笔记][Java7并发编程实战手册]5.Fork＼Join(Java1.7新特性)框架_代码有毒的博客-CSDN博客 Java并发系列（12）——ForkJoin框架源码解析（上） - 知乎 (zhihu.com) Java并发系列（12）——ForkJoin框架源码解析（下） - 知乎 (zhihu.com) ","wordCount":"4417","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-08-31T00:23:09+08:00","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/fork_join.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class="dark" id="top"><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class="header"><nav class="nav"><div class="logo"><a accesskey="h" href="https://xiaokunji.com/zh/" title="米二 (Alt + H)"><img alt="" aria-label="logo" height="35" src="https://xiaokunji.com/img/Q.svg"/>米二</a><div class="logo-switches"><button accesskey="t" id="theme-toggle" title="(Alt + T)"><svg fill="none" height="18" id="moon" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg><svg fill="none" height="18" id="sun" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="5"></circle><line x1="12" x2="12" y1="1" y2="3"></line><line x1="12" x2="12" y1="21" y2="23"></line><line x1="4.22" x2="5.64" y1="4.22" y2="5.64"></line><line x1="18.36" x2="19.78" y1="18.36" y2="19.78"></line><line x1="1" x2="3" y1="12" y2="12"></line><line x1="21" x2="23" y1="12" y2="12"></line><line x1="4.22" x2="5.64" y1="19.78" y2="18.36"></line><line x1="18.36" x2="19.78" y1="5.64" y2="4.22"></line></svg></button><ul class="lang-switch"><li>|</li><li><a aria-label="English" href="https://xiaokunji.com/en/" title="English">English</a></li></ul></div></div><ul id="menu"><li><a href="https://xiaokunji.com/zh/" title="🏠主页"><span>🏠主页</span></a></li><li><a accesskey="/" href="https://xiaokunji.com/zh/search" title="🔍搜索 (Alt + /)"><span>🔍搜索</span></a></li><li><a href="https://xiaokunji.com/zh/post.html" title="📚文章"><span>📚文章</span></a></li><li><a href="https://xiaokunji.com/zh/archives.html" title="⏱时间轴"><span>⏱时间轴</span></a></li><li><a href="https://xiaokunji.com/zh/tags.html" title="🔖标签"><span>🔖标签</span></a></li><li><a href="https://xiaokunji.com/zh/categories.html" title="📖分类"><span>📖分类</span></a></li><li><a href="https://xiaokunji.com/zh/links.html" title="🤝友链"><span>🤝友链</span></a></li></ul></nav></header><main class="main"><article class="post-single"><header class="post-header"><nav aria-label="breadcrumb"><ul><a href="https://xiaokunji.com/zh/">🏠</a> <span>&gt;</span>
<a href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html">java及其框架</a> <span>&gt;</span>
<a href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80.html">java基础</a> <span>&gt;</span>
<a href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91.html">并发</a> <span>&gt;</span></ul></nav><h1 class="post-title">ForkJoin</h1><div class="post-description">java 的forkjoin</div><div class="post-meta">创建: <span title="2023-08-22 00:00:00 +0000 UTC">2023-08-22</span> · 更新: 2023-08-31 · xkj
 | 分类:  <ul class="post-categories-meta"><a href="https://xiaokunji.com/zh/categories/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html">java及其框架</a></ul><span id="busuanzi_container_page_pv"> | 访问: <span id="busuanzi_value_page_pv">1</span></span></div></header><div class="post-content"><p>[toc]</p><h1 id="前言">前言<a aria-hidden="true" class="anchor" hidden="" href="#前言">#</a></h1><p>它通过 「 分而治之 」 的方法尝试将所有可用的处理器内核使用起来帮助加速并行处理。</p><p>在实际使用过程中，这种 「 分而治之 」的方法意味着框架首先要 <code>fork</code> ，递归地将任务分解为较小的独立子任务，直到它们足够简单以便异步执行。然后，<code>join</code> 部分开始工作，将所有子任务的结果递归地连接成单个结果，或者在返回 void 的任务的情况下，程序只是等待每个子任务执行完毕。</p><p>Fork/Join框架是一个实现了ExecutorService接口的多线程处理器，它专为那些可以通过递归分解成更细小的任务而设计，最大化的利用多核处理器来提高应用程序的性能。</p><p>与其他ExecutorService相关的实现相同的是，Fork/Join框架会将任务分配给线程池中的线程。而与之不同的是，Fork/Join框架在执行任务时使用了<strong>工作窃取算法</strong>。</p><p>ForkJoin 有两大核心思想：</p><ul><li>分治算法；</li><li>工作密取：为了充分利用 cpu 资源，一个工作线程执行完自己队列的任务之后，不会空闲，而是从其它队列里寻找任务。</li></ul><p><strong>使用场景</strong>:</p><ol><li><p>ForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。</p></li><li><p>ForkJoinPool 主要用于实现“分而治之”的算法，特别是分治之后递归调用的函数，例如 quick sort 等。</p></li><li><p>ForkJoinPool 最适合的是计算密集型的任务，如果存在 I/O，线程间同步，sleep() 等会造成线程长时间阻塞的情况时，最好配合使用 ManagedBlocker。</p><blockquote><p>ManagedBlocker 它可以控制在阻塞时增加并行数, 这样就不会卡死了</p></blockquote></li></ol><p><a href="http://concurrent.redspider.group/article/03/18.html" rel="noopener" target="_blank">18 Fork/Join框架 · 深入浅出Java多线程 (redspider.group)</a></p><p><a href="https://www.twle.cn/c/yufei/javatm/javatm-basic-forkjoin.html" rel="noopener" target="_blank">一文秒懂 Java Fork/Join - Java 一文秒懂 - 简单教程，简单编程 (twle.cn)</a></p><p><a href="https://www.itbaoku.cn/post/2147877/do" rel="noopener" target="_blank">在Java8 parallelStream()中使用I/O + ManagedBlocker有什么问题吗? - IT宝库 (itbaoku.cn)</a></p><p><a href="https://blog.csdn.net/heng_zou/article/details/118193846" rel="noopener" target="_blank">关于ForkJoinPool使用ManagedBlocker防线程阻塞而降低吞吐量的说明_heng_zou的博客-CSDN博客_forkjoin 阻塞</a></p><p><b style="color:red">ManagedBlocker的使用和深入理解ForkJoin 有待提升</b></p><h1 id="1-工作窃取算法">1. 工作窃取算法<a aria-hidden="true" class="anchor" hidden="" href="#1-工作窃取算法">#</a></h1><p>工作窃取算法指的是在多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。</p><p>工作窃取流程如下图所示：</p><p><img alt="工作窃取算法流程" loading="lazy" src="http://concurrent.redspider.group/article/03/imgs/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%AE%97%E6%B3%95%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"/></p><p>值得注意的是，当一个线程窃取另一个线程的时候，为了减少两个任务线程之间的竞争，我们通常使用<strong>双端队列</strong>来存储任务。被窃取的任务线程都从双端队列的<strong>头部</strong>拿任务执行，而窃取其他任务的线程从双端队列的<strong>尾部</strong>执行任务。</p><p>另外，当一个线程在窃取任务时要是没有其他可用的任务了，这个线程会进入<strong>阻塞状态</strong>以等待再次“工作”。</p><p><img alt="image-20230830172212889" loading="lazy" src="forkJoin.assets/image-20230830172212889.png"/></p><p>工作窃取算法的<strong>优点</strong>： 充分利用线程进行并行计算，减少了线程间的竞争。</p><p>工作窃取算法的<strong>缺点</strong>： 在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><h1 id="2-源码解释">2. 源码解释<a aria-hidden="true" class="anchor" hidden="" href="#2-源码解释">#</a></h1><p><img alt="img" loading="lazy" src="https://pic1.zhimg.com/v2-f8a4fa79f5e6b83671c3401f57b2f98c_r.jpg"/></p><h2 id="21-forkjointask">2.1 ForkJoinTask<a aria-hidden="true" class="anchor" hidden="" href="#21-forkjointask">#</a></h2><p>ForkJoinTask代表运行在ForkJoinPool中的任务。</p><p>主要方法：</p><ul><li>fork() 在当前线程运行的线程池中安排一个异步执行。简单的理解就是再创建一个子任务。</li><li>join() 当任务完成的时候返回计算结果。</li><li>invoke() 开始执行任务，如果必要，等待计算完成。</li></ul><p>子类：</p><ul><li>RecursiveAction 一个递归无结果的ForkJoinTask（没有返回值）</li><li>RecursiveTask 一个递归有结果的ForkJoinTask（有返回值）</li></ul><p>ForkJoinTask是一个类似普通线程的实体，但是比普通线程轻量得多。</p><p><strong>fork()方法</strong>:使用线程池中的空闲线程异步提交任务</p><div class="highlight"><pre style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-java" data-lang="java"><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">// 本文所有代码都引自Java 8
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">public</span> <span style="color:#ff7b72">final</span> ForkJoinTask<span style="color:#ff7b72;font-weight:700">&lt;</span>V<span style="color:#ff7b72;font-weight:700">&gt;</span> <span style="color:#d2a8ff;font-weight:700">fork</span><span style="color:#ff7b72;font-weight:700">()</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>    Thread t<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">// ForkJoinWorkerThread是执行ForkJoinTask的专有线程，由ForkJoinPool管理
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#8b949e;font-style:italic">// 先判断当前线程是否是ForkJoin专有线程，如果是，则将任务push到当前线程所负责的队列里去
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">if</span> <span style="color:#ff7b72;font-weight:700">((</span>t <span style="color:#ff7b72;font-weight:700">=</span> Thread<span style="color:#ff7b72;font-weight:700">.</span>currentThread<span style="color:#ff7b72;font-weight:700">())</span> <span style="color:#ff7b72">instanceof</span> ForkJoinWorkerThread<span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">((</span>ForkJoinWorkerThread<span style="color:#ff7b72;font-weight:700">)</span>t<span style="color:#ff7b72;font-weight:700">).</span>workQueue<span style="color:#ff7b72;font-weight:700">.</span>push<span style="color:#ff7b72;font-weight:700">(</span><span style="color:#ff7b72">this</span><span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">else</span>
</span></span><span style="display:flex"><span>         <span style="color:#8b949e;font-style:italic">// 如果不是则将线程加入队列
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#8b949e;font-style:italic">// 没有显式创建ForkJoinPool的时候走这里，提交任务到默认的common线程池中
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        ForkJoinPool<span style="color:#ff7b72;font-weight:700">.</span>common<span style="color:#ff7b72;font-weight:700">.</span>externalPush<span style="color:#ff7b72;font-weight:700">(</span><span style="color:#ff7b72">this</span><span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">return</span> <span style="color:#ff7b72">this</span><span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span><span style="color:#ff7b72;font-weight:700">}</span>
</span></span></code></pre></div><p>其实fork()只做了一件事，那就是<strong>把任务推入当前工作线程的工作队列里</strong>。</p><p><strong>join()方法</strong>：等待处理任务的线程处理完毕，获得返回值。来看下join()的源码：</p><div class="highlight"><pre style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-java" data-lang="java"><span style="display:flex"><span><span style="color:#ff7b72">public</span> <span style="color:#ff7b72">final</span> V <span style="color:#d2a8ff;font-weight:700">join</span><span style="color:#ff7b72;font-weight:700">()</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">int</span> s<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">// doJoin()方法来获取当前任务的执行状态
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">if</span> <span style="color:#ff7b72;font-weight:700">((</span>s <span style="color:#ff7b72;font-weight:700">=</span> doJoin<span style="color:#ff7b72;font-weight:700">()</span> <span style="color:#ff7b72;font-weight:700">&amp;</span> DONE_MASK<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">!=</span> NORMAL<span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>        <span style="color:#8b949e;font-style:italic">// 任务异常，抛出异常
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        reportException<span style="color:#ff7b72;font-weight:700">(</span>s<span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">// 任务正常完成，获取返回值
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">return</span> getRawResult<span style="color:#ff7b72;font-weight:700">();</span>
</span></span><span style="display:flex"><span><span style="color:#ff7b72;font-weight:700">}</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">/**
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * doJoin()方法用来返回当前任务的执行状态
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> **/</span>
</span></span><span style="display:flex"><span><span style="color:#ff7b72">private</span> <span style="color:#ff7b72">int</span> <span style="color:#d2a8ff;font-weight:700">doJoin</span><span style="color:#ff7b72;font-weight:700">()</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">int</span> s<span style="color:#ff7b72;font-weight:700">;</span> Thread t<span style="color:#ff7b72;font-weight:700">;</span> ForkJoinWorkerThread wt<span style="color:#ff7b72;font-weight:700">;</span> ForkJoinPool<span style="color:#ff7b72;font-weight:700">.</span>WorkQueue w<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">// 先判断任务是否执行完毕，执行完毕直接返回结果（执行状态）
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">return</span> <span style="color:#ff7b72;font-weight:700">(</span>s <span style="color:#ff7b72;font-weight:700">=</span> status<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">&lt;</span> 0 <span style="color:#ff7b72;font-weight:700">?</span> s <span style="color:#ff7b72;font-weight:700">:</span>
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">// 如果没有执行完毕，先判断是否是ForkJoinWorkThread线程
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72;font-weight:700">((</span>t <span style="color:#ff7b72;font-weight:700">=</span> Thread<span style="color:#ff7b72;font-weight:700">.</span>currentThread<span style="color:#ff7b72;font-weight:700">())</span> <span style="color:#ff7b72">instanceof</span> ForkJoinWorkerThread<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">?</span>
</span></span><span style="display:flex"><span>        <span style="color:#8b949e;font-style:italic">// 如果是，先判断任务是否处于工作队列顶端（意味着下一个就执行它）
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#8b949e;font-style:italic">// tryUnpush()方法判断任务是否处于当前工作队列顶端，是返回true
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#8b949e;font-style:italic">// doExec()方法执行任务
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#ff7b72;font-weight:700">(</span>w <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">(</span>wt <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">(</span>ForkJoinWorkerThread<span style="color:#ff7b72;font-weight:700">)</span>t<span style="color:#ff7b72;font-weight:700">).</span>workQueue<span style="color:#ff7b72;font-weight:700">).</span>
</span></span><span style="display:flex"><span>        <span style="color:#8b949e;font-style:italic">// 如果是处于顶端并且任务执行完毕，返回结果
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        tryUnpush<span style="color:#ff7b72;font-weight:700">(</span><span style="color:#ff7b72">this</span><span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">&amp;&amp;</span> <span style="color:#ff7b72;font-weight:700">(</span>s <span style="color:#ff7b72;font-weight:700">=</span> doExec<span style="color:#ff7b72;font-weight:700">())</span> <span style="color:#ff7b72;font-weight:700">&lt;</span> 0 <span style="color:#ff7b72;font-weight:700">?</span> s <span style="color:#ff7b72;font-weight:700">:</span>
</span></span><span style="display:flex"><span>        <span style="color:#8b949e;font-style:italic">// 如果不在顶端或者在顶端却没未执行完毕，那就调用awitJoin()执行任务
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#8b949e;font-style:italic">// awaitJoin()：使用自旋使任务执行完成，返回结果
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        wt<span style="color:#ff7b72;font-weight:700">.</span>pool<span style="color:#ff7b72;font-weight:700">.</span>awaitJoin<span style="color:#ff7b72;font-weight:700">(</span>w<span style="color:#ff7b72;font-weight:700">,</span> <span style="color:#ff7b72">this</span><span style="color:#ff7b72;font-weight:700">,</span> 0L<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">:</span>
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">// 如果不是ForkJoinWorkThread线程，执行externalAwaitDone()返回任务结果
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    externalAwaitDone<span style="color:#ff7b72;font-weight:700">();</span>
</span></span><span style="display:flex"><span><span style="color:#ff7b72;font-weight:700">}</span>
</span></span></code></pre></div><p>我们在之前介绍过说Thread.join()会使线程阻塞，而ForkJoinPool.join()会使线程免于阻塞，下面是ForkJoinPool.join()的流程图：</p><p><img alt="join流程图" loading="lazy" src="http://concurrent.redspider.group/article/03/imgs/join%E6%B5%81%E7%A8%8B%E5%9B%BE.png"/></p><h2 id="22-forkjoinworkerthread">2.2 ForkJoinWorkerThread<a aria-hidden="true" class="anchor" hidden="" href="#22-forkjoinworkerthread">#</a></h2><p>ForkJoinWorkerThread代表ForkJoinPool线程池中的一个执行任务的线程。</p><p><img alt="img" loading="lazy" src="forkJoin.assets/874963-20180523163540976-673113189.png"/>
<img alt="img" loading="lazy" src="forkJoin.assets/874963-20180523163529873-1907395587.png"/>
<img alt="img" loading="lazy" src="forkJoin.assets/874963-20180523163554075-1223888829.png"/></p><div class="highlight"><pre style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-java" data-lang="java"><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">/**
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">     * Default ForkJoinWorkerThreadFactory implementation; creates a
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">     * new ForkJoinWorkerThread.
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">     */</span>
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">static</span> <span style="color:#ff7b72">final</span> <span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:700">DefaultForkJoinWorkerThreadFactory</span> <span style="color:#ff7b72">implements</span> ForkJoinWorkerThreadFactory <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">public</span> <span style="color:#ff7b72">final</span> ForkJoinWorkerThread <span style="color:#d2a8ff;font-weight:700">newThread</span><span style="color:#ff7b72;font-weight:700">(</span>ForkJoinPool pool<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">return</span> <span style="color:#ff7b72">new</span> ForkJoinWorkerThread<span style="color:#ff7b72;font-weight:700">(</span>pool<span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">}</span>
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72;font-weight:700">}</span>
</span></span></code></pre></div><h2 id="23-forkjoinpool">2.3 ForkJoinPool<a aria-hidden="true" class="anchor" hidden="" href="#23-forkjoinpool">#</a></h2><p>ForkJoinPool是用于执行ForkJoinTask任务的执行（线程）池。</p><p>ForkJoinPool管理着执行池中的线程和任务队列，此外，执行池是否还接受任务，显示线程的运行状态也是在这里处理。</p><p>我们来大致看下ForkJoinPool的源码：</p><div class="highlight"><pre style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-java" data-lang="java"><span style="display:flex"><span><span style="color:#d2a8ff;font-weight:700">@sun.misc.Contended</span>
</span></span><span style="display:flex"><span><span style="color:#ff7b72">public</span> <span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:700">ForkJoinPool</span> <span style="color:#ff7b72">extends</span> AbstractExecutorService <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">// 任务队列
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">volatile</span> WorkQueue<span style="color:#ff7b72;font-weight:700">[]</span> workQueues<span style="color:#ff7b72;font-weight:700">;</span>   
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">// 线程的运行状态
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">volatile</span> <span style="color:#ff7b72">int</span> runState<span style="color:#ff7b72;font-weight:700">;</span>  
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">// 创建ForkJoinWorkerThread的默认工厂，可以通过构造函数重写
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">public</span> <span style="color:#ff7b72">static</span> <span style="color:#ff7b72">final</span> ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">// 公用的线程池，其运行状态不受shutdown()和shutdownNow()的影响
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">static</span> <span style="color:#ff7b72">final</span> ForkJoinPool common<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">// 私有构造方法，没有任何安全检查和参数校验，由makeCommonPool直接调用
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#8b949e;font-style:italic">// 其他构造方法都是源自于此方法
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#8b949e;font-style:italic">// parallelism: 并行度，
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#8b949e;font-style:italic">// 默认调用java.lang.Runtime.availableProcessors() 方法返回可用处理器的数量
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">private</span> <span style="color:#d2a8ff;font-weight:700">ForkJoinPool</span><span style="color:#ff7b72;font-weight:700">(</span><span style="color:#ff7b72">int</span> parallelism<span style="color:#ff7b72;font-weight:700">,</span>
</span></span><span style="display:flex"><span>                         ForkJoinWorkerThreadFactory factory<span style="color:#ff7b72;font-weight:700">,</span> <span style="color:#8b949e;font-style:italic">// 工作线程工厂
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>                         UncaughtExceptionHandler handler<span style="color:#ff7b72;font-weight:700">,</span> <span style="color:#8b949e;font-style:italic">// 拒绝任务的handler
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>                         <span style="color:#ff7b72">int</span> mode<span style="color:#ff7b72;font-weight:700">,</span> <span style="color:#8b949e;font-style:italic">// 同步模式
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>                         String workerNamePrefix<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">{</span> <span style="color:#8b949e;font-style:italic">// 线程名prefix
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#ff7b72">this</span><span style="color:#ff7b72;font-weight:700">.</span>workerNamePrefix <span style="color:#ff7b72;font-weight:700">=</span> workerNamePrefix<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">this</span><span style="color:#ff7b72;font-weight:700">.</span>factory <span style="color:#ff7b72;font-weight:700">=</span> factory<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">this</span><span style="color:#ff7b72;font-weight:700">.</span>ueh <span style="color:#ff7b72;font-weight:700">=</span> handler<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">this</span><span style="color:#ff7b72;font-weight:700">.</span>config <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">(</span>parallelism <span style="color:#ff7b72;font-weight:700">&amp;</span> SMASK<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">|</span> mode<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">long</span> np <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">(</span><span style="color:#ff7b72">long</span><span style="color:#ff7b72;font-weight:700">)(-</span>parallelism<span style="color:#ff7b72;font-weight:700">);</span> <span style="color:#8b949e;font-style:italic">// offset ctl counts
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#ff7b72">this</span><span style="color:#ff7b72;font-weight:700">.</span>ctl <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">((</span>np <span style="color:#ff7b72;font-weight:700">&lt;&lt;</span> AC_SHIFT<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">&amp;</span> AC_MASK<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">|</span> <span style="color:#ff7b72;font-weight:700">((</span>np <span style="color:#ff7b72;font-weight:700">&lt;&lt;</span> TC_SHIFT<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">&amp;</span> TC_MASK<span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72;font-weight:700">}</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">/**
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">     * Creates and returns the common pool, respecting user settings
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">     * specified via system properties.
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">     * jdk8 提供了一个简单的pool,(默认并行数是cpu核数-1), Lambda中(所有)的并行流用的就是这个方法,所以乱用并行流可能会导致线程阻塞卡死
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">     */</span>
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">private</span> <span style="color:#ff7b72">static</span> ForkJoinPool <span style="color:#d2a8ff;font-weight:700">makeCommonPool</span><span style="color:#ff7b72;font-weight:700">()</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">int</span> parallelism <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">-</span>1<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>        ForkJoinWorkerThreadFactory factory <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#79c0ff">null</span><span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>        UncaughtExceptionHandler handler <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#79c0ff">null</span><span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">try</span> <span style="color:#ff7b72;font-weight:700">{</span>  <span style="color:#8b949e;font-style:italic">// ignore exceptions in accessing/parsing properties
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>            String pp <span style="color:#ff7b72;font-weight:700">=</span> System<span style="color:#ff7b72;font-weight:700">.</span>getProperty
</span></span><span style="display:flex"><span>                <span style="color:#ff7b72;font-weight:700">(</span><span style="color:#a5d6ff">"java.util.concurrent.ForkJoinPool.common.parallelism"</span><span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>            String fp <span style="color:#ff7b72;font-weight:700">=</span> System<span style="color:#ff7b72;font-weight:700">.</span>getProperty
</span></span><span style="display:flex"><span>                <span style="color:#ff7b72;font-weight:700">(</span><span style="color:#a5d6ff">"java.util.concurrent.ForkJoinPool.common.threadFactory"</span><span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>            String hp <span style="color:#ff7b72;font-weight:700">=</span> System<span style="color:#ff7b72;font-weight:700">.</span>getProperty
</span></span><span style="display:flex"><span>                <span style="color:#ff7b72;font-weight:700">(</span><span style="color:#a5d6ff">"java.util.concurrent.ForkJoinPool.common.exceptionHandler"</span><span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">if</span> <span style="color:#ff7b72;font-weight:700">(</span>pp <span style="color:#ff7b72;font-weight:700">!=</span> <span style="color:#79c0ff">null</span><span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>                parallelism <span style="color:#ff7b72;font-weight:700">=</span> Integer<span style="color:#ff7b72;font-weight:700">.</span>parseInt<span style="color:#ff7b72;font-weight:700">(</span>pp<span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">if</span> <span style="color:#ff7b72;font-weight:700">(</span>fp <span style="color:#ff7b72;font-weight:700">!=</span> <span style="color:#79c0ff">null</span><span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>                factory <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">((</span>ForkJoinWorkerThreadFactory<span style="color:#ff7b72;font-weight:700">)</span>ClassLoader<span style="color:#ff7b72;font-weight:700">.</span>
</span></span><span style="display:flex"><span>                           <span style="color:#d2a8ff;font-weight:700">getSystemClassLoader</span><span style="color:#ff7b72;font-weight:700">().</span>loadClass<span style="color:#ff7b72;font-weight:700">(</span>fp<span style="color:#ff7b72;font-weight:700">).</span>newInstance<span style="color:#ff7b72;font-weight:700">());</span>
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">if</span> <span style="color:#ff7b72;font-weight:700">(</span>hp <span style="color:#ff7b72;font-weight:700">!=</span> <span style="color:#79c0ff">null</span><span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>                handler <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">((</span>UncaughtExceptionHandler<span style="color:#ff7b72;font-weight:700">)</span>ClassLoader<span style="color:#ff7b72;font-weight:700">.</span>
</span></span><span style="display:flex"><span>                           <span style="color:#d2a8ff;font-weight:700">getSystemClassLoader</span><span style="color:#ff7b72;font-weight:700">().</span>loadClass<span style="color:#ff7b72;font-weight:700">(</span>hp<span style="color:#ff7b72;font-weight:700">).</span>newInstance<span style="color:#ff7b72;font-weight:700">());</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">}</span> <span style="color:#ff7b72">catch</span> <span style="color:#ff7b72;font-weight:700">(</span>Exception ignore<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">}</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">if</span> <span style="color:#ff7b72;font-weight:700">(</span>factory <span style="color:#ff7b72;font-weight:700">==</span> <span style="color:#79c0ff">null</span><span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">if</span> <span style="color:#ff7b72;font-weight:700">(</span>System<span style="color:#ff7b72;font-weight:700">.</span>getSecurityManager<span style="color:#ff7b72;font-weight:700">()</span> <span style="color:#ff7b72;font-weight:700">==</span> <span style="color:#79c0ff">null</span><span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>                factory <span style="color:#ff7b72;font-weight:700">=</span> defaultForkJoinWorkerThreadFactory<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">else</span> <span style="color:#8b949e;font-style:italic">// use security-managed default
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>                factory <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72">new</span> InnocuousForkJoinWorkerThreadFactory<span style="color:#ff7b72;font-weight:700">();</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">}</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">if</span> <span style="color:#ff7b72;font-weight:700">(</span>parallelism <span style="color:#ff7b72;font-weight:700">&lt;</span> 0 <span style="color:#ff7b72;font-weight:700">&amp;&amp;</span> <span style="color:#8b949e;font-style:italic">// default 1 less than #cores
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>            <span style="color:#ff7b72;font-weight:700">(</span>parallelism <span style="color:#ff7b72;font-weight:700">=</span> Runtime<span style="color:#ff7b72;font-weight:700">.</span>getRuntime<span style="color:#ff7b72;font-weight:700">().</span>availableProcessors<span style="color:#ff7b72;font-weight:700">()</span> <span style="color:#ff7b72;font-weight:700">-</span> 1<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">&lt;=</span> 0<span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>            parallelism <span style="color:#ff7b72;font-weight:700">=</span> 1<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">if</span> <span style="color:#ff7b72;font-weight:700">(</span>parallelism <span style="color:#ff7b72;font-weight:700">&gt;</span> MAX_CAP<span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>            parallelism <span style="color:#ff7b72;font-weight:700">=</span> MAX_CAP<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">return</span> <span style="color:#ff7b72">new</span> ForkJoinPool<span style="color:#ff7b72;font-weight:700">(</span>parallelism<span style="color:#ff7b72;font-weight:700">,</span> factory<span style="color:#ff7b72;font-weight:700">,</span> handler<span style="color:#ff7b72;font-weight:700">,</span> LIFO_QUEUE<span style="color:#ff7b72;font-weight:700">,</span><span style="color:#a5d6ff">"ForkJoinPool.commonPool-worker-"</span><span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72;font-weight:700">}</span>
</span></span><span style="display:flex"><span>    
</span></span><span style="display:flex"><span><span style="color:#ff7b72;font-weight:700">}</span>
</span></span></code></pre></div><h2 id="24-workqueue">2.4 WorkQueue<a aria-hidden="true" class="anchor" hidden="" href="#24-workqueue">#</a></h2><p>双端队列，ForkJoinTask们存放在这里。</p><p>当工作线程在处理自己的工作队列时，会从队列首取任务来执行（FIFO）；如果是窃取其他队列的任务时，窃取的任务位于所属任务队列的队尾（LIFO）。</p><p>ForkJoinPool与传统线程池最显著的区别就是它维护了一个<strong>工作队列数组</strong>（volatile WorkQueue[] workQueues，ForkJoinPool中的<strong>每个工作线程都维护着一个工作队列</strong>）。</p><p><img alt="img" loading="lazy" src="https://pic3.zhimg.com/v2-f9986f1e66a50778bbac48eb851e540e_r.jpg"/></p><blockquote><ul><li>array 初始容量 8192；</li><li>第一个任务放在 4096，似乎是因为操作系统内存的原因；</li><li>8191 的位置放入任务之后，还是会回到 0 的位置；</li><li>初始 base = top = 4096；</li><li>从上面放入一个任务 top + 1，不会从下面放入任务；</li><li>LIFO 模式自己线程从上面取走任务 top - 1；</li><li>FIFO 模式自己线程从下面取走任务 base + 1；</li><li>被其它线程从下面窃取任务，base + 1，其它线程不会从上面窃取任务；</li><li>数组 size 由 top - base 获得；</li><li>从 8191 回到 0 之后，top 和 base 会继续往上加，索引值通过取余获得。</li></ul></blockquote><div class="highlight"><pre style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-java" data-lang="java"><span style="display:flex"><span><span style="color:#ff7b72">static</span> <span style="color:#ff7b72">final</span> <span style="color:#ff7b72">int</span> INITIAL_QUEUE_CAPACITY <span style="color:#ff7b72;font-weight:700">=</span> 1 <span style="color:#ff7b72;font-weight:700">&lt;&lt;</span> 13<span style="color:#ff7b72;font-weight:700">;</span> <span style="color:#8b949e;font-style:italic">// 2^13 =  8192
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">static</span> <span style="color:#ff7b72">final</span> <span style="color:#ff7b72">int</span> MAXIMUM_QUEUE_CAPACITY <span style="color:#ff7b72;font-weight:700">=</span> 1 <span style="color:#ff7b72;font-weight:700">&lt;&lt;</span> 26<span style="color:#ff7b72;font-weight:700">;</span> <span style="color:#8b949e;font-style:italic">// 2^26 = 67108864
</span></span></span></code></pre></div><p><strong>如果队列长度不够了,会自动两倍扩容的</strong></p><div class="highlight"><pre style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-java" data-lang="java"><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">/**
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">     * Callback from ForkJoinWorkerThread constructor to establish and
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">     * record its WorkQueue.
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">     *
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">     * @param wt the worker thread
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">     * @return the worker's queue
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">     */</span>
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">final</span> WorkQueue <span style="color:#d2a8ff;font-weight:700">registerWorker</span><span style="color:#ff7b72;font-weight:700">(</span>ForkJoinWorkerThread wt<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>        UncaughtExceptionHandler handler<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>        wt<span style="color:#ff7b72;font-weight:700">.</span>setDaemon<span style="color:#ff7b72;font-weight:700">(</span><span style="color:#79c0ff">true</span><span style="color:#ff7b72;font-weight:700">);</span>                           <span style="color:#8b949e;font-style:italic">// configure thread
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#ff7b72">if</span> <span style="color:#ff7b72;font-weight:700">((</span>handler <span style="color:#ff7b72;font-weight:700">=</span> ueh<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">!=</span> <span style="color:#79c0ff">null</span><span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>            wt<span style="color:#ff7b72;font-weight:700">.</span>setUncaughtExceptionHandler<span style="color:#ff7b72;font-weight:700">(</span>handler<span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>        WorkQueue w <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72">new</span> WorkQueue<span style="color:#ff7b72;font-weight:700">(</span><span style="color:#ff7b72">this</span><span style="color:#ff7b72;font-weight:700">,</span> wt<span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">int</span> i <span style="color:#ff7b72;font-weight:700">=</span> 0<span style="color:#ff7b72;font-weight:700">;</span>                                    <span style="color:#8b949e;font-style:italic">// assign a pool index
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#ff7b72">int</span> mode <span style="color:#ff7b72;font-weight:700">=</span> config <span style="color:#ff7b72;font-weight:700">&amp;</span> MODE_MASK<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">int</span> rs <span style="color:#ff7b72;font-weight:700">=</span> lockRunState<span style="color:#ff7b72;font-weight:700">();</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">try</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>            WorkQueue<span style="color:#ff7b72;font-weight:700">[]</span> ws<span style="color:#ff7b72;font-weight:700">;</span> <span style="color:#ff7b72">int</span> n<span style="color:#ff7b72;font-weight:700">;</span>                    <span style="color:#8b949e;font-style:italic">// skip if no array
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>            <span style="color:#ff7b72">if</span> <span style="color:#ff7b72;font-weight:700">((</span>ws <span style="color:#ff7b72;font-weight:700">=</span> workQueues<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">!=</span> <span style="color:#79c0ff">null</span> <span style="color:#ff7b72;font-weight:700">&amp;&amp;</span> <span style="color:#ff7b72;font-weight:700">(</span>n <span style="color:#ff7b72;font-weight:700">=</span> ws<span style="color:#ff7b72;font-weight:700">.</span>length<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">&gt;</span> 0<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>                <span style="color:#ff7b72">int</span> s <span style="color:#ff7b72;font-weight:700">=</span> indexSeed <span style="color:#ff7b72;font-weight:700">+=</span> SEED_INCREMENT<span style="color:#ff7b72;font-weight:700">;</span>  <span style="color:#8b949e;font-style:italic">// unlikely to collide
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>                <span style="color:#ff7b72">int</span> m <span style="color:#ff7b72;font-weight:700">=</span> n <span style="color:#ff7b72;font-weight:700">-</span> 1<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>                i <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">((</span>s <span style="color:#ff7b72;font-weight:700">&lt;&lt;</span> 1<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">|</span> 1<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">&amp;</span> m<span style="color:#ff7b72;font-weight:700">;</span>               <span style="color:#8b949e;font-style:italic">// odd-numbered indices
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>                <span style="color:#ff7b72">if</span> <span style="color:#ff7b72;font-weight:700">(</span>ws<span style="color:#ff7b72;font-weight:700">[</span>i<span style="color:#ff7b72;font-weight:700">]</span> <span style="color:#ff7b72;font-weight:700">!=</span> <span style="color:#79c0ff">null</span><span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">{</span>                  <span style="color:#8b949e;font-style:italic">// collision
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>                    <span style="color:#ff7b72">int</span> probes <span style="color:#ff7b72;font-weight:700">=</span> 0<span style="color:#ff7b72;font-weight:700">;</span>                   <span style="color:#8b949e;font-style:italic">// step by approx half n
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>                    <span style="color:#ff7b72">int</span> step <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">(</span>n <span style="color:#ff7b72;font-weight:700">&lt;=</span> 4<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">?</span> 2 <span style="color:#ff7b72;font-weight:700">:</span> <span style="color:#ff7b72;font-weight:700">((</span>n <span style="color:#ff7b72;font-weight:700">&gt;&gt;&gt;</span> 1<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">&amp;</span> EVENMASK<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">+</span> 2<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>                    <span style="color:#ff7b72">while</span> <span style="color:#ff7b72;font-weight:700">(</span>ws<span style="color:#ff7b72;font-weight:700">[</span>i <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#ff7b72;font-weight:700">(</span>i <span style="color:#ff7b72;font-weight:700">+</span> step<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">&amp;</span> m<span style="color:#ff7b72;font-weight:700">]</span> <span style="color:#ff7b72;font-weight:700">!=</span> <span style="color:#79c0ff">null</span><span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>                        <span style="color:#ff7b72">if</span> <span style="color:#ff7b72;font-weight:700">(++</span>probes <span style="color:#ff7b72;font-weight:700">&gt;=</span> n<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>                            <span style="color:#8b949e;font-style:italic">// 这里用 copyOf 进行复制, 这段代码太难读了,以后再来分析吧
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>                            workQueues <span style="color:#ff7b72;font-weight:700">=</span> ws <span style="color:#ff7b72;font-weight:700">=</span> Arrays<span style="color:#ff7b72;font-weight:700">.</span>copyOf<span style="color:#ff7b72;font-weight:700">(</span>ws<span style="color:#ff7b72;font-weight:700">,</span> n <span style="color:#ff7b72;font-weight:700">&lt;&lt;=</span> 1<span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>                            m <span style="color:#ff7b72;font-weight:700">=</span> n <span style="color:#ff7b72;font-weight:700">-</span> 1<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>                            probes <span style="color:#ff7b72;font-weight:700">=</span> 0<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>                        <span style="color:#ff7b72;font-weight:700">}</span>
</span></span><span style="display:flex"><span>                    <span style="color:#ff7b72;font-weight:700">}</span>
</span></span><span style="display:flex"><span>                <span style="color:#ff7b72;font-weight:700">}</span>
</span></span><span style="display:flex"><span>                w<span style="color:#ff7b72;font-weight:700">.</span>hint <span style="color:#ff7b72;font-weight:700">=</span> s<span style="color:#ff7b72;font-weight:700">;</span>                           <span style="color:#8b949e;font-style:italic">// use as random seed
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>                w<span style="color:#ff7b72;font-weight:700">.</span>config <span style="color:#ff7b72;font-weight:700">=</span> i <span style="color:#ff7b72;font-weight:700">|</span> mode<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>                w<span style="color:#ff7b72;font-weight:700">.</span>scanState <span style="color:#ff7b72;font-weight:700">=</span> i<span style="color:#ff7b72;font-weight:700">;</span>                      <span style="color:#8b949e;font-style:italic">// publication fence
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>                ws<span style="color:#ff7b72;font-weight:700">[</span>i<span style="color:#ff7b72;font-weight:700">]</span> <span style="color:#ff7b72;font-weight:700">=</span> w<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72;font-weight:700">}</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">}</span> <span style="color:#ff7b72">finally</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>            unlockRunState<span style="color:#ff7b72;font-weight:700">(</span>rs<span style="color:#ff7b72;font-weight:700">,</span> rs <span style="color:#ff7b72;font-weight:700">&amp;</span> <span style="color:#ff7b72;font-weight:700">~</span>RSLOCK<span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72;font-weight:700">}</span>
</span></span><span style="display:flex"><span>        wt<span style="color:#ff7b72;font-weight:700">.</span>setName<span style="color:#ff7b72;font-weight:700">(</span>workerNamePrefix<span style="color:#ff7b72;font-weight:700">.</span>concat<span style="color:#ff7b72;font-weight:700">(</span>Integer<span style="color:#ff7b72;font-weight:700">.</span>toString<span style="color:#ff7b72;font-weight:700">(</span>i <span style="color:#ff7b72;font-weight:700">&gt;&gt;&gt;</span> 1<span style="color:#ff7b72;font-weight:700">)));</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">return</span> w<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72;font-weight:700">}</span>
</span></span></code></pre></div><p><img alt="img" loading="lazy" src="forkJoin.assets/1363696-20200507171234445-1579744101.jpg"/></p><h2 id="25-runstate">2.5 runState<a aria-hidden="true" class="anchor" hidden="" href="#25-runstate">#</a></h2><p>ForkJoinPool的运行状态。<strong>SHUTDOWN</strong>状态用负数表示，其他用2的幂次表示。</p><h2 id="总结">总结<a aria-hidden="true" class="anchor" hidden="" href="#总结">#</a></h2><p>对于一个 new ForkJoinPool()，执行任务全流程如下：</p><ul><li><p>ForkJoinPool 初始化 parallelism size = cpu 逻辑核心数，没有队列，没有线程；</p></li><li><p>向 ForkJoinPool 提交一个任务；</p></li><li><p>初始化队列数组，容量为 2 * Max { parallelism size, 2 ^ n }；</p></li><li><p>创建一个没有线程的队列，容量为 2 ^ 13，随机放在队列数组的某一个偶数索引处；</p></li><li><p>任务存入这个队列索引值为 2 ^ 12 处；</p></li><li><p>再创建一个有线程的队列，容量为 2 ^ 13，随机放在队列数组的某一个奇数索引处；</p></li><li><p>线程启动；</p></li><li><p>线程从随机一个队列开始，遍历所有队列，最终扫描找到前面提交的任务，并从其所在队列取出；</p></li><li><p>线程执行任务，拆分出两个子任务；</p><ul><li>如果用 invokeAll 提交，则一个进入线程所在队列，另一个直接在线程里执行；</li><li>如果用 fork 提交，则两个都进入线程所在队列；</li></ul></li><li><p>提交的子任务触发创建新的线程，及与其对应的队列，还是在奇数索引处；</p></li><li><p>提交的子任务可能仍然被当前线程执行，可能被其它线程窃取；</p></li><li><p>线程在子任务处 join，join 期间会尝试从窃取自己任务的线程那里窃取任务执行；</p><ul><li>优先窃取队列底部；</li><li>队列没有任务则窃取其正在 join 的任务；</li><li>还没有则阻塞自己等待被唤醒，在阻塞之前会补偿一个活跃线程；</li></ul></li><li><p>提交的子任务不管被哪个线程执行，仍会重复上述拆分、提交、窃取、阻塞流程；</p></li><li><p>当任务被拆分的足够细，则会真正开始计算；</p></li><li><p>计算完成从递归一层一层返回；</p></li><li><p>最终所有子任务都完成，得到结果；</p></li><li><p>如果不再提交任务，所有线程扫描不到任务进入 inactive 状态；</p></li><li><p>最终，所有线程销毁，所有奇数索引位的队列回收，ForkJoinPool 中只剩下一个最初创建的在偶数索引位的队列。</p></li></ul><p><a href="https://www.cnblogs.com/dengzy/p/5808170.html" rel="noopener" target="_blank">thread_fork/join并发框架2 - dengzy - 博客园 (cnblogs.com)</a></p><p>[<a href="https://blog.csdn.net/mr_zhuqiang/article/details/48300229" rel="noopener" target="_blank">笔记][Java7并发编程实战手册]5.Fork＼Join(Java1.7新特性)框架_代码有毒的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/281875848" rel="noopener" target="_blank">Java并发系列（12）——ForkJoin框架源码解析（上） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/281896040" rel="noopener" target="_blank">Java并发系列（12）——ForkJoin框架源码解析（下） - 知乎 (zhihu.com)</a></p></div><footer class="post-footer"><ul class="post-tags"><li><a href="https://xiaokunji.com/zh/tags/%E5%B9%B6%E5%8F%91.html">并发</a></li><li><a href="https://xiaokunji.com/zh/tags/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html">java及其框架</a></li></ul><nav class="paginav"><a class="prev" href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/springBoot/filter.html"><span class="title">« 上一页</span><br/><span>filter</span></a>
<a class="next" href="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git%E5%92%8Csvn.html"><span class="title">下一页 »</span><br/><span>git和svn</span></a></nav></footer></article></main><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><footer class="footer"><span>Copyright
©
-2023
<a href="https://xiaokunji.com/zh/" style="color:#939393">米二</a>
All Rights Reserved</span>
<span id="busuanzi_container"><span class="fa fa-user">用户数:</span><span id="busuanzi_value_site_uv"></span>
<span class="fa fa-eye">访问数:</span><span id="busuanzi_value_site_pv"></span></span></footer><a accesskey="g" aria-label="go to top" class="top-link" href="#top" id="top-link" title="Go to Top (Alt + G)"><svg fill="currentcolor" viewbox="0 0 12 6" xmlns="http://www.w3.org/2000/svg"><path d="M12 6H0l6-6z"></path></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>