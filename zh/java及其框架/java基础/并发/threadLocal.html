<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ThreadLocal原理以及常见问题 | 米二</title><meta name=keywords content=" 1. ThreadLocal是什么？, 2. ThreadLocal的具体实现, 2.1 ThreadLocal结构  , 2.2 具体实现, 2.3 引用关系, 2.3.1 threadLocal引用关系, 2.3.2 扩展, 3. 源码解读, 3.1 从set方法开始, 3.2 ThreadLocal中的get(), 3.3 ThreadLocalMap中的remove(), 4. 内存泄露, 4.1 ThreadLocal 内存泄漏的原因, 4.2 ThreadLocal正确的使用方法, 4.3 总结, 5. 使用场景, 5.1 场景一：代替参数的显式传递, 5.2 场景二：解决线程安全问题, 5.3 场景三：全局存储用户信息, 6. 实战, 6.1 代码, 6.2 异常处理, 6.2.1 feign调用丢失请求头, 6.2.2 多线程中丢失请求头, 7. 扩展, 7.1 InheritableThreadLocal, 7.2 TransmittableThreadLocal(TTL)"><meta name=description content="ThreadLocal原理"><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/threadLocal.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/threadLocal.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="ThreadLocal原理以及常见问题"><meta property="og:description" content="ThreadLocal原理"><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/threadLocal.html"><meta property="article:section" content="java及其框架"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-04T05:49:41+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="ThreadLocal原理以及常见问题"><meta name=twitter:description content="ThreadLocal原理"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"ThreadLocal原理以及常见问题","item":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/threadLocal.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ThreadLocal原理以及常见问题","name":"ThreadLocal原理以及常见问题","description":"ThreadLocal原理","keywords":[" 1. ThreadLocal是什么？"," 2. ThreadLocal的具体实现"," 2.1 ThreadLocal结构  "," 2.2 具体实现"," 2.3 引用关系"," 2.3.1 threadLocal引用关系"," 2.3.2 扩展"," 3. 源码解读"," 3.1 从set方法开始"," 3.2 ThreadLocal中的get()"," 3.3 ThreadLocalMap中的remove()"," 4. 内存泄露"," 4.1 ThreadLocal 内存泄漏的原因"," 4.2 ThreadLocal正确的使用方法"," 4.3 总结"," 5. 使用场景"," 5.1 场景一：代替参数的显式传递"," 5.2 场景二：解决线程安全问题"," 5.3 场景三：全局存储用户信息"," 6. 实战"," 6.1 代码"," 6.2 异常处理"," 6.2.1 feign调用丢失请求头"," 6.2.2 多线程中丢失请求头"," 7. 扩展"," 7.1 InheritableThreadLocal"," 7.2 TransmittableThreadLocal(TTL)"],"articleBody":"[toc]\n1. ThreadLocal是什么？ 从名字我们就可以看到ThreadLocal 叫做本地线程变量，意思是说，ThreadLocal 中填充的的是当前线程的变量，该变量对其他线程而言是封闭且隔离的，ThreadLocal 为变量在每个线程中创建了一个副本，这样每个线程都可以访问自己内部的副本变量。\n简单实用\n@Test public void testThreadLocal() { ThreadLocal\u003cString\u003e local = new ThreadLocal\u003c\u003e(); IntStream.range(0, 10) .forEach(i -\u003e new Thread(() -\u003e { local.set(Thread.currentThread().getName() + \":\" + i); System.out.println(\"线程：\" + Thread.currentThread().getName() + \",local:\" + local.get()); }).start() ); } 输出结果： 线程：Thread-0,local:Thread-0:0 线程：Thread-1,local:Thread-1:1 线程：Thread-2,local:Thread-2:2 线程：Thread-3,local:Thread-3:3 线程：Thread-4,local:Thread-4:4 线程：Thread-5,local:Thread-5:5 线程：Thread-6,local:Thread-6:6 线程：Thread-7,local:Thread-7:7 线程：Thread-8,local:Thread-8:8 线程：Thread-9,local:Thread-9:9 2. ThreadLocal的具体实现 2.1 ThreadLocal结构 每一个线程都有一个 ThreadLocalMap ； 该 Map 底层由 Entry 数组构成，含有多个 Entry ； Entry 中 key 为 ThreadLocal 的弱引用， value 为我们保存的值 线程下的threadLocalMap\npublic class Thread implements Runnable { /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; /* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. */ ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; } 2.2 具体实现 从结构可以看出, 每个线程在向ThreadLocal里塞值的时候，其实都是向自己所持有的ThreadLocalMap里塞入数据；读的时候同理，首先从自己线程中取出自己持有的ThreadLocalMap，然后再根据ThreadLocal引用作为key取出value，基于以上描述，ThreadLocal实现了变量的线程隔离（当然，毕竟变量其实都是从自己当前线程实例中取出来的）。\n所以在上面的案例中, 会生成10个map, 每个map中就只有一个元素, key都是local变量, value是线程名称\n由此看出 , threadLocal底层使用map结构存储信息, key为当前的线程下的threadLocal对象, value 是我们的业务值\n它与hashMap有很多相似之处, 比如 扩展因子, 初始化大小等等, 但是threadLocal解决hash冲突使用的线性探测\n解决哈希冲突的四种方法 1.开放地址方法(再散列法)\n可以通俗理解为所有的地址都对所有的数值开放，而不是链式地址法的封闭方式，一个数值固定在一个索引地址位置。p1=hash(key)如果冲突就在p1地址的基础上+1或者散列处理，p2=hash(p1)….\n(1）线性探测\n按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上往后加一个单位，直至不发生哈希冲突。\n（2）再平方探测\n按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上先加1的平方个单位，若仍然存在则加1的平方个单位。随之是2的平方，3的平方等等。直至不发生哈希冲突。\n和线性探测相比就是改变探测了步长。因为如果都是+1来探测在数据量比较大的情况下，效率会很差。\n2.链式地址法\n对于相同的值，使用链表进行连接。使用数组存储每一个链表。（HashMap的哈希冲突解决方法）\n3.建立公共溢出区\n建立公共溢出区存储所有哈希冲突的数据。\n4.再哈希法\n对于冲突的哈希值再次进行哈希处理，直至没有哈希冲突。\n一文理解哈希冲突四种解决方法 - 简书 (jianshu.com) 2.3 引用关系 2.3.1 threadLocal引用关系 引用关系如上图所示：\n在整个引用链路中，只有 ThreadLocal 是采用了弱引用的方式进行声明的。\n2.3.2 扩展 Java 中引用有四种方式。\n强引用： 通过 new 关键字产生的引用关系，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象；\n软引用： SoftReference 内存空间不足时，发生GC, 垃圾回收器就会回收它, 可用来实现内存敏感的高速缓存。\n弱引用： 声明时，通过 WeakReference 包裹，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。\n虚引用：虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。\nJava中提供这四种引用类型主要有两个目的 ：\n可以让程序员通过代码的方式决定某些对象的生命周期。 有利于JVM进行垃圾回收。 jvm内存回收前提 JVM 垃圾回收详解-引用类型 | JavaGuide 3. 源码解读 3.1 从set方法开始 因为set是线程级别的, 所有的操作都在当前线程下, 所以set操作本身就是线程安全的\nThreadLocal.set(T value)\npublic void set(T value) { Thread t = Thread.currentThread(); // 获取当前线程 ThreadLocalMap map = getMap(t);// 获取当前线程的ThreadLocalMap if (map != null) map.set(this, value);// map不为空则调用map的set方法 else createMap(t, value);// map为空则调用createMap方法 } 先看看 map 为空时， createMap 方法是怎么创建 map 的。\nThreadLocal.createMap(Thread t, T firstValue)\nvoid createMap(Thread t, T firstValue) { // 为传入的线程实例化一个map，传入了自身的引用 t.threadLocals = new ThreadLocalMap(this, firstValue); } /** * 构造一个最初包含 (firstKey, firstValue) 的新映射。 * ThreadLocalMaps 是惰性构建的，所以我们只有在至少有一个条目可以放入时才创建一个。 */ ThreadLocalMap(ThreadLocal\u003c?\u003e firstKey, Object firstValue) { table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode \u0026 (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); } 该构造方法主要做了以下操作：\n创建一个默认长度的 Entry 数组 计算出传入的 ThreadLocal 应在数组中的位置 实例化 Entry 放到对应位置上 ThreadLocalMap 元素数置为1 设置要调整大小的下一个值 我们看看 ThreadLocalMap 的基础信息；\n/** * 初始容量 - 必须是 2 的幂次方 */ private static final int INITIAL_CAPACITY = 16; /** * table,长度必须为 2 的幂次方 */ private Entry[] table; /** * table中元素的个数 */ private int size = 0; /** * 要调整大小的下一个大小值。 */ private int threshold; // 默认值为 0 /** * Entry对象继承了弱引用(当发生垃圾回收时就会回收) */ static class Entry extends WeakReference\u003cThreadLocal\u003c?\u003e\u003e { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal\u003c?\u003e k, Object v) { super(k); value = v; } } 主要说一下计算索引，firstKey.threadLocalHashCode \u0026 (INITIAL_CAPACITY - 1)。\n关于\u0026 (INITIAL_CAPACITY - 1),这是取模的一种方式，对于2的幂作为模数取模，用此代替%(2^n)，这也就是为啥容量必须为2的冥，在这个地方也得到了解答，至于为什么可以这样这里不过多解释，原理很简单。\n关于firstKey.threadLocalHashCode：\nprivate final int threadLocalHashCode = nextHashCode(); private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; 定义了一个AtomicInteger类型，每次获取当前值并加上HASH_INCREMENT，HASH_INCREMENT = 0x61c88647,关于这个值和斐波那契散列有关，其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里, 也就是Entry[] table中。\n常见的散列方法是取模散列, 而斐波那契散列是另一种散列方法\n从 ThreadLocal 的实现看散列算法 - 知乎 (zhihu.com) 再看回set方法\nThreadLocalMap.set(ThreadLocal\u003c?\u003e key, Object value)\nThreadLocalMap使用线性探测法来解决哈希冲突，线性探测法的地址增量di = 1, 2, … , m-1，其中，i为探测次数。该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。假设当前table长度为16，也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致，那么就发生了hash冲突，这个时候将14加1得到15，取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0],以此类推，直到可以插入。所以 可以把table看成一个环形数组。\n在set的时候, 会去判断 entry==null 和 key==null的哈希槽, 并删除这些槽位, 由于使用线性探测方式, 还会挪动冲突的key的位置, 使得相同key紧凑一起\nprivate void set(ThreadLocal\u003c?\u003e key, Object value) { // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; // 获取ThreadLocal的hashCode，计算索引位置 int i = key.threadLocalHashCode \u0026 (len-1); // 该索引位置上是否有元素，如果有元素的话就进行线性探测 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal\u003c?\u003e k = e.get(); // 说明该key已经存在，则覆盖旧值 if (k == key) { e.value = value; return; } /** * table[i]上的key为空，说明被回收了（上面的弱引用中提到过）。 * 这个时候说明改table[i]可以重新使用，用新的key-value将其替换,并删除其他无效的entry */ if (k == null) { replaceStaleEntry(key, value, i); return; } } // 该索引位置上没有元素，则新建Entry tab[i] = new Entry(key, value); int sz = ++size; // 不需要清理 空哈希槽或者槽key为null的， 并且大于等于扩容值，则进行rehash， if (!cleanSomeSlots(i, sz) \u0026\u0026 sz \u003e= threshold) // 默认16，以2的倍数扩容 rehash(); } /**java /** * 获取环形数组的下一个索引 */ private static int nextIndex(int i, int len) { return ((i + 1 \u003c len) ? i + 1 : 0); } /** * 获取环形数组的上一个索引 */ private static int prevIndex(int i, int len) { return ((i - 1 \u003e= 0) ? i - 1 : len - 1); } replaceStaleEntry(ThreadLocal\u003c?\u003e key, Object value, int staleSlot)\n// 好复杂, 看看网上文章,以后深入了解吧\nThreadLocal源码分析 - 简书 (jianshu.com) 3.2 ThreadLocal中的get() public T get() { //同set方法类似获取对应线程中的ThreadLocalMap实例 Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } //为空返回初始化值 return setInitialValue(); } /** * 初始化设值的方法，可以被子类覆盖。 */ protected T initialValue() { return null; } private T setInitialValue() { //获取初始化值，默认为null(如果没有子类进行覆盖) T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //不为空不用再初始化，直接调用set操作设值 if (map != null) map.set(this, value); else //第一次初始化，createMap在上面介绍set()的时候有介绍过。 createMap(t, value); return value; } ThreadLocalMap中的getEntry()\nprivate ThreadLocal.ThreadLocalMap.Entry getEntry(ThreadLocal\u003c?\u003e key) { //根据key计算索引，获取entry int i = key.threadLocalHashCode \u0026 (table.length - 1); ThreadLocal.ThreadLocalMap.Entry e = table[i]; if (e != null \u0026\u0026 e.get() == key) return e; else return getEntryAfterMiss(key, i, e); } /** * 通过直接计算出来的key找不到对于的value的时候适用这个方法. */ private ThreadLocal.ThreadLocalMap.Entry getEntryAfterMiss(ThreadLocal\u003c?\u003e key, int i, ThreadLocal.ThreadLocalMap.Entry e) { ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; while (e != null) { ThreadLocal\u003c?\u003e k = e.get(); if (k == key) return e; if (k == null) //清除无效的entry expungeStaleEntry(i); else //基于线性探测法向后扫描 i = nextIndex(i, len); e = tab[i]; } return null; } 3.3 ThreadLocalMap中的remove() private void remove(ThreadLocal\u003c?\u003e key) { ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; //计算索引 int i = key.threadLocalHashCode \u0026 (len-1); //进行线性探测，查找正确的key for (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { //调用weakrefrence的clear()清除引用 e.clear(); //连续段清除 expungeStaleEntry(i); return; } } } 4. 内存泄露 4.1 ThreadLocal 内存泄漏的原因 从上图中可以看出，hreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部强引用时，Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强引用，只有thead线程退出以后,value的强引用链条才会断掉。\n但如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：\nThread Ref -\u003e Thread -\u003e ThreaLocalMap -\u003e Entry -\u003e value\n永远无法回收，造成内存泄漏。, 所以泄露的是value值\n4.2 ThreadLocal正确的使用方法 每次使用完ThreadLocal都调用它的remove()方法清除数据 其实调用set()和get() 都有可能也会清除数据\nThreadLocal会在以下过程中清理过期节点：\n调用set()方法时，采样清理、全量清理，扩容时还会继续检查。 调用get()方法，没有直接命中，向后环形查找时。 调用remove()时，除了清理当前Entry，还会向后继续清理。 使用ThreadLocal时，一般建议将其声明为static final的，避免频繁创建ThreadLocal实例。 4.3 总结 由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。\n但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()的时候会被清除。\n因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。\nThreadLocal的内存泄露？什么原因？如何避免？ - 知乎 (zhihu.com) 5. 使用场景 5.1 场景一：代替参数的显式传递 当我们在写API接口的时候，通常Controller层会接受来自前端的入参，当这个接口功能比较复杂的时候，可能我们调用的Service层内部还调用了 很多其他的很多方法，通常情况下，我们会在每个调用的方法上加上需要传递的参数。\n但是如果我们将参数存入ThreadLocal中，那么就不用显式的传递参数了，而是只需要ThreadLocal中获取即可。\n这个场景其实使用的比较少，一方面显式传参比较容易理解，另一方面我们可以将多个参数封装为对象去传递。\n5.2 场景二：解决线程安全问题 在Spring的Web项目中，我们通常会将业务分为Controller层，Service层，Dao层， 我们都知道@Autowired注解默认使用单例模式，那么不同请求线程进来之后，由于Dao层使用单例，那么负责数据库连接的Connection也只有一个， 如果每个请求线程都去连接数据库，那么就会造成线程不安全的问题，Spring是如何解决这个问题的呢？\n在Spring项目中Dao层中装配的Connection肯定是线程安全的，其解决方案就是采用ThreadLocal方法，当每个请求线程使用Connection的时候， 都会从ThreadLocal获取一次，如果为null，说明没有进行过数据库连接，连接后存入ThreadLocal中，如此一来，每一个请求线程都保存有一份 自己的Connection。于是便解决了线程安全问题\nThreadLocal在设计之初就是为解决并发问题而提供一种方案，每个线程维护一份自己的数据，达到线程隔离的效果。\n5.3 场景三：全局存储用户信息 在现在的系统设计中，前后端分离已基本成为常态，分离之后如何获取用户信息就成了一件麻烦事，通常在用户登录后， 用户信息会保存在Session或者Token中。这个时候，我们如果使用常规的手段去获取用户信息会很费劲，拿Session来说，我们要在接口参数中加上HttpServletRequest对象，然后调用 getSession方法，且每一个需要用户信息的接口都要加上这个参数，才能获取Session，这样实现就很麻烦了。\n在实际的系统设计中，我们肯定不会采用上面所说的这种方式，而是使用ThreadLocal，我们会选择在拦截器的业务中， 获取到保存的用户信息，然后存入ThreadLocal，那么当前线程在任何地方如果需要拿到用户信息都可以使用ThreadLocal的get()方法\n(异步程序中ThreadLocal是不可靠的, 因为threadLocal是线程级别的, 所以只要开了新线程都会丢失信息\n例如, 使用了线程池, future, fegin调用 就会丢失threadlocal里的数据(除非threadLocal是全局的)\n6. 实战 6.1 代码 具体实现流程：\n在登录业务代码中，当用户登录成功时，生成一个登录凭证存储到redis中，将凭证中的字符串保存在cookie中返回给客户端。 使用一个拦截器拦截请求，从cookie中获取凭证字符串与redis中的凭证进行匹配，获取用户信息，将用户信息存储到ThreadLocal中，在本次请求中持有用户信息，即可在后续操作中使用到用户信息。 定义工具类操作[ThreadLocal]（存放，获取，删除用户信息）\npublic class ThreadLocalUtil { /** * 保存用户对象的ThreadLocal 在拦截器操作 添加、删除相关用户数据 */ private static final ThreadLocal\u003cFeginUser\u003e userThreadLocal = new ThreadLocal\u003cFeginUser\u003e(); /** * 添加当前登录用户方法 在拦截器方法执行前调用设置获取用户 * @param user */ public static void addCurrentUser(FeginUser user){ userThreadLocal.set(user); } /** * 获取当前登录用户方法 */ public static FeginUser getCurrentUser(){ return userThreadLocal.get(); } /** * 删除当前登录用户方法 在拦截器方法执行后 移除当前用户对象 */ public static void remove(){ userThreadLocal.remove(); } } 拦截器\n@Component @Slf4j public class UserInfoInterceptor implements HandlerInterceptor { @Autowired private UserInfoUtil userInfoUtil; /** * 请求执行前执行的，将用户信息放入ThreadLocal * @param request * @param response * @param handler * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { FeginUser user; try{ user = userInfoUtil.getUser(request); }catch (CustomException e){ log.info(\"***************************用户未登录， ThreadLocal无信息***************************\"); return true; } if (null!=user) { log.info(\"***************************用户已登录，用户信息放入ThreadLocal***************************\"); ThreadLocalUtil.addCurrentUser(user); return true; } log.info(\"***************************用户未登录， ThreadLocal无信息***************************\"); return true; } /** * 接口访问结束后，从ThreadLocal中删除用户信息 * @param request * @param response * @param handler * @param ex * @throws Exception */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { log.info(\"***************************接口调用结束， 从ThreadLocal删除用户信息***************************\"); ThreadLocalUtil.remove(); } 6.2 异常处理 6.2.1 feign调用丢失请求头 从请求头中获取登录token, 会有个问题, 如果上游是fegin调用, 则请求头会丢失, 所以需要在fegin调用时手动设置token, 因为feign调用会使用新的http请求且不会携带原来http的header信息\n@Bean public RequestInterceptor requestInterceptor() { //处理feign远程调用丢失请求头问题 return template -\u003e { HttpRequestUtil.getHttpHeader(Constant.AUTHORIZATION) .ifPresent(auth -\u003e template.header(Constant.AUTHORIZATION, auth)); HttpRequestUtil.getHttpHeader(Constant.POWER_MENU_ID) .ifPresent(auth -\u003e template.header(Constant.POWER_MENU_ID, auth)); HttpRequestUtil.getHttpHeader(Constant.X_FLAG) .ifPresent(auth -\u003e template.header(Constant.X_FLAG, auth)); HttpRequestUtil.getHttpHeader(Constant.PLATFORM_FLAG) .ifPresent(auth -\u003e template.header(Constant.PLATFORM_FLAG, auth)); }; } 6.2.2 多线程中丢失请求头 因为threadLocal是线程内部的, 使用多线程后threadLocal会不再有数据\n解决方案:\n手动为子线程里的requst设置请求头 临时存储方案, 将threadLocal中的数据在子线程中再设置一遍 获取用户信息工具类 spring security 框架默认也没有解决\nspring security 如何在子线程中获取父线程中的用户认证信息（更改安全策略） - precedeforetime - 博客园 (cnblogs.com) 7. 扩展 7.1 InheritableThreadLocal InheritableThreadLocal类继承并重写了ThreadLocal的3个函数：\npublic class InheritableThreadLocal\u003cT\u003e extends ThreadLocal\u003cT\u003e { /** * 该函数在父线程创建子线程，向子线程复制InheritableThreadLocal变量时使用 */ protected T childValue(T parentValue) { return parentValue; } /** * 由于重写了getMap，操作InheritableThreadLocal时， * 将只影响Thread类中的inheritableThreadLocals变量， * 与threadLocals变量不再有关系 */ ThreadLocalMap getMap(Thread t) { return t.inheritableThreadLocals; } /** * 类似于getMap，操作InheritableThreadLocal时， * 将只影响Thread类中的inheritableThreadLocals变量， * 与threadLocals变量不再有关系 */ void createMap(Thread t, T firstValue) { t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue); } } 线程间传值实现原理\n线程初始化时将数据从 inheritableThreadLocals 取出并设置\nthread类\npublic class Thread implements Runnable { ......(其他源码) /* * 当前线程的ThreadLocalMap，主要存储该线程自身的ThreadLocal */ ThreadLocal.ThreadLocalMap threadLocals = null; /* * InheritableThreadLocal，自父线程集成而来的ThreadLocalMap， * 主要用于父子线程间ThreadLocal变量的传递 * 本文主要讨论的就是这个ThreadLocalMap */ ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; ......(其他源码) } 线程初始化\n/** * 默认情况下，设置inheritThreadLocals可传递 */ private void init(ThreadGroup g, Runnable target, String name, long stackSize) { init(g, target, name, stackSize, null, true); } /** * 初始化一个线程. * 此函数有两处调用， * 1、上面的 init()，不传AccessControlContext，inheritThreadLocals=true * 2、传递AccessControlContext，inheritThreadLocals=false */ private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { ......（其他代码） if (inheritThreadLocals \u0026\u0026 parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); ......（其他代码） } 所以只有线程创建时才会 执行值传递\n7.2 TransmittableThreadLocal(TTL) 阿里提供的 在使用线程池等会池化复用线程的执行组件情况下，提供ThreadLocal值的传递功能，解决异步执行时上下文传递的问题。\n其底层是 将数据从父线程中取出来, 再手动设置到子线程中\nTransmittableThreadLocal (TTL) ThreadLocal，一篇文章就够了 - 知乎 (zhihu.com) ThreadLocal源码分析 - 简书 (jianshu.com) ThreadLocal为什么会导致内存泄漏？ - Chen洋 - 博客园 (cnblogs.com) Java-ThreadLocal三种使用场景_用心去追梦的博客-CSDN博客_java threadlocal场景 ThreadLocal存放用户信息（springboot）_神都燕的博客-CSDN博客_threadlocal存储用户信息 InheritableThreadLocal详解 - 简书 (jianshu.com) ThreadLocal 面试夺命11连问_Young丶的博客-CSDN博客 ","wordCount":"8560","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-09-04T05:49:41.137225003Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/threadLocal.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80.html>java基础</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91.html>并发</a> <span>></span></ul></nav><h1 class=post-title>ThreadLocal原理以及常见问题</h1><div class=post-description>ThreadLocal原理</div><div class=post-meta>创建:&nbsp;<span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;更新:&nbsp;2023-09-04&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv>1</span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#1-threadlocal%e6%98%af%e4%bb%80%e4%b9%88 aria-label="1. ThreadLocal是什么？">1. ThreadLocal是什么？</a></li><li><a href=#2-threadlocal%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0 aria-label="2. ThreadLocal的具体实现">2. ThreadLocal的具体实现</a><ul><li><a href=#21-threadlocal%e7%bb%93%e6%9e%84 aria-label="2.1 ThreadLocal结构">2.1 ThreadLocal结构</a></li><li><a href=#22-%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0 aria-label="2.2 具体实现">2.2 具体实现</a></li><li><a href=#%e8%a7%a3%e5%86%b3%e5%93%88%e5%b8%8c%e5%86%b2%e7%aa%81%e7%9a%84%e5%9b%9b%e7%a7%8d%e6%96%b9%e6%b3%95 aria-label=解决哈希冲突的四种方法>解决哈希冲突的四种方法</a></li><li><a href=#23-%e5%bc%95%e7%94%a8%e5%85%b3%e7%b3%bb aria-label="2.3 引用关系">2.3 引用关系</a><ul><li><a href=#231-threadlocal%e5%bc%95%e7%94%a8%e5%85%b3%e7%b3%bb aria-label="2.3.1 threadLocal引用关系">2.3.1 threadLocal引用关系</a></li><li><a href=#232-%e6%89%a9%e5%b1%95 aria-label="2.3.2 扩展">2.3.2 扩展</a></li></ul></li></ul></li><li><a href=#3-%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb aria-label="3. 源码解读">3. 源码解读</a><ul><li><a href=#31-%e4%bb%8eset%e6%96%b9%e6%b3%95%e5%bc%80%e5%a7%8b aria-label="3.1 从set方法开始">3.1 从set方法开始</a></li><li><a href=#32-threadlocal%e4%b8%ad%e7%9a%84get aria-label="3.2 ThreadLocal中的get()">3.2 ThreadLocal中的get()</a></li><li><a href=#33-threadlocalmap%e4%b8%ad%e7%9a%84remove aria-label="3.3 ThreadLocalMap中的remove()">3.3 ThreadLocalMap中的remove()</a></li></ul></li><li><a href=#4-%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2 aria-label="4. 内存泄露">4. 内存泄露</a><ul><li><a href=#41-threadlocal-%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e7%9a%84%e5%8e%9f%e5%9b%a0 aria-label="4.1 ThreadLocal 内存泄漏的原因">4.1 ThreadLocal 内存泄漏的原因</a></li><li><a href=#42-threadlocal%e6%ad%a3%e7%a1%ae%e7%9a%84%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95 aria-label="4.2 ThreadLocal正确的使用方法">4.2 ThreadLocal正确的使用方法</a></li><li><a href=#43-%e6%80%bb%e7%bb%93 aria-label="4.3 总结">4.3 总结</a></li></ul></li><li><a href=#5-%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af aria-label="5. 使用场景">5. 使用场景</a><ul><li><a href=#51-%e5%9c%ba%e6%99%af%e4%b8%80%e4%bb%a3%e6%9b%bf%e5%8f%82%e6%95%b0%e7%9a%84%e6%98%be%e5%bc%8f%e4%bc%a0%e9%80%92 aria-label="5.1 场景一：代替参数的显式传递">5.1 场景一：代替参数的显式传递</a></li><li><a href=#52-%e5%9c%ba%e6%99%af%e4%ba%8c%e8%a7%a3%e5%86%b3%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e9%97%ae%e9%a2%98 aria-label="5.2 场景二：解决线程安全问题">5.2 场景二：解决线程安全问题</a></li><li><a href=#53-%e5%9c%ba%e6%99%af%e4%b8%89%e5%85%a8%e5%b1%80%e5%ad%98%e5%82%a8%e7%94%a8%e6%88%b7%e4%bf%a1%e6%81%af aria-label="5.3 场景三：全局存储用户信息">5.3 场景三：全局存储用户信息</a></li></ul></li><li><a href=#6-%e5%ae%9e%e6%88%98 aria-label="6. 实战">6. 实战</a><ul><li><a href=#61-%e4%bb%a3%e7%a0%81 aria-label="6.1 代码">6.1 代码</a></li><li><a href=#62-%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86 aria-label="6.2 异常处理">6.2 异常处理</a><ul><li><a href=#621-feign%e8%b0%83%e7%94%a8%e4%b8%a2%e5%a4%b1%e8%af%b7%e6%b1%82%e5%a4%b4 aria-label="6.2.1 feign调用丢失请求头">6.2.1 feign调用丢失请求头</a></li><li><a href=#622-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e4%b8%ad%e4%b8%a2%e5%a4%b1%e8%af%b7%e6%b1%82%e5%a4%b4 aria-label="6.2.2 多线程中丢失请求头">6.2.2 多线程中丢失请求头</a></li></ul></li></ul></li><li><a href=#7-%e6%89%a9%e5%b1%95 aria-label="7. 扩展">7. 扩展</a><ul><li><a href=#71-inheritablethreadlocal aria-label="7.1 InheritableThreadLocal">7.1 InheritableThreadLocal</a></li><li><a href=#72-transmittablethreadlocalttl aria-label="7.2 TransmittableThreadLocal(TTL)">7.2 TransmittableThreadLocal(TTL)</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=1-threadlocal是什么>1. ThreadLocal是什么？<a hidden class=anchor aria-hidden=true href=#1-threadlocal是什么>#</a></h1><p>从名字我们就可以看到<code>ThreadLocal</code> 叫做本地线程变量，意思是说，<code>ThreadLocal</code> 中填充的的是当前线程的变量，该变量对其他线程而言是封闭且隔离的，<code>ThreadLocal</code> 为变量在每个线程中创建了一个副本，这样每个线程都可以访问自己内部的副本变量。</p><p><strong>简单实用</strong></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>testThreadLocal</span><span style=color:#ff7b72;font-weight:700>()</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;</span>String<span style=color:#ff7b72;font-weight:700>&gt;</span> local <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;&gt;();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        IntStream<span style=color:#ff7b72;font-weight:700>.</span>range<span style=color:#ff7b72;font-weight:700>(</span>0<span style=color:#ff7b72;font-weight:700>,</span> 10<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72;font-weight:700>.</span>forEach<span style=color:#ff7b72;font-weight:700>(</span>i <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#ff7b72>new</span> Thread<span style=color:#ff7b72;font-weight:700>(()</span> <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                            local<span style=color:#ff7b72;font-weight:700>.</span>set<span style=color:#ff7b72;font-weight:700>(</span>Thread<span style=color:#ff7b72;font-weight:700>.</span>currentThread<span style=color:#ff7b72;font-weight:700>().</span>getName<span style=color:#ff7b72;font-weight:700>()</span> <span style=color:#ff7b72;font-weight:700>+</span> <span style=color:#a5d6ff>&#34;:&#34;</span> <span style=color:#ff7b72;font-weight:700>+</span> i<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>                            System<span style=color:#ff7b72;font-weight:700>.</span>out<span style=color:#ff7b72;font-weight:700>.</span>println<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#a5d6ff>&#34;线程：&#34;</span> <span style=color:#ff7b72;font-weight:700>+</span> Thread<span style=color:#ff7b72;font-weight:700>.</span>currentThread<span style=color:#ff7b72;font-weight:700>().</span>getName<span style=color:#ff7b72;font-weight:700>()</span> <span style=color:#ff7b72;font-weight:700>+</span> <span style=color:#a5d6ff>&#34;,local:&#34;</span> <span style=color:#ff7b72;font-weight:700>+</span> local<span style=color:#ff7b72;font-weight:700>.</span>get<span style=color:#ff7b72;font-weight:700>());</span>
</span></span><span style=display:flex><span>                        <span style=color:#ff7b72;font-weight:700>}).</span>start<span style=color:#ff7b72;font-weight:700>()</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>输出结果<span style=color:#f85149>：</span>
</span></span><span style=display:flex><span>线程<span style=color:#f85149>：</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>0<span style=color:#ff7b72;font-weight:700>,</span>local<span style=color:#ff7b72;font-weight:700>:</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>0<span style=color:#ff7b72;font-weight:700>:</span>0
</span></span><span style=display:flex><span>线程<span style=color:#f85149>：</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>1<span style=color:#ff7b72;font-weight:700>,</span>local<span style=color:#ff7b72;font-weight:700>:</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>1<span style=color:#ff7b72;font-weight:700>:</span>1
</span></span><span style=display:flex><span>线程<span style=color:#f85149>：</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>2<span style=color:#ff7b72;font-weight:700>,</span>local<span style=color:#ff7b72;font-weight:700>:</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>2<span style=color:#ff7b72;font-weight:700>:</span>2
</span></span><span style=display:flex><span>线程<span style=color:#f85149>：</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>3<span style=color:#ff7b72;font-weight:700>,</span>local<span style=color:#ff7b72;font-weight:700>:</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>3<span style=color:#ff7b72;font-weight:700>:</span>3
</span></span><span style=display:flex><span>线程<span style=color:#f85149>：</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>4<span style=color:#ff7b72;font-weight:700>,</span>local<span style=color:#ff7b72;font-weight:700>:</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>4<span style=color:#ff7b72;font-weight:700>:</span>4
</span></span><span style=display:flex><span>线程<span style=color:#f85149>：</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>5<span style=color:#ff7b72;font-weight:700>,</span>local<span style=color:#ff7b72;font-weight:700>:</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>5<span style=color:#ff7b72;font-weight:700>:</span>5
</span></span><span style=display:flex><span>线程<span style=color:#f85149>：</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>6<span style=color:#ff7b72;font-weight:700>,</span>local<span style=color:#ff7b72;font-weight:700>:</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>6<span style=color:#ff7b72;font-weight:700>:</span>6
</span></span><span style=display:flex><span>线程<span style=color:#f85149>：</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>7<span style=color:#ff7b72;font-weight:700>,</span>local<span style=color:#ff7b72;font-weight:700>:</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>7<span style=color:#ff7b72;font-weight:700>:</span>7
</span></span><span style=display:flex><span>线程<span style=color:#f85149>：</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>8<span style=color:#ff7b72;font-weight:700>,</span>local<span style=color:#ff7b72;font-weight:700>:</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>8<span style=color:#ff7b72;font-weight:700>:</span>8
</span></span><span style=display:flex><span>线程<span style=color:#f85149>：</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>9<span style=color:#ff7b72;font-weight:700>,</span>local<span style=color:#ff7b72;font-weight:700>:</span>Thread<span style=color:#ff7b72;font-weight:700>-</span>9<span style=color:#ff7b72;font-weight:700>:</span>9
</span></span></code></pre></div><h1 id=2-threadlocal的具体实现>2. ThreadLocal的具体实现<a hidden class=anchor aria-hidden=true href=#2-threadlocal的具体实现>#</a></h1><h2 id=21-threadlocal结构>2.1 ThreadLocal结构<a hidden class=anchor aria-hidden=true href=#21-threadlocal结构>#</a></h2><p><img loading=lazy src=./threadLocal.assets/image-20220710170956658.png alt=image-20220710170956658></p><ol><li>每一个线程都有一个 ThreadLocalMap ；</li><li>该 Map 底层由 Entry 数组构成，含有多个 Entry ；</li><li>Entry 中 key 为 ThreadLocal 的弱引用， value 为我们保存的值</li></ol><p>线程下的threadLocalMap</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span> <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>Thread</span> <span style=color:#ff7b72>implements</span> Runnable <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>/* ThreadLocal values pertaining to this thread. This map is maintained
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * by the ThreadLocal class. */</span>
</span></span><span style=display:flex><span>    ThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>ThreadLocalMap threadLocals <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * InheritableThreadLocal values pertaining to this thread. This map is
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * maintained by the InheritableThreadLocal class.
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    ThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>ThreadLocalMap inheritableThreadLocals <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><h2 id=22-具体实现>2.2 具体实现<a hidden class=anchor aria-hidden=true href=#22-具体实现>#</a></h2><p>从结构可以看出, 每个线程在向ThreadLocal里塞值的时候，其实都是向自己所持有的ThreadLocalMap里塞入数据；读的时候同理，首先从自己线程中取出自己持有的ThreadLocalMap，然后再根据ThreadLocal引用作为key取出value，基于以上描述，ThreadLocal实现了变量的线程隔离（当然，毕竟变量其实都是从自己当前线程实例中取出来的）。</p><blockquote><p>所以在上面的案例中, 会生成10个map, 每个map中就只有一个元素, key都是<code>local</code>变量, value是线程名称</p></blockquote><p>由此看出 , threadLocal底层使用map结构存储信息, key为当前的线程下的threadLocal对象, value 是我们的业务值</p><p>它与hashMap有很多相似之处, 比如 扩展因子, 初始化大小等等, 但是threadLocal解决hash冲突使用的<strong>线性探测</strong></p><blockquote><h2 id=解决哈希冲突的四种方法>解决哈希冲突的四种方法<a hidden class=anchor aria-hidden=true href=#解决哈希冲突的四种方法>#</a></h2><p><strong>1.开放地址方法(再散列法)</strong></p><p>可以通俗理解为所有的地址都对所有的数值开放，而不是链式地址法的封闭方式，一个数值固定在一个索引地址位置。<strong>p1=hash(key)如果冲突就在p1地址的基础上+1或者散列处理</strong>，p2=hash(p1)&mldr;.</p><p>(1）线性探测</p><p>　　　按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上往后加一个单位，直至不发生哈希冲突。</p><p>（2）再平方探测</p><p>　　　按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上先加1的平方个单位，若仍然存在则加1的平方个单位。随之是2的平方，3的平方等等。直至不发生哈希冲突。</p><p><strong>和线性探测相比就是改变探测了步长</strong>。因为如果都是+1来探测在数据量比较大的情况下，效率会很差。</p><p><strong>2.链式地址法</strong></p><p>对于<strong>相同的值，使用链表进行连接</strong>。使用数组存储每一个链表。<strong>（HashMap的哈希冲突解决方法）</strong></p><p><strong>3.建立公共溢出区</strong></p><p>　　建立公共溢出区存储所有哈希冲突的数据。</p><p><strong>4.再哈希法</strong></p><p>　　对于冲突的哈希值再次进行哈希处理，直至没有哈希冲突。</p><p><a href=https://www.jianshu.com/p/a343dae4a818 target=_blank rel=noopener>一文理解哈希冲突四种解决方法 - 简书 (jianshu.com)</a></p></blockquote><h2 id=23-引用关系>2.3 引用关系<a hidden class=anchor aria-hidden=true href=#23-引用关系>#</a></h2><h3 id=231-threadlocal引用关系>2.3.1 threadLocal引用关系<a hidden class=anchor aria-hidden=true href=#231-threadlocal引用关系>#</a></h3><p><img loading=lazy src=./threadLocal.assets/image-20220710171226838.png alt=image-20220710171226838></p><p>引用关系如上图所示：</p><p>在整个引用链路中，只有 ThreadLocal 是采用了弱引用的方式进行声明的。</p><h3 id=232-扩展>2.3.2 扩展<a hidden class=anchor aria-hidden=true href=#232-扩展>#</a></h3><p>Java 中引用有四种方式。</p><p>强引用： 通过 <strong>new</strong> 关键字产生的引用关系，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象；</p><p>软引用： <strong>SoftReference</strong> 内存空间不足时，发生GC, 垃圾回收器就会回收它, 可用来实现内存敏感的高速缓存。</p><p>弱引用： 声明时，通过 <strong>WeakReference</strong> 包裹，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><p>虚引用：虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p><p>Java中提供这四种引用类型主要有两个目的 ：</p><ul><li>可以让程序员通过代码的方式决定某些对象的生命周期。</li><li>有利于JVM进行垃圾回收。</li></ul><p><a href=../JVM/%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6/%e5%9b%9e%e6%94%b6%e5%89%8d%e6%8f%90.html>jvm内存回收前提</a></p><p><a href=https://javaguide.cn/java/jvm/jvm-garbage-collection.html#%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b%e6%80%bb%e7%bb%93 target=_blank rel=noopener>JVM 垃圾回收详解-引用类型 | JavaGuide</a></p><h1 id=3-源码解读>3. 源码解读<a hidden class=anchor aria-hidden=true href=#3-源码解读>#</a></h1><h2 id=31-从set方法开始>3.1 从set方法开始<a hidden class=anchor aria-hidden=true href=#31-从set方法开始>#</a></h2><blockquote><p>因为set是线程级别的, 所有的操作都在当前线程下, 所以set操作本身就是线程安全的</p></blockquote><p><strong>ThreadLocal.set(T value)</strong></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>set</span><span style=color:#ff7b72;font-weight:700>(</span>T value<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>    Thread t <span style=color:#ff7b72;font-weight:700>=</span> Thread<span style=color:#ff7b72;font-weight:700>.</span>currentThread<span style=color:#ff7b72;font-weight:700>();</span> <span style=color:#8b949e;font-style:italic>// 获取当前线程
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    ThreadLocalMap map <span style=color:#ff7b72;font-weight:700>=</span> getMap<span style=color:#ff7b72;font-weight:700>(</span>t<span style=color:#ff7b72;font-weight:700>);</span><span style=color:#8b949e;font-style:italic>// 获取当前线程的ThreadLocalMap
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>map <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>    	map<span style=color:#ff7b72;font-weight:700>.</span>set<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#ff7b72>this</span><span style=color:#ff7b72;font-weight:700>,</span> value<span style=color:#ff7b72;font-weight:700>);</span><span style=color:#8b949e;font-style:italic>// map不为空则调用map的set方法
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>else</span>
</span></span><span style=display:flex><span>    	createMap<span style=color:#ff7b72;font-weight:700>(</span>t<span style=color:#ff7b72;font-weight:700>,</span> value<span style=color:#ff7b72;font-weight:700>);</span><span style=color:#8b949e;font-style:italic>// map为空则调用createMap方法
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p>先看看 map 为空时， createMap 方法是怎么创建 map 的。</p><p><strong>ThreadLocal.createMap(Thread t, T firstValue)</strong></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>createMap</span><span style=color:#ff7b72;font-weight:700>(</span>Thread t<span style=color:#ff7b72;font-weight:700>,</span> T firstValue<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>// 为传入的线程实例化一个map，传入了自身的引用
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    t<span style=color:#ff7b72;font-weight:700>.</span>threadLocals <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> ThreadLocalMap<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#ff7b72>this</span><span style=color:#ff7b72;font-weight:700>,</span> firstValue<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>* 构造一个最初包含 (firstKey, firstValue) 的新映射。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>* ThreadLocalMaps 是惰性构建的，所以我们只有在至少有一个条目可以放入时才创建一个。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>*/</span>
</span></span><span style=display:flex><span>ThreadLocalMap<span style=color:#ff7b72;font-weight:700>(</span>ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;?&gt;</span> firstKey<span style=color:#ff7b72;font-weight:700>,</span> Object firstValue<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>    table <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> Entry<span style=color:#ff7b72;font-weight:700>[</span>INITIAL_CAPACITY<span style=color:#ff7b72;font-weight:700>];</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> i <span style=color:#ff7b72;font-weight:700>=</span> firstKey<span style=color:#ff7b72;font-weight:700>.</span>threadLocalHashCode <span style=color:#ff7b72;font-weight:700>&amp;</span> <span style=color:#ff7b72;font-weight:700>(</span>INITIAL_CAPACITY <span style=color:#ff7b72;font-weight:700>-</span> 1<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    table<span style=color:#ff7b72;font-weight:700>[</span>i<span style=color:#ff7b72;font-weight:700>]</span> <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> Entry<span style=color:#ff7b72;font-weight:700>(</span>firstKey<span style=color:#ff7b72;font-weight:700>,</span> firstValue<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    size <span style=color:#ff7b72;font-weight:700>=</span> 1<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>    setThreshold<span style=color:#ff7b72;font-weight:700>(</span>INITIAL_CAPACITY<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p>该构造方法主要做了以下操作：</p><ol><li>创建一个默认长度的 Entry 数组</li><li>计算出传入的 ThreadLocal 应在数组中的位置</li><li>实例化 Entry 放到对应位置上</li><li>ThreadLocalMap 元素数置为1</li><li>设置要调整大小的下一个值</li></ol><p>我们看看 ThreadLocalMap 的基础信息；</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>* 初始容量 - 必须是 2 的幂次方
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>*/</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>private</span> <span style=color:#ff7b72>static</span> <span style=color:#ff7b72>final</span> <span style=color:#ff7b72>int</span> INITIAL_CAPACITY <span style=color:#ff7b72;font-weight:700>=</span> 16<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>* table,长度必须为 2 的幂次方
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>*/</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>private</span> Entry<span style=color:#ff7b72;font-weight:700>[]</span> table<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>* table中元素的个数
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>*/</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>private</span> <span style=color:#ff7b72>int</span> size <span style=color:#ff7b72;font-weight:700>=</span> 0<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>* 要调整大小的下一个大小值。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>*/</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>private</span> <span style=color:#ff7b72>int</span> threshold<span style=color:#ff7b72;font-weight:700>;</span> <span style=color:#8b949e;font-style:italic>// 默认值为 0
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>* Entry对象继承了弱引用(当发生垃圾回收时就会回收)
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>*/</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>static</span> <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>Entry</span> <span style=color:#ff7b72>extends</span> WeakReference<span style=color:#ff7b72;font-weight:700>&lt;</span>ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;?&gt;&gt;</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>/** The value associated with this ThreadLocal. */</span>
</span></span><span style=display:flex><span>    Object value<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>    Entry<span style=color:#ff7b72;font-weight:700>(</span>ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;?&gt;</span> k<span style=color:#ff7b72;font-weight:700>,</span> Object v<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>super</span><span style=color:#ff7b72;font-weight:700>(</span>k<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>        value <span style=color:#ff7b72;font-weight:700>=</span> v<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p>主要说一下计算索引，<code>firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1)</code>。</p><ul><li><p>关于<code>& (INITIAL_CAPACITY - 1)</code>,这是取模的一种方式，对于2的幂作为模数取模，用此代替<code>%(2^n)</code>，这也就是为啥容量必须为2的冥，在这个地方也得到了解答，至于为什么可以这样这里不过多解释，原理很简单。</p></li><li><p>关于<code>firstKey.threadLocalHashCode</code>：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#ff7b72>private</span> <span style=color:#ff7b72>final</span> <span style=color:#ff7b72>int</span> threadLocalHashCode <span style=color:#ff7b72;font-weight:700>=</span> nextHashCode<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>private</span> <span style=color:#ff7b72>static</span> <span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>nextHashCode</span><span style=color:#ff7b72;font-weight:700>()</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> nextHashCode<span style=color:#ff7b72;font-weight:700>.</span>getAndAdd<span style=color:#ff7b72;font-weight:700>(</span>HASH_INCREMENT<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>private</span> <span style=color:#ff7b72>static</span> AtomicInteger nextHashCode <span style=color:#ff7b72;font-weight:700>=</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>new</span> AtomicInteger<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>private</span> <span style=color:#ff7b72>static</span> <span style=color:#ff7b72>final</span> <span style=color:#ff7b72>int</span> HASH_INCREMENT <span style=color:#ff7b72;font-weight:700>=</span> 0x61c88647<span style=color:#ff7b72;font-weight:700>;</span>
</span></span></code></pre></div><p>定义了一个AtomicInteger类型，每次获取当前值并加上HASH_INCREMENT，<code>HASH_INCREMENT = 0x61c88647</code>,关于这个值和<code>斐波那契散列</code>有关，其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里, 也就是<code>Entry[] table</code>中。</p><blockquote><p>常见的散列方法是取模散列, 而斐波那契散列是另一种散列方法</p><p><a href=https://zhuanlan.zhihu.com/p/40515974 target=_blank rel=noopener>从 ThreadLocal 的实现看散列算法 - 知乎 (zhihu.com)</a></p></blockquote></li></ul><p>再看回set方法</p><p><strong>ThreadLocalMap.set(ThreadLocal key, Object value)</strong></p><blockquote><p>ThreadLocalMap使用<code>线性探测法</code>来解决哈希冲突，线性探测法的地址增量di = 1, 2, &mldr; , m-1，其中，i为探测次数。该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。假设当前table长度为16，也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致，那么就发生了hash冲突，这个时候将14加1得到15，取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0],以此类推，直到可以插入。所以 <code>可以把table看成一个环形数组</code>。</p><p>在set的时候, 会去判断 <code>entry==null</code> 和 <code>key==null</code>的哈希槽, 并删除这些槽位, 由于使用线性探测方式, 还会挪动冲突的key的位置, 使得相同key紧凑一起</p></blockquote><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#ff7b72>private</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>set</span><span style=color:#ff7b72;font-weight:700>(</span>ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;?&gt;</span> key<span style=color:#ff7b72;font-weight:700>,</span> Object value<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#8b949e;font-style:italic>// We don&#39;t use a fast path as with get() because it is at
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>            <span style=color:#8b949e;font-style:italic>// least as common to use set() to create new entries as
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>            <span style=color:#8b949e;font-style:italic>// it is to replace existing ones, in which case, a fast
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>            <span style=color:#8b949e;font-style:italic>// path would fail more often than not.
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>            Entry<span style=color:#ff7b72;font-weight:700>[]</span> tab <span style=color:#ff7b72;font-weight:700>=</span> table<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>int</span> len <span style=color:#ff7b72;font-weight:700>=</span> tab<span style=color:#ff7b72;font-weight:700>.</span>length<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>     <span style=color:#8b949e;font-style:italic>// 获取ThreadLocal的hashCode，计算索引位置
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>            <span style=color:#ff7b72>int</span> i <span style=color:#ff7b72;font-weight:700>=</span> key<span style=color:#ff7b72;font-weight:700>.</span>threadLocalHashCode <span style=color:#ff7b72;font-weight:700>&amp;</span> <span style=color:#ff7b72;font-weight:700>(</span>len<span style=color:#ff7b72;font-weight:700>-</span>1<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 该索引位置上是否有元素，如果有元素的话就进行线性探测
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>            <span style=color:#ff7b72>for</span> <span style=color:#ff7b72;font-weight:700>(</span>Entry e <span style=color:#ff7b72;font-weight:700>=</span> tab<span style=color:#ff7b72;font-weight:700>[</span>i<span style=color:#ff7b72;font-weight:700>];</span>
</span></span><span style=display:flex><span>                 e <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                 e <span style=color:#ff7b72;font-weight:700>=</span> tab<span style=color:#ff7b72;font-weight:700>[</span>i <span style=color:#ff7b72;font-weight:700>=</span> nextIndex<span style=color:#ff7b72;font-weight:700>(</span>i<span style=color:#ff7b72;font-weight:700>,</span> len<span style=color:#ff7b72;font-weight:700>)])</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;?&gt;</span> k <span style=color:#ff7b72;font-weight:700>=</span> e<span style=color:#ff7b72;font-weight:700>.</span>get<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 说明该key已经存在，则覆盖旧值
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>k <span style=color:#ff7b72;font-weight:700>==</span> key<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                    e<span style=color:#ff7b72;font-weight:700>.</span>value <span style=color:#ff7b72;font-weight:700>=</span> value<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>return</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>             * table[i]上的key为空，说明被回收了（上面的弱引用中提到过）。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>             * 这个时候说明改table[i]可以重新使用，用新的key-value将其替换,并删除其他无效的entry
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>             */</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>k <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                    replaceStaleEntry<span style=color:#ff7b72;font-weight:700>(</span>key<span style=color:#ff7b72;font-weight:700>,</span> value<span style=color:#ff7b72;font-weight:700>,</span> i<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>return</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 该索引位置上没有元素，则新建Entry
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>            tab<span style=color:#ff7b72;font-weight:700>[</span>i<span style=color:#ff7b72;font-weight:700>]</span> <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> Entry<span style=color:#ff7b72;font-weight:700>(</span>key<span style=color:#ff7b72;font-weight:700>,</span> value<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>int</span> sz <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>++</span>size<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>     <span style=color:#8b949e;font-style:italic>// 不需要清理 空哈希槽或者槽key为null的， 并且大于等于扩容值，则进行rehash，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>            <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(!</span>cleanSomeSlots<span style=color:#ff7b72;font-weight:700>(</span>i<span style=color:#ff7b72;font-weight:700>,</span> sz<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> sz <span style=color:#ff7b72;font-weight:700>&gt;=</span> threshold<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>                <span style=color:#8b949e;font-style:italic>// 默认16，以2的倍数扩容
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                rehash<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/**java
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>    /**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 获取环形数组的下一个索引
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>private</span> <span style=color:#ff7b72>static</span> <span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>nextIndex</span><span style=color:#ff7b72;font-weight:700>(</span><span style=color:#ff7b72>int</span> i<span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#ff7b72>int</span> len<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#ff7b72;font-weight:700>((</span>i <span style=color:#ff7b72;font-weight:700>+</span> 1 <span style=color:#ff7b72;font-weight:700>&lt;</span> len<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>?</span> i <span style=color:#ff7b72;font-weight:700>+</span> 1 <span style=color:#ff7b72;font-weight:700>:</span> 0<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 获取环形数组的上一个索引
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>private</span> <span style=color:#ff7b72>static</span> <span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>prevIndex</span><span style=color:#ff7b72;font-weight:700>(</span><span style=color:#ff7b72>int</span> i<span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#ff7b72>int</span> len<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#ff7b72;font-weight:700>((</span>i <span style=color:#ff7b72;font-weight:700>-</span> 1 <span style=color:#ff7b72;font-weight:700>&gt;=</span> 0<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>?</span> i <span style=color:#ff7b72;font-weight:700>-</span> 1 <span style=color:#ff7b72;font-weight:700>:</span> len <span style=color:#ff7b72;font-weight:700>-</span> 1<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p><strong>replaceStaleEntry(ThreadLocal key, Object value, int staleSlot)</strong></p><p>// 好复杂, 看看网上文章,以后深入了解吧</p><p><a href=https://www.jianshu.com/p/80866ca6c424 target=_blank rel=noopener>ThreadLocal源码分析 - 简书 (jianshu.com)</a></p><h2 id=32-threadlocal中的get>3.2 ThreadLocal中的get()<a hidden class=anchor aria-hidden=true href=#32-threadlocal中的get>#</a></h2><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span> T <span style=color:#d2a8ff;font-weight:700>get</span><span style=color:#ff7b72;font-weight:700>()</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>//同set方法类似获取对应线程中的ThreadLocalMap实例
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    Thread t <span style=color:#ff7b72;font-weight:700>=</span> Thread<span style=color:#ff7b72;font-weight:700>.</span>currentThread<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>    ThreadLocalMap map <span style=color:#ff7b72;font-weight:700>=</span> getMap<span style=color:#ff7b72;font-weight:700>(</span>t<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>map <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        ThreadLocalMap<span style=color:#ff7b72;font-weight:700>.</span>Entry e <span style=color:#ff7b72;font-weight:700>=</span> map<span style=color:#ff7b72;font-weight:700>.</span>getEntry<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#ff7b72>this</span><span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>e <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#d2a8ff;font-weight:700>@SuppressWarnings</span><span style=color:#ff7b72;font-weight:700>(</span><span style=color:#a5d6ff>&#34;unchecked&#34;</span><span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>            T result <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>(</span>T<span style=color:#ff7b72;font-weight:700>)</span>e<span style=color:#ff7b72;font-weight:700>.</span>value<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> result<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>//为空返回初始化值
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>return</span> setInitialValue<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * 初始化设值的方法，可以被子类覆盖。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>protected</span> T <span style=color:#d2a8ff;font-weight:700>initialValue</span><span style=color:#ff7b72;font-weight:700>()</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>   <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>private</span> T <span style=color:#d2a8ff;font-weight:700>setInitialValue</span><span style=color:#ff7b72;font-weight:700>()</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>//获取初始化值，默认为null(如果没有子类进行覆盖)
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    T value <span style=color:#ff7b72;font-weight:700>=</span> initialValue<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>    Thread t <span style=color:#ff7b72;font-weight:700>=</span> Thread<span style=color:#ff7b72;font-weight:700>.</span>currentThread<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>    ThreadLocalMap map <span style=color:#ff7b72;font-weight:700>=</span> getMap<span style=color:#ff7b72;font-weight:700>(</span>t<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>//不为空不用再初始化，直接调用set操作设值
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>map <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>        map<span style=color:#ff7b72;font-weight:700>.</span>set<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#ff7b72>this</span><span style=color:#ff7b72;font-weight:700>,</span> value<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>else</span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>//第一次初始化，createMap在上面介绍set()的时候有介绍过。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        createMap<span style=color:#ff7b72;font-weight:700>(</span>t<span style=color:#ff7b72;font-weight:700>,</span> value<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>return</span> value<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p><strong>ThreadLocalMap中的getEntry()</strong></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#ff7b72>private</span> ThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>ThreadLocalMap<span style=color:#ff7b72;font-weight:700>.</span>Entry <span style=color:#d2a8ff;font-weight:700>getEntry</span><span style=color:#ff7b72;font-weight:700>(</span>ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;?&gt;</span> key<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>//根据key计算索引，获取entry
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#ff7b72>int</span> i <span style=color:#ff7b72;font-weight:700>=</span> key<span style=color:#ff7b72;font-weight:700>.</span>threadLocalHashCode <span style=color:#ff7b72;font-weight:700>&amp;</span> <span style=color:#ff7b72;font-weight:700>(</span>table<span style=color:#ff7b72;font-weight:700>.</span>length <span style=color:#ff7b72;font-weight:700>-</span> 1<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>        ThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>ThreadLocalMap<span style=color:#ff7b72;font-weight:700>.</span>Entry e <span style=color:#ff7b72;font-weight:700>=</span> table<span style=color:#ff7b72;font-weight:700>[</span>i<span style=color:#ff7b72;font-weight:700>];</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>e <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>null</span> <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> e<span style=color:#ff7b72;font-weight:700>.</span>get<span style=color:#ff7b72;font-weight:700>()</span> <span style=color:#ff7b72;font-weight:700>==</span> key<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> e<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>else</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> getEntryAfterMiss<span style=color:#ff7b72;font-weight:700>(</span>key<span style=color:#ff7b72;font-weight:700>,</span> i<span style=color:#ff7b72;font-weight:700>,</span> e<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 通过直接计算出来的key找不到对于的value的时候适用这个方法.
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>private</span> ThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>ThreadLocalMap<span style=color:#ff7b72;font-weight:700>.</span>Entry <span style=color:#d2a8ff;font-weight:700>getEntryAfterMiss</span><span style=color:#ff7b72;font-weight:700>(</span>ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;?&gt;</span> key<span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#ff7b72>int</span> i<span style=color:#ff7b72;font-weight:700>,</span> ThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>ThreadLocalMap<span style=color:#ff7b72;font-weight:700>.</span>Entry e<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        ThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>ThreadLocalMap<span style=color:#ff7b72;font-weight:700>.</span>Entry<span style=color:#ff7b72;font-weight:700>[]</span> tab <span style=color:#ff7b72;font-weight:700>=</span> table<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>int</span> len <span style=color:#ff7b72;font-weight:700>=</span> tab<span style=color:#ff7b72;font-weight:700>.</span>length<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>while</span> <span style=color:#ff7b72;font-weight:700>(</span>e <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>            ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;?&gt;</span> k <span style=color:#ff7b72;font-weight:700>=</span> e<span style=color:#ff7b72;font-weight:700>.</span>get<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>k <span style=color:#ff7b72;font-weight:700>==</span> key<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>return</span> e<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>k <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>                <span style=color:#8b949e;font-style:italic>//清除无效的entry
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                expungeStaleEntry<span style=color:#ff7b72;font-weight:700>(</span>i<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>else</span>
</span></span><span style=display:flex><span>                <span style=color:#8b949e;font-style:italic>//基于线性探测法向后扫描
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                i <span style=color:#ff7b72;font-weight:700>=</span> nextIndex<span style=color:#ff7b72;font-weight:700>(</span>i<span style=color:#ff7b72;font-weight:700>,</span> len<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>            e <span style=color:#ff7b72;font-weight:700>=</span> tab<span style=color:#ff7b72;font-weight:700>[</span>i<span style=color:#ff7b72;font-weight:700>];</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><h2 id=33-threadlocalmap中的remove>3.3 ThreadLocalMap中的remove()<a hidden class=anchor aria-hidden=true href=#33-threadlocalmap中的remove>#</a></h2><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#ff7b72>private</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>remove</span><span style=color:#ff7b72;font-weight:700>(</span>ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;?&gt;</span> key<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        ThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>ThreadLocalMap<span style=color:#ff7b72;font-weight:700>.</span>Entry<span style=color:#ff7b72;font-weight:700>[]</span> tab <span style=color:#ff7b72;font-weight:700>=</span> table<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>int</span> len <span style=color:#ff7b72;font-weight:700>=</span> tab<span style=color:#ff7b72;font-weight:700>.</span>length<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>//计算索引
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#ff7b72>int</span> i <span style=color:#ff7b72;font-weight:700>=</span> key<span style=color:#ff7b72;font-weight:700>.</span>threadLocalHashCode <span style=color:#ff7b72;font-weight:700>&amp;</span> <span style=color:#ff7b72;font-weight:700>(</span>len<span style=color:#ff7b72;font-weight:700>-</span>1<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>//进行线性探测，查找正确的key
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#ff7b72>for</span> <span style=color:#ff7b72;font-weight:700>(</span>ThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>ThreadLocalMap<span style=color:#ff7b72;font-weight:700>.</span>Entry e <span style=color:#ff7b72;font-weight:700>=</span> tab<span style=color:#ff7b72;font-weight:700>[</span>i<span style=color:#ff7b72;font-weight:700>];</span>
</span></span><span style=display:flex><span>             e <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>             e <span style=color:#ff7b72;font-weight:700>=</span> tab<span style=color:#ff7b72;font-weight:700>[</span>i <span style=color:#ff7b72;font-weight:700>=</span> nextIndex<span style=color:#ff7b72;font-weight:700>(</span>i<span style=color:#ff7b72;font-weight:700>,</span> len<span style=color:#ff7b72;font-weight:700>)])</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>e<span style=color:#ff7b72;font-weight:700>.</span>get<span style=color:#ff7b72;font-weight:700>()</span> <span style=color:#ff7b72;font-weight:700>==</span> key<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                <span style=color:#8b949e;font-style:italic>//调用weakrefrence的clear()清除引用
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                e<span style=color:#ff7b72;font-weight:700>.</span>clear<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>                <span style=color:#8b949e;font-style:italic>//连续段清除
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                expungeStaleEntry<span style=color:#ff7b72;font-weight:700>(</span>i<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>return</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><h1 id=4-内存泄露>4. 内存泄露<a hidden class=anchor aria-hidden=true href=#4-内存泄露>#</a></h1><h2 id=41-threadlocal-内存泄漏的原因>4.1 ThreadLocal 内存泄漏的原因<a hidden class=anchor aria-hidden=true href=#41-threadlocal-内存泄漏的原因>#</a></h2><p>从上图中可以看出，hreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部<strong>强引用</strong>时，Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强引用，只有thead线程退出以后,value的强引用链条才会断掉。</p><p>但如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p><blockquote><p>Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value</p></blockquote><p>永远无法回收，造成内存泄漏。, <strong>所以泄露的是value值</strong></p><h2 id=42-threadlocal正确的使用方法>4.2 ThreadLocal正确的使用方法<a hidden class=anchor aria-hidden=true href=#42-threadlocal正确的使用方法>#</a></h2><ol><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li></ol><blockquote><p>其实调用set()和get() 都有可能也会清除数据</p><p>ThreadLocal会在以下过程中清理过期节点：</p><ol><li>调用set()方法时，采样清理、全量清理，扩容时还会继续检查。</li><li>调用get()方法，没有直接命中，向后环形查找时。</li><li>调用remove()时，除了清理当前Entry，还会向后继续清理。</li></ol></blockquote><ol start=2><li>使用ThreadLocal时，一般建议将其声明为static final的，避免频繁创建ThreadLocal实例。</li></ol><h2 id=43-总结>4.3 总结<a hidden class=anchor aria-hidden=true href=#43-总结>#</a></h2><p>由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。</p><p>但是使用<strong>弱引用</strong>可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()的时候会被清除。</p><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><p><a href=https://zhuanlan.zhihu.com/p/102571059 target=_blank rel=noopener>ThreadLocal的内存泄露？什么原因？如何避免？ - 知乎 (zhihu.com)</a></p><h1 id=5-使用场景>5. 使用场景<a hidden class=anchor aria-hidden=true href=#5-使用场景>#</a></h1><h2 id=51-场景一代替参数的显式传递>5.1 场景一：代替参数的显式传递<a hidden class=anchor aria-hidden=true href=#51-场景一代替参数的显式传递>#</a></h2><p>当我们在写API接口的时候，通常Controller层会接受来自前端的入参，当这个接口功能比较复杂的时候，可能我们调用的Service层内部还调用了 很多其他的很多方法，通常情况下，我们会在每个调用的方法上加上需要传递的参数。</p><p>但是如果我们将参数存入ThreadLocal中，那么就不用显式的传递参数了，而是只需要ThreadLocal中获取即可。</p><p>这个场景其实使用的比较少，一方面显式传参比较容易理解，另一方面我们可以将多个参数封装为对象去传递。</p><h2 id=52-场景二解决线程安全问题>5.2 场景二：解决线程安全问题<a hidden class=anchor aria-hidden=true href=#52-场景二解决线程安全问题>#</a></h2><p>在Spring的Web项目中，我们通常会将业务分为Controller层，Service层，Dao层， 我们都知道@Autowired注解默认使用单例模式，那么不同请求线程进来之后，由于Dao层使用单例，那么负责数据库连接的Connection也只有一个， 如果每个请求线程都去连接数据库，那么就会造成线程不安全的问题，Spring是如何解决这个问题的呢？</p><p>在Spring项目中Dao层中装配的Connection肯定是线程安全的，其解决方案就是采用ThreadLocal方法，当每个请求线程使用Connection的时候， 都会从ThreadLocal获取一次，如果为null，说明没有进行过数据库连接，连接后存入ThreadLocal中，如此一来，每一个请求线程都保存有一份 自己的Connection。于是便解决了线程安全问题</p><p>ThreadLocal在设计之初就是为解决并发问题而提供一种方案，每个线程维护一份自己的数据，达到线程隔离的效果。</p><h2 id=53-场景三全局存储用户信息>5.3 场景三：全局存储用户信息<a hidden class=anchor aria-hidden=true href=#53-场景三全局存储用户信息>#</a></h2><p>在现在的系统设计中，前后端分离已基本成为常态，分离之后如何获取用户信息就成了一件麻烦事，通常在用户登录后， 用户信息会保存在Session或者Token中。这个时候，我们如果使用常规的手段去获取用户信息会很费劲，拿Session来说，我们要在接口参数中加上HttpServletRequest对象，然后调用 getSession方法，且每一个需要用户信息的接口都要加上这个参数，才能获取Session，这样实现就很麻烦了。</p><p>在实际的系统设计中，我们肯定不会采用上面所说的这种方式，而是使用ThreadLocal，我们会选择在拦截器的业务中， 获取到保存的用户信息，然后存入ThreadLocal，那么当前线程在任何地方如果需要拿到用户信息都可以使用ThreadLocal的get()方法</p><blockquote><p>(异步程序中ThreadLocal是不可靠的, 因为threadLocal是线程级别的, 所以只要开了新线程都会丢失信息</p><p>例如, 使用了<strong>线程池, future, fegin调用</strong> 就会丢失threadlocal里的数据(除非threadLocal是全局的)</p></blockquote><h1 id=6-实战>6. 实战<a hidden class=anchor aria-hidden=true href=#6-实战>#</a></h1><h2 id=61-代码>6.1 代码<a hidden class=anchor aria-hidden=true href=#61-代码>#</a></h2><p>具体实现流程：</p><ul><li>在登录业务代码中，当用户登录成功时，生成一个登录凭证存储到redis中，将凭证中的字符串保存在cookie中返回给客户端。</li><li>使用一个拦截器拦截请求，从cookie中获取凭证字符串与redis中的凭证进行匹配，获取用户信息，将用户信息存储到ThreadLocal中，在本次请求中持有用户信息，即可在后续操作中使用到用户信息。</li></ul><p><strong>定义工具类操作[ThreadLocal]（存放，获取，删除用户信息）</strong></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>ThreadLocalUtil</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>         * 保存用户对象的ThreadLocal  在拦截器操作 添加、删除相关用户数据
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>private</span> <span style=color:#ff7b72>static</span> <span style=color:#ff7b72>final</span> ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;</span>FeginUser<span style=color:#ff7b72;font-weight:700>&gt;</span> userThreadLocal <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;</span>FeginUser<span style=color:#ff7b72;font-weight:700>&gt;();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>         * 添加当前登录用户方法  在拦截器方法执行前调用设置获取用户
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>         * @param user
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>static</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>addCurrentUser</span><span style=color:#ff7b72;font-weight:700>(</span>FeginUser user<span style=color:#ff7b72;font-weight:700>){</span>
</span></span><span style=display:flex><span>            userThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>set<span style=color:#ff7b72;font-weight:700>(</span>user<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>         * 获取当前登录用户方法
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>static</span> FeginUser <span style=color:#d2a8ff;font-weight:700>getCurrentUser</span><span style=color:#ff7b72;font-weight:700>(){</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> userThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>get<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>         * 删除当前登录用户方法  在拦截器方法执行后 移除当前用户对象
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>static</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>remove</span><span style=color:#ff7b72;font-weight:700>(){</span>
</span></span><span style=display:flex><span>            userThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>remove<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p><strong>拦截器</strong></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>@Component</span>
</span></span><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>@Slf4j</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>public</span> <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>UserInfoInterceptor</span> <span style=color:#ff7b72>implements</span> HandlerInterceptor  <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>private</span> UserInfoUtil userInfoUtil<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 请求执行前执行的，将用户信息放入ThreadLocal
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * @param request
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * @param response
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * @param handler
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * @return
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * @throws Exception
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>boolean</span> <span style=color:#d2a8ff;font-weight:700>preHandle</span><span style=color:#ff7b72;font-weight:700>(</span>HttpServletRequest request<span style=color:#ff7b72;font-weight:700>,</span> HttpServletResponse response<span style=color:#ff7b72;font-weight:700>,</span> Object handler<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72>throws</span> Exception <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        FeginUser user<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>try</span><span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>             user <span style=color:#ff7b72;font-weight:700>=</span> userInfoUtil<span style=color:#ff7b72;font-weight:700>.</span>getUser<span style=color:#ff7b72;font-weight:700>(</span>request<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span><span style=color:#ff7b72>catch</span> <span style=color:#ff7b72;font-weight:700>(</span>CustomException e<span style=color:#ff7b72;font-weight:700>){</span>
</span></span><span style=display:flex><span>            log<span style=color:#ff7b72;font-weight:700>.</span>info<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#a5d6ff>&#34;***************************用户未登录， ThreadLocal无信息***************************&#34;</span><span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>true</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span><span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>!=</span>user<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>            log<span style=color:#ff7b72;font-weight:700>.</span>info<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#a5d6ff>&#34;***************************用户已登录，用户信息放入ThreadLocal***************************&#34;</span><span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>            ThreadLocalUtil<span style=color:#ff7b72;font-weight:700>.</span>addCurrentUser<span style=color:#ff7b72;font-weight:700>(</span>user<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>true</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>        log<span style=color:#ff7b72;font-weight:700>.</span>info<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#a5d6ff>&#34;***************************用户未登录， ThreadLocal无信息***************************&#34;</span><span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>true</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 接口访问结束后，从ThreadLocal中删除用户信息
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * @param request
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * @param response
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * @param handler
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * @param ex
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * @throws Exception
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#d2a8ff;font-weight:700>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>afterCompletion</span><span style=color:#ff7b72;font-weight:700>(</span>HttpServletRequest request<span style=color:#ff7b72;font-weight:700>,</span> HttpServletResponse response<span style=color:#ff7b72;font-weight:700>,</span> Object handler<span style=color:#ff7b72;font-weight:700>,</span> Exception ex<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72>throws</span> Exception <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        log<span style=color:#ff7b72;font-weight:700>.</span>info<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#a5d6ff>&#34;***************************接口调用结束， 从ThreadLocal删除用户信息***************************&#34;</span><span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>        ThreadLocalUtil<span style=color:#ff7b72;font-weight:700>.</span>remove<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><h2 id=62-异常处理>6.2 异常处理<a hidden class=anchor aria-hidden=true href=#62-异常处理>#</a></h2><h3 id=621-feign调用丢失请求头>6.2.1 feign调用丢失请求头<a hidden class=anchor aria-hidden=true href=#621-feign调用丢失请求头>#</a></h3><p>从请求头中获取登录token, 会有个问题, 如果上游是fegin调用, 则请求头会丢失, 所以需要在fegin调用时手动设置token, <strong>因为feign调用会使用新的http请求且不会携带原来http的header信息</strong></p><blockquote><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#d2a8ff;font-weight:700>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>public</span> RequestInterceptor <span style=color:#d2a8ff;font-weight:700>requestInterceptor</span><span style=color:#ff7b72;font-weight:700>()</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>//处理feign远程调用丢失请求头问题
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#ff7b72>return</span> template <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>            HttpRequestUtil<span style=color:#ff7b72;font-weight:700>.</span>getHttpHeader<span style=color:#ff7b72;font-weight:700>(</span>Constant<span style=color:#ff7b72;font-weight:700>.</span>AUTHORIZATION<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72;font-weight:700>.</span>ifPresent<span style=color:#ff7b72;font-weight:700>(</span>auth <span style=color:#ff7b72;font-weight:700>-&gt;</span> template<span style=color:#ff7b72;font-weight:700>.</span>header<span style=color:#ff7b72;font-weight:700>(</span>Constant<span style=color:#ff7b72;font-weight:700>.</span>AUTHORIZATION<span style=color:#ff7b72;font-weight:700>,</span> auth<span style=color:#ff7b72;font-weight:700>));</span>
</span></span><span style=display:flex><span>            HttpRequestUtil<span style=color:#ff7b72;font-weight:700>.</span>getHttpHeader<span style=color:#ff7b72;font-weight:700>(</span>Constant<span style=color:#ff7b72;font-weight:700>.</span>POWER_MENU_ID<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72;font-weight:700>.</span>ifPresent<span style=color:#ff7b72;font-weight:700>(</span>auth <span style=color:#ff7b72;font-weight:700>-&gt;</span> template<span style=color:#ff7b72;font-weight:700>.</span>header<span style=color:#ff7b72;font-weight:700>(</span>Constant<span style=color:#ff7b72;font-weight:700>.</span>POWER_MENU_ID<span style=color:#ff7b72;font-weight:700>,</span> auth<span style=color:#ff7b72;font-weight:700>));</span>
</span></span><span style=display:flex><span>            HttpRequestUtil<span style=color:#ff7b72;font-weight:700>.</span>getHttpHeader<span style=color:#ff7b72;font-weight:700>(</span>Constant<span style=color:#ff7b72;font-weight:700>.</span>X_FLAG<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72;font-weight:700>.</span>ifPresent<span style=color:#ff7b72;font-weight:700>(</span>auth <span style=color:#ff7b72;font-weight:700>-&gt;</span> template<span style=color:#ff7b72;font-weight:700>.</span>header<span style=color:#ff7b72;font-weight:700>(</span>Constant<span style=color:#ff7b72;font-weight:700>.</span>X_FLAG<span style=color:#ff7b72;font-weight:700>,</span> auth<span style=color:#ff7b72;font-weight:700>));</span>
</span></span><span style=display:flex><span>            HttpRequestUtil<span style=color:#ff7b72;font-weight:700>.</span>getHttpHeader<span style=color:#ff7b72;font-weight:700>(</span>Constant<span style=color:#ff7b72;font-weight:700>.</span>PLATFORM_FLAG<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72;font-weight:700>.</span>ifPresent<span style=color:#ff7b72;font-weight:700>(</span>auth <span style=color:#ff7b72;font-weight:700>-&gt;</span> template<span style=color:#ff7b72;font-weight:700>.</span>header<span style=color:#ff7b72;font-weight:700>(</span>Constant<span style=color:#ff7b72;font-weight:700>.</span>PLATFORM_FLAG<span style=color:#ff7b72;font-weight:700>,</span> auth<span style=color:#ff7b72;font-weight:700>));</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>};</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div></blockquote><h3 id=622-多线程中丢失请求头>6.2.2 多线程中丢失请求头<a hidden class=anchor aria-hidden=true href=#622-多线程中丢失请求头>#</a></h3><p>因为threadLocal是线程内部的, 使用多线程后threadLocal会不再有数据</p><p>解决方案:</p><ol><li>手动为子线程里的requst设置请求头</li><li>临时存储方案, 将threadLocal中的数据在子线程中再设置一遍</li></ol><p><a href=../../spring/%e8%8e%b7%e5%8f%96%e7%94%a8%e6%88%b7%e4%bf%a1%e6%81%af%e5%b7%a5%e5%85%b7%e7%b1%bb.html>获取用户信息工具类</a></p><blockquote><p>spring security 框架默认也没有解决</p><p><a href=https://www.cnblogs.com/precedeforetime/p/14601101.html target=_blank rel=noopener>spring security 如何在子线程中获取父线程中的用户认证信息（更改安全策略） - precedeforetime - 博客园 (cnblogs.com)</a></p></blockquote><h1 id=7-扩展>7. 扩展<a hidden class=anchor aria-hidden=true href=#7-扩展>#</a></h1><h2 id=71-inheritablethreadlocal>7.1 InheritableThreadLocal<a hidden class=anchor aria-hidden=true href=#71-inheritablethreadlocal>#</a></h2><p>InheritableThreadLocal类继承并重写了ThreadLocal的3个函数：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span> <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>InheritableThreadLocal</span><span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72>extends</span> ThreadLocal<span style=color:#ff7b72;font-weight:700>&lt;</span>T<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 该函数在父线程创建子线程，向子线程复制InheritableThreadLocal变量时使用
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>protected</span> T <span style=color:#d2a8ff;font-weight:700>childValue</span><span style=color:#ff7b72;font-weight:700>(</span>T parentValue<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>return</span> parentValue<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 由于重写了getMap，操作InheritableThreadLocal时，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 将只影响Thread类中的inheritableThreadLocals变量，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 与threadLocals变量不再有关系
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    ThreadLocalMap <span style=color:#d2a8ff;font-weight:700>getMap</span><span style=color:#ff7b72;font-weight:700>(</span>Thread t<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>       <span style=color:#ff7b72>return</span> t<span style=color:#ff7b72;font-weight:700>.</span>inheritableThreadLocals<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>        <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 类似于getMap，操作InheritableThreadLocal时，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 将只影响Thread类中的inheritableThreadLocals变量，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 与threadLocals变量不再有关系
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>createMap</span><span style=color:#ff7b72;font-weight:700>(</span>Thread t<span style=color:#ff7b72;font-weight:700>,</span> T firstValue<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        t<span style=color:#ff7b72;font-weight:700>.</span>inheritableThreadLocals <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> ThreadLocalMap<span style=color:#ff7b72;font-weight:700>(</span><span style=color:#ff7b72>this</span><span style=color:#ff7b72;font-weight:700>,</span> firstValue<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p><strong>线程间传值实现原理</strong></p><p>线程初始化时将数据从 inheritableThreadLocals 取出并设置</p><p><strong>thread类</strong></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>public</span> <span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>Thread</span> <span style=color:#ff7b72>implements</span> Runnable <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>   <span style=color:#ff7b72;font-weight:700>......(</span>其他源码<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>/* 
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 当前线程的ThreadLocalMap，主要存储该线程自身的ThreadLocal
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    ThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>ThreadLocalMap threadLocals <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * InheritableThreadLocal，自父线程集成而来的ThreadLocalMap，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 主要用于父子线程间ThreadLocal变量的传递
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 本文主要讨论的就是这个ThreadLocalMap
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    ThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>ThreadLocalMap inheritableThreadLocals <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>......(</span>其他源码<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p>线程初始化</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 默认情况下，设置inheritThreadLocals可传递
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>private</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>init</span><span style=color:#ff7b72;font-weight:700>(</span>ThreadGroup g<span style=color:#ff7b72;font-weight:700>,</span> Runnable target<span style=color:#ff7b72;font-weight:700>,</span> String name<span style=color:#ff7b72;font-weight:700>,</span>
</span></span><span style=display:flex><span>                      <span style=color:#ff7b72>long</span> stackSize<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        init<span style=color:#ff7b72;font-weight:700>(</span>g<span style=color:#ff7b72;font-weight:700>,</span> target<span style=color:#ff7b72;font-weight:700>,</span> name<span style=color:#ff7b72;font-weight:700>,</span> stackSize<span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#79c0ff>true</span><span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 初始化一个线程.
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 此函数有两处调用，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 1、上面的 init()，不传AccessControlContext，inheritThreadLocals=true
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     * 2、传递AccessControlContext，inheritThreadLocals=false
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>private</span> <span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>init</span><span style=color:#ff7b72;font-weight:700>(</span>ThreadGroup g<span style=color:#ff7b72;font-weight:700>,</span> Runnable target<span style=color:#ff7b72;font-weight:700>,</span> String name<span style=color:#ff7b72;font-weight:700>,</span>
</span></span><span style=display:flex><span>                      <span style=color:#ff7b72>long</span> stackSize<span style=color:#ff7b72;font-weight:700>,</span> AccessControlContext acc<span style=color:#ff7b72;font-weight:700>,</span>
</span></span><span style=display:flex><span>                      <span style=color:#ff7b72>boolean</span> inheritThreadLocals<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>......</span><span style=color:#f85149>（</span>其他代码<span style=color:#f85149>）</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>inheritThreadLocals <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> parent<span style=color:#ff7b72;font-weight:700>.</span>inheritableThreadLocals <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>this</span><span style=color:#ff7b72;font-weight:700>.</span>inheritableThreadLocals <span style=color:#ff7b72;font-weight:700>=</span>
</span></span><span style=display:flex><span>                ThreadLocal<span style=color:#ff7b72;font-weight:700>.</span>createInheritedMap<span style=color:#ff7b72;font-weight:700>(</span>parent<span style=color:#ff7b72;font-weight:700>.</span>inheritableThreadLocals<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>......</span><span style=color:#f85149>（</span>其他代码<span style=color:#f85149>）</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><blockquote><p><strong>所以只有线程创建时才会 执行值传递</strong></p></blockquote><h2 id=72-transmittablethreadlocalttl>7.2 TransmittableThreadLocal(TTL)<a hidden class=anchor aria-hidden=true href=#72-transmittablethreadlocalttl>#</a></h2><p>阿里提供的 在使用线程池等会池化复用线程的执行组件情况下，提供<code>ThreadLocal</code>值的传递功能，解决异步执行时上下文传递的问题。</p><blockquote><p>其底层是 将数据从父线程中取出来, 再手动设置到子线程中</p></blockquote><p><a href=https://github.com/alibaba/transmittable-thread-local target=_blank rel=noopener>TransmittableThreadLocal (TTL)</a></p><p><a href=https://zhuanlan.zhihu.com/p/102744180 target=_blank rel=noopener>ThreadLocal，一篇文章就够了 - 知乎 (zhihu.com)</a></p><p><a href=https://www.jianshu.com/p/80866ca6c424 target=_blank rel=noopener>ThreadLocal源码分析 - 简书 (jianshu.com)</a></p><p><a href=https://www.cnblogs.com/cy0628/p/15086201.html target=_blank rel=noopener>ThreadLocal为什么会导致内存泄漏？ - Chen洋 - 博客园 (cnblogs.com)</a></p><p><a href=https://blog.csdn.net/qq_33240556/article/details/121071209 target=_blank rel=noopener>Java-ThreadLocal三种使用场景_用心去追梦的博客-CSDN博客_java threadlocal场景</a></p><p><a href=https://blog.csdn.net/qq_39632561/article/details/115425564 target=_blank rel=noopener>ThreadLocal存放用户信息（springboot）_神都燕的博客-CSDN博客_threadlocal存储用户信息</a></p><p><a href=https://www.jianshu.com/p/94ba4a918ff5 target=_blank rel=noopener>InheritableThreadLocal详解 - 简书 (jianshu.com)</a></p><p><a href=https://blog.csdn.net/agonie201218/article/details/125933740 target=_blank rel=noopener>ThreadLocal 面试夺命11连问_Young丶的博客-CSDN博客</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/%E5%B9%B6%E5%8F%91.html>并发</a></li><li><a href=https://xiaokunji.com/zh/tags/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/TCP.html><span class=title>« 上一页</span><br><span>TCP</span></a>
<a class=next href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E6%9D%82%E9%A1%B9/timingwheel.html><span class=title>下一页 »</span><br><span>timingwheel</span></a></nav></footer></article></main><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>