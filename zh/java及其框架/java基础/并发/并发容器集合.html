<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>并发容器集合 | 米二</title><meta name=keywords content=" 1. 并发容器类介绍, 2. ConcurrentHashMap, 2.1  jdk1.7实现, put操作, 2.2 jdk1.8 实现, put操作, transfer() 扩容操作, get操作, 2.3 面试题"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E9%9B%86%E5%90%88.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E9%9B%86%E5%90%88.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="并发容器集合"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E9%9B%86%E5%90%88.html"><meta property="article:section" content="java及其框架"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-30T16:23:43+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="并发容器集合"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"并发容器集合","item":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E9%9B%86%E5%90%88.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"并发容器集合","name":"并发容器集合","description":"     ","keywords":[" 1. 并发容器类介绍"," 2. ConcurrentHashMap"," 2.1  jdk1.7实现"," put操作"," 2.2 jdk1.8 实现"," put操作"," transfer() 扩容操作"," get操作"," 2.3 面试题"],"articleBody":"[TOC]\n1. 并发容器类介绍 2. ConcurrentHashMap 2.1 jdk1.7实现 在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，如下图所示：\nSegment数组的意义就是将一个大的table分割成多个小的table来进行加锁，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样\nput操作 对于ConcurrentHashMap的数据插入，这里要进行两次Hash去定位数据的存储位置\nstatic class Segment\u003cK,V\u003e extends ReentrantLock implements Serializable { } 从上Segment的继承体系可以看出，Segment实现了ReentrantLock,也就带有锁的功能，\n当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒\n简单的说, 会通过两次hash分别找到对应的Segment和hashEntry的位置, 然后再插进去, 每个Segment都是ReentrantLock锁, 所以在Segment上加锁来保证线程安全\n2.2 jdk1.8 实现 JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本\n这些是构成ConcurrentHashMap实现结构的基础，下面看一下基本属性：\n// node数组最大容量：2^30=1073741824 private static final int MAXIMUM_CAPACITY = 1 \u003c\u003c 30 ; // 默认初始值，必须是2的幂数 private static final int DEFAULT_CAPACITY = 16 ; //数组可能最大值，需要与toArray（）相关方法关联 static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8 ; //并发级别，遗留下来的，为兼容以前的版本 private static final int DEFAULT_CONCURRENCY_LEVEL = 16 ; // 负载因子 private static final float LOAD_FACTOR = 0.75f; // 链表转红黑树阀值,\u003e 8 链表转换为红黑树 static final int TREEIFY_THRESHOLD = 8 ; //树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，\u003c=UNTREEIFY_THRESHOLD 则untreeify(lo)） static final int UNTREEIFY_THRESHOLD = 6 ; static final int MIN_TREEIFY_CAPACITY = 64 ; private static final int MIN_TRANSFER_STRIDE = 16 ; private static int RESIZE_STAMP_BITS = 16 ; // 2^15-1，help resize的最大线程数 private static final int MAX_RESIZERS = ( 1 \u003c\u003c ( 32 - RESIZE_STAMP_BITS)) - 1 ; // 32-16=16，sizeCtl中记录size大小的偏移量 private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS; // forwarding nodes的hash值 static final int MOVED = - 1 ; // 树根节点的hash值 static final int TREEBIN = - 2 ; // ReservationNode的hash值 static final int RESERVED = - 3 ; // 可用处理器数量 static final int NCPU = Runtime.getRuntime().availableProcessors(); //存放node的数组 transient volatile Node\u003cK,V\u003e[] table; /*控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义 *当为负数时：- 1 代表正在初始化，-N代表有N- 1 个线程正在 进行扩容 *当为 0 时：代表当时的table还没有被初始化 *当为正数时：表示初始化或者下一次进行扩容的大小 */ private transient volatile int sizeCtl; ConcurrentHashMap (int initialCapacity) 构造函数总结下：\n构造函数中并不会初始化哈希表；\n构造函数中仅设置哈希表大小的变量 sizeCtl；\ninitialCapacity 并不是哈希表大小；\n哈希表大小为 initialCapacity*1.5+1 后，向上取最小的 2 的 n 次方。如果超过最大容量一半，那么就是最大容量。\nput操作 final V putVal(K key, V value, boolean onlyIfAbsent){ if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); //两次hash，减少hash冲突，可以均匀分布 int binCount = 0; for (Node\u003cK,V\u003e[] tab = table;;) { Node\u003cK,V\u003e f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable();//这里就是上面构造方法没有进行初始化，在这里进行判断，为null就调用initTable进行初始化，属于懒汉模式初始化 else if ((f = tabAt(tab, i = (n - 1) \u0026 hash)) == null) { //如果i位置没有数据，就直接无锁插入 if ( casTabAt(tab, i, null,new Node\u003cK,V\u003e(hash, key, value, null)) ) break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) //如果在进行扩容，则先辅助扩容操作 (多线程同步进行扩容) tab = helpTransfer(tab, f); else { V oldVal = null; synchronized (f) { //如果以上条件都不满足，那就要进行加锁操作，也就是存在hash冲突，锁住链表或者红黑树的头结点 if (tabAt(tab, i) == f) { if (fh \u003e= 0) {//表示该节点是链表结构 binCount = 1; for (Node\u003cK,V\u003e e = f;; ++binCount) { K ek; //这里涉及到相同的key进行put就会覆盖原先的value if (e.hash == hash \u0026\u0026 ((ek = e.key) == key || (ek != null \u0026\u0026 key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) // hashmap 支持仅不存在时插入, 故此判断 e.val = value; break; } Node\u003cK,V\u003e pred = e; if ((e = e.next) == null) { pred.next = new Node\u003cK,V\u003e(hash, key, value, null); //插入链表尾部 break; } } } else if (f instanceof TreeBin) { //红黑树结构 Node\u003cK,V\u003e p; binCount = 2; //红黑树结构旋转插入 if ((p = ((TreeBin\u003cK,V\u003e)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } if (binCount != 0) {//如果链表的长度大于8时就会进行红黑树的转换 if (binCount \u003e= TREEIFY_THRESHOLD) treeifyBin(tab, i); // treeifyBin()方法里判断需要数组大小超过64,才会变红黑树, 和hashMap一样 if (oldVal != null) return oldVal; break; } } } addCount(1L, binCount); //统计size，并且检查是否需要扩容 return null; } 这个put的过程很清晰，对当前的table进行无条件自循环直到put成功，可以分成以下六步流程来概述\n如果没有初始化就先调用**initTable（）**方法来进行初始化过程 如果没有hash冲突就直接CAS插入 如果还在进行扩容操作就先进行扩容 helpTransfer(tab, f) 如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入， 最后一个如果Hash冲突时会形成Node链表，在链表长度超过8，Node数组超过64时会将链表结构转换为红黑树的结构，break再一次进入循环 如果添加成功就调用**addCount（）**方法统计size，并且检查是否需要扩容 新增槽点值时的线程安全\n此时为了保证线程安全，做了四处优化：\n通过自旋死循环保证一定可以新增成功。 在新增之前，通过 for (Node[] tab = table;;)这样的死循环来保证新增一定可以成功，一旦新增成功，就可以退出当前死循环，新增失败的话，会重复新增的步骤，直到新增成功为止。\n当前槽点为空时，通过 CAS 新增。 Java 这里的写法非常严谨，没有在判断槽点为空的情况下直接赋值，因为在判断槽点为空和赋值的瞬间，很有可能槽点已经被其他线程复制了，所以我们采用 CAS 算法，能够保证槽点为空的情况下赋值成功，如果恰好槽点已经被其他线程赋值，当前 CAS 操作失败，会再次执行 for 自旋，再走槽点有值的 put 流程，这里就是自旋 + CAS 的结合。\n当前槽点有值，锁住当前槽点。 put 时，如果当前槽点有值，就是 key 的 hash 冲突的情况，此时槽点上可能是链表或红黑树，我们通过锁住槽点，来保证同一时刻只会有一个线程能对槽点进行修改\nV oldVal = null;//锁定当前槽点，其余线程不能操作，保证了安全 synchronized (f) { ... } 红黑树旋转时，锁住红黑树的根节点，保证同一时刻，当前红黑树只能被一个线程旋转 ConcurrentHashMap核心原理，彻底给整明白了_Java_AI乔治_InfoQ写作社区 transfer() 扩容操作 transfer 方法的主要思路是：\n首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝；\n拷贝数组的槽点时，先把原数组槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时，把原数组槽点赋值为转移节点；\n这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在扩容完成之前，该槽点对应的数据是不会发生变化的；\n从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点；\n直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。\n扩容方法主要是通过在原数组上设置转移节点，put 时碰到转移节点时会等待扩容成功之后才能 put 的策略，来保证了整个扩容过程中肯定是线程安全的，因为数组的槽点一旦被设置成转移节点，在没有扩容完成之前，是无法进行操作的\n会使用多线程的方式来做扩容(数据迁移), 通过 ForwardingNode (转移节点) 来表示是否被迁移过 加上 synchronized 来保证线程安全\n这里的多线程不是新开一个线程池去迁移, 而是让 操作数据的线程 暂停操作来帮忙处理数据迁移(例如put时就会有这个处理) (称为辅助扩容或者多线程扩容)\nget操作 ConcurrentHashMap的get操作的流程很简单，也很清晰，可以分为三个步骤来描述\n计算hash值，定位到该table索引位置，如果是首节点符合就返回 如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回 以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null 下图表示有节点成为了链表中的元素\n其中\"xkj11\" 与\"xkj9\" hash冲突, 则\"11\"成为\"9\"的后驱节点, 所以直接看tab是找不到\"xkj11\"的, 所以get时会找到\"xkj9\"(的hash值) 然后比较key值是否相等, 才能确定是否为该值\nConcurrentHashMap底层实现原理(JDK1.7 \u0026 1.8) - 简书 (jianshu.com) 2.3 面试题 ConcurrentHashMap 的 get 方法是否要加锁，为什么？\nget 方法不需要加锁。因为 Node 的元素 value 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改节点的 value 或者新增节点的时候是对线程B可见的。这也是它比其他并发集合比如 Hashtable、用 Collections.synchronizedMap()包装的 HashMap 效率高的原因之一。\nConcurrentHashMap 支持 key 或者 value 为 null 吗？\n不支持\nConcurrentHashMap 面试题_学习使我可乐的博客-CSDN博客_concurrenthashmap面试题 ","wordCount":"4005","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-08-30T16:23:43.416699883Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E9%9B%86%E5%90%88.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search.html title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80.html>java基础</a> <span>></span>
<a href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91.html>并发</a> <span>></span></ul></nav><h1 class=post-title>并发容器集合</h1><div class=post-description></div><div class=post-meta>创建:&nbsp;<span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;更新:&nbsp;2023-08-30&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#1-%e5%b9%b6%e5%8f%91%e5%ae%b9%e5%99%a8%e7%b1%bb%e4%bb%8b%e7%bb%8d aria-label="1. 并发容器类介绍">1. 并发容器类介绍</a></li><li><a href=#2-concurrenthashmap aria-label="2. ConcurrentHashMap">2. ConcurrentHashMap</a><ul><li><a href=#21--jdk17%e5%ae%9e%e7%8e%b0 aria-label="2.1  jdk1.7实现">2.1 jdk1.7实现</a><ul><ul><li><a href=#put%e6%93%8d%e4%bd%9c aria-label=put操作>put操作</a></li></ul></ul></li><li><a href=#22-jdk18-%e5%ae%9e%e7%8e%b0 aria-label="2.2 jdk1.8 实现">2.2 jdk1.8 实现</a><ul><li><a href=#put%e6%93%8d%e4%bd%9c-1 aria-label=put操作>put操作</a></li><li><a href=#transfer-%e6%89%a9%e5%ae%b9%e6%93%8d%e4%bd%9c aria-label="transfer() 扩容操作">transfer() 扩容操作</a></li><li><a href=#get%e6%93%8d%e4%bd%9c aria-label=get操作>get操作</a></li></ul></li><li><a href=#23-%e9%9d%a2%e8%af%95%e9%a2%98 aria-label="2.3 面试题">2.3 面试题</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[TOC]</p><h1 id=1-并发容器类介绍>1. 并发容器类介绍<a hidden class=anchor aria-hidden=true href=#1-并发容器类介绍>#</a></h1><p><img loading=lazy src=http://concurrent.redspider.group/article/03/imgs/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8.png alt=img></p><h1 id=2-concurrenthashmap>2. ConcurrentHashMap<a hidden class=anchor aria-hidden=true href=#2-concurrenthashmap>#</a></h1><h2 id=21--jdk17实现>2.1 jdk1.7实现<a hidden class=anchor aria-hidden=true href=#21--jdk17实现>#</a></h2><p>在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，如下图所示：</p><p><img loading=lazy src=https://upload-images.jianshu.io/upload_images/5220087-8c5b0cc951e61398.png?imageMogr2/auto-orient/strip%7cimageView2/2/w/767/format/webp alt=img></p><p>Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样</p><h4 id=put操作>put操作<a hidden class=anchor aria-hidden=true href=#put操作>#</a></h4><p>对于ConcurrentHashMap的数据插入，这里要进行两次Hash去定位数据的存储位置</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>static</span> <span style=color:#ff7b72>class</span>  <span style=color:#f0883e;font-weight:700>Segment</span><span style=color:#ff7b72;font-weight:700>&lt;</span>K<span style=color:#ff7b72;font-weight:700>,</span>V<span style=color:#ff7b72;font-weight:700>&gt;</span> <span style=color:#ff7b72>extends</span>  ReentrantLock <span style=color:#ff7b72>implements</span>  Serializable <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p>从上Segment的继承体系可以看出，Segment实现了ReentrantLock,也就带有锁的功能，</p><p>当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒</p><blockquote><p>简单的说, 会通过两次hash分别找到对应的Segment和hashEntry的位置, 然后再插进去, 每个Segment都是ReentrantLock锁, 所以在Segment上加锁来保证线程安全</p></blockquote><h2 id=22-jdk18-实现>2.2 jdk1.8 实现<a hidden class=anchor aria-hidden=true href=#22-jdk18-实现>#</a></h2><p>JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，<strong>整个看起来就像是优化过且线程安全的HashMap</strong>，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本</p><p><img loading=lazy src=https://upload-images.jianshu.io/upload_images/5220087-63281d7b737f1109.png?imageMogr2/auto-orient/strip%7cimageView2/2/w/453/format/webp alt=img></p><p>这些是构成ConcurrentHashMap实现结构的基础，下面看一下基本属性：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// node数组最大容量：2^30=1073741824  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>private</span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  MAXIMUM_CAPACITY <span style=color:#ff7b72;font-weight:700>=</span>  1  <span style=color:#ff7b72;font-weight:700>&lt;&lt;</span>  30    <span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 默认初始值，必须是2的幂数  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>private</span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  DEFAULT_CAPACITY <span style=color:#ff7b72;font-weight:700>=</span>  16    <span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>//数组可能最大值，需要与toArray（）相关方法关联  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  MAX_ARRAY_SIZE <span style=color:#ff7b72;font-weight:700>=</span> Integer<span style=color:#ff7b72;font-weight:700>.</span>MAX_VALUE <span style=color:#ff7b72;font-weight:700>-</span>  8    <span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>//并发级别，遗留下来的，为兼容以前的版本  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>private</span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  DEFAULT_CONCURRENCY_LEVEL <span style=color:#ff7b72;font-weight:700>=</span>  16    <span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 负载因子  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>private</span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>float</span>  LOAD_FACTOR <span style=color:#ff7b72;font-weight:700>=</span>  0<span style=color:#ff7b72;font-weight:700>.</span>75f<span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 链表转红黑树阀值,&gt; 8 链表转换为红黑树  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  TREEIFY_THRESHOLD <span style=color:#ff7b72;font-weight:700>=</span>  8    <span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>//树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  UNTREEIFY_THRESHOLD <span style=color:#ff7b72;font-weight:700>=</span>  6    <span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  MIN_TREEIFY_CAPACITY <span style=color:#ff7b72;font-weight:700>=</span>  64    <span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>private</span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  MIN_TRANSFER_STRIDE <span style=color:#ff7b72;font-weight:700>=</span>  16    <span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>private</span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>int</span>  RESIZE_STAMP_BITS <span style=color:#ff7b72;font-weight:700>=</span>  16    <span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 2^15-1，help resize的最大线程数  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>private</span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  MAX_RESIZERS <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>(</span>    1  <span style=color:#ff7b72;font-weight:700>&lt;&lt;</span> <span style=color:#ff7b72;font-weight:700>(</span>    32  <span style=color:#ff7b72;font-weight:700>-</span> RESIZE_STAMP_BITS<span style=color:#ff7b72;font-weight:700>))</span> <span style=color:#ff7b72;font-weight:700>-</span>  1    <span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 32-16=16，sizeCtl中记录size大小的偏移量  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>private</span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  RESIZE_STAMP_SHIFT <span style=color:#ff7b72;font-weight:700>=</span>  32  <span style=color:#ff7b72;font-weight:700>-</span> RESIZE_STAMP_BITS<span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// forwarding nodes的hash值  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  MOVED     <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>-</span>    1    <span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 树根节点的hash值  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  TREEBIN   <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>-</span>    2    <span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// ReservationNode的hash值  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  RESERVED  <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>-</span>    3    <span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 可用处理器数量  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>static</span>  <span style=color:#ff7b72>final</span>  <span style=color:#ff7b72>int</span>  NCPU <span style=color:#ff7b72;font-weight:700>=</span> Runtime<span style=color:#ff7b72;font-weight:700>.</span>getRuntime<span style=color:#ff7b72;font-weight:700>().</span>availableProcessors<span style=color:#ff7b72;font-weight:700>();</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>//存放node的数组  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>transient</span>  <span style=color:#ff7b72>volatile</span>  Node<span style=color:#ff7b72;font-weight:700>&lt;</span>K<span style=color:#ff7b72;font-weight:700>,</span>V<span style=color:#ff7b72;font-weight:700>&gt;[]</span> table<span style=color:#ff7b72;font-weight:700>;</span>  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>/*控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>  *当为负数时：-    1    代表正在初始化，-N代表有N-    1    个线程正在 进行扩容  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>  *当为    0    时：代表当时的table还没有被初始化  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>  *当为正数时：表示初始化或者下一次进行扩容的大小  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>private</span>  <span style=color:#ff7b72>transient</span>  <span style=color:#ff7b72>volatile</span>  <span style=color:#ff7b72>int</span>  sizeCtl<span style=color:#ff7b72;font-weight:700>;</span>  
</span></span></code></pre></div><p><strong>ConcurrentHashMap (int initialCapacity) 构造函数总结下：</strong></p><ol><li><p>构造函数中并不会初始化哈希表；</p></li><li><p>构造函数中仅设置哈希表大小的变量 sizeCtl；</p></li><li><p>initialCapacity 并不是哈希表大小；</p></li><li><p>哈希表大小为 <strong>initialCapacity*1.5+1 后，向上取最小的 2 的 n 次方</strong>。如果超过最大容量一半，那么就是最大容量。</p></li></ol><h3 id=put操作-1>put操作<a hidden class=anchor aria-hidden=true href=#put操作-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff7b72>final</span> V <span style=color:#d2a8ff;font-weight:700>putVal</span><span style=color:#ff7b72;font-weight:700>(</span>K key<span style=color:#ff7b72;font-weight:700>,</span> V value<span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#ff7b72>boolean</span> onlyIfAbsent<span style=color:#ff7b72;font-weight:700>){</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>key <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#79c0ff>null</span> <span style=color:#ff7b72;font-weight:700>||</span> value <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72>throw</span> <span style=color:#ff7b72>new</span> NullPointerException<span style=color:#ff7b72;font-weight:700>();</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>int</span> hash <span style=color:#ff7b72;font-weight:700>=</span> spread<span style=color:#ff7b72;font-weight:700>(</span>key<span style=color:#ff7b72;font-weight:700>.</span>hashCode<span style=color:#ff7b72;font-weight:700>());</span>  <span style=color:#8b949e;font-style:italic>//两次hash，减少hash冲突，可以均匀分布  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#ff7b72>int</span> binCount <span style=color:#ff7b72;font-weight:700>=</span> 0<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72>for</span> <span style=color:#ff7b72;font-weight:700>(</span>Node<span style=color:#ff7b72;font-weight:700>&lt;</span>K<span style=color:#ff7b72;font-weight:700>,</span>V<span style=color:#ff7b72;font-weight:700>&gt;[]</span> tab <span style=color:#ff7b72;font-weight:700>=</span> table<span style=color:#ff7b72;font-weight:700>;;)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>            Node<span style=color:#ff7b72;font-weight:700>&lt;</span>K<span style=color:#ff7b72;font-weight:700>,</span>V<span style=color:#ff7b72;font-weight:700>&gt;</span> f<span style=color:#ff7b72;font-weight:700>;</span> <span style=color:#ff7b72>int</span> n<span style=color:#ff7b72;font-weight:700>,</span> i<span style=color:#ff7b72;font-weight:700>,</span> fh<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>tab <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#79c0ff>null</span> <span style=color:#ff7b72;font-weight:700>||</span> <span style=color:#ff7b72;font-weight:700>(</span>n <span style=color:#ff7b72;font-weight:700>=</span> tab<span style=color:#ff7b72;font-weight:700>.</span>length<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>==</span> 0<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>                tab <span style=color:#ff7b72;font-weight:700>=</span> initTable<span style=color:#ff7b72;font-weight:700>();</span><span style=color:#8b949e;font-style:italic>//这里就是上面构造方法没有进行初始化，在这里进行判断，为null就调用initTable进行初始化，属于懒汉模式初始化  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>            <span style=color:#ff7b72>else</span> <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>((</span>f <span style=color:#ff7b72;font-weight:700>=</span> tabAt<span style=color:#ff7b72;font-weight:700>(</span>tab<span style=color:#ff7b72;font-weight:700>,</span> i <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>(</span>n <span style=color:#ff7b72;font-weight:700>-</span> 1<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>&amp;</span> hash<span style=color:#ff7b72;font-weight:700>))</span> <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span> <span style=color:#8b949e;font-style:italic>//如果i位置没有数据，就直接无锁插入  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span> casTabAt<span style=color:#ff7b72;font-weight:700>(</span>tab<span style=color:#ff7b72;font-weight:700>,</span> i<span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>,</span><span style=color:#ff7b72>new</span> Node<span style=color:#ff7b72;font-weight:700>&lt;</span>K<span style=color:#ff7b72;font-weight:700>,</span>V<span style=color:#ff7b72;font-weight:700>&gt;(</span>hash<span style=color:#ff7b72;font-weight:700>,</span> key<span style=color:#ff7b72;font-weight:700>,</span> value<span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>))</span> <span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>break</span><span style=color:#ff7b72;font-weight:700>;</span>                   <span style=color:#8b949e;font-style:italic>// no lock when adding to empty bin
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>            <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>else</span> <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>((</span>fh <span style=color:#ff7b72;font-weight:700>=</span> f<span style=color:#ff7b72;font-weight:700>.</span>hash<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>==</span> MOVED<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#8b949e;font-style:italic>//如果在进行扩容，则先辅助扩容操作 (多线程同步进行扩容)
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                tab <span style=color:#ff7b72;font-weight:700>=</span> helpTransfer<span style=color:#ff7b72;font-weight:700>(</span>tab<span style=color:#ff7b72;font-weight:700>,</span> f<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72>else</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                V oldVal <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>synchronized</span> <span style=color:#ff7b72;font-weight:700>(</span>f<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span> <span style=color:#8b949e;font-style:italic>//如果以上条件都不满足，那就要进行加锁操作，也就是存在hash冲突，锁住链表或者红黑树的头结点
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                    <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>tabAt<span style=color:#ff7b72;font-weight:700>(</span>tab<span style=color:#ff7b72;font-weight:700>,</span> i<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>==</span> f<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                        <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>fh <span style=color:#ff7b72;font-weight:700>&gt;=</span> 0<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span><span style=color:#8b949e;font-style:italic>//表示该节点是链表结构  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                            binCount <span style=color:#ff7b72;font-weight:700>=</span> 1<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                            <span style=color:#ff7b72>for</span> <span style=color:#ff7b72;font-weight:700>(</span>Node<span style=color:#ff7b72;font-weight:700>&lt;</span>K<span style=color:#ff7b72;font-weight:700>,</span>V<span style=color:#ff7b72;font-weight:700>&gt;</span> e <span style=color:#ff7b72;font-weight:700>=</span> f<span style=color:#ff7b72;font-weight:700>;;</span> <span style=color:#ff7b72;font-weight:700>++</span>binCount<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                                K ek<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                                <span style=color:#8b949e;font-style:italic>//这里涉及到相同的key进行put就会覆盖原先的value  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                                <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>e<span style=color:#ff7b72;font-weight:700>.</span>hash <span style=color:#ff7b72;font-weight:700>==</span> hash <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span>
</span></span><span style=display:flex><span>                                    <span style=color:#ff7b72;font-weight:700>((</span>ek <span style=color:#ff7b72;font-weight:700>=</span> e<span style=color:#ff7b72;font-weight:700>.</span>key<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>==</span> key <span style=color:#ff7b72;font-weight:700>||</span>
</span></span><span style=display:flex><span>                                     <span style=color:#ff7b72;font-weight:700>(</span>ek <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>null</span> <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> key<span style=color:#ff7b72;font-weight:700>.</span>equals<span style=color:#ff7b72;font-weight:700>(</span>ek<span style=color:#ff7b72;font-weight:700>))))</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                                    oldVal <span style=color:#ff7b72;font-weight:700>=</span> e<span style=color:#ff7b72;font-weight:700>.</span>val<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                                    <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(!</span>onlyIfAbsent<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#8b949e;font-style:italic>// hashmap 支持仅不存在时插入, 故此判断
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                                        e<span style=color:#ff7b72;font-weight:700>.</span>val <span style=color:#ff7b72;font-weight:700>=</span> value<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                                    <span style=color:#ff7b72>break</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                                <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>                                Node<span style=color:#ff7b72;font-weight:700>&lt;</span>K<span style=color:#ff7b72;font-weight:700>,</span>V<span style=color:#ff7b72;font-weight:700>&gt;</span> pred <span style=color:#ff7b72;font-weight:700>=</span> e<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                                <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>((</span>e <span style=color:#ff7b72;font-weight:700>=</span> e<span style=color:#ff7b72;font-weight:700>.</span>next<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                                    pred<span style=color:#ff7b72;font-weight:700>.</span>next <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72>new</span> Node<span style=color:#ff7b72;font-weight:700>&lt;</span>K<span style=color:#ff7b72;font-weight:700>,</span>V<span style=color:#ff7b72;font-weight:700>&gt;(</span>hash<span style=color:#ff7b72;font-weight:700>,</span> key<span style=color:#ff7b72;font-weight:700>,</span> value<span style=color:#ff7b72;font-weight:700>,</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>);</span> <span style=color:#8b949e;font-style:italic>//插入链表尾部  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                                    <span style=color:#ff7b72>break</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                                <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>                            <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>                        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>                        <span style=color:#ff7b72>else</span> <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>f <span style=color:#ff7b72>instanceof</span> TreeBin<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>  <span style=color:#8b949e;font-style:italic>//红黑树结构  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                            Node<span style=color:#ff7b72;font-weight:700>&lt;</span>K<span style=color:#ff7b72;font-weight:700>,</span>V<span style=color:#ff7b72;font-weight:700>&gt;</span> p<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                            binCount <span style=color:#ff7b72;font-weight:700>=</span> 2<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                            <span style=color:#8b949e;font-style:italic>//红黑树结构旋转插入  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                            <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>((</span>p <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#ff7b72;font-weight:700>((</span>TreeBin<span style=color:#ff7b72;font-weight:700>&lt;</span>K<span style=color:#ff7b72;font-weight:700>,</span>V<span style=color:#ff7b72;font-weight:700>&gt;)</span>f<span style=color:#ff7b72;font-weight:700>).</span>putTreeVal<span style=color:#ff7b72;font-weight:700>(</span>hash<span style=color:#ff7b72;font-weight:700>,</span> key<span style=color:#ff7b72;font-weight:700>,</span> value<span style=color:#ff7b72;font-weight:700>))</span> <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>                                oldVal <span style=color:#ff7b72;font-weight:700>=</span> p<span style=color:#ff7b72;font-weight:700>.</span>val<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                                <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(!</span>onlyIfAbsent<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>                                    p<span style=color:#ff7b72;font-weight:700>.</span>val <span style=color:#ff7b72;font-weight:700>=</span> value<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                            <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>                        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>binCount <span style=color:#ff7b72;font-weight:700>!=</span> 0<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span><span style=color:#8b949e;font-style:italic>//如果链表的长度大于8时就会进行红黑树的转换
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                    <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>binCount <span style=color:#ff7b72;font-weight:700>&gt;=</span> TREEIFY_THRESHOLD<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>                        treeifyBin<span style=color:#ff7b72;font-weight:700>(</span>tab<span style=color:#ff7b72;font-weight:700>,</span> i<span style=color:#ff7b72;font-weight:700>);</span> <span style=color:#8b949e;font-style:italic>// treeifyBin()方法里判断需要数组大小超过64,才会变红黑树, 和hashMap一样
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                    <span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>(</span>oldVal <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>                        <span style=color:#ff7b72>return</span> oldVal<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff7b72>break</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>            <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>        <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span>        addCount<span style=color:#ff7b72;font-weight:700>(</span>1L<span style=color:#ff7b72;font-weight:700>,</span> binCount<span style=color:#ff7b72;font-weight:700>);</span>  <span style=color:#8b949e;font-style:italic>//统计size，并且检查是否需要扩容  
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#ff7b72>return</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><p>这个put的过程很清晰，对当前的table进行无条件自循环直到put成功，可以分成以下六步流程来概述</p><blockquote><ol><li>如果没有初始化就先调用**initTable（）**方法来进行初始化过程</li><li>如果没有hash冲突就直接CAS插入</li><li>如果还在进行扩容操作就先进行扩容 <strong>helpTransfer(tab, f)</strong></li><li>如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入，</li><li>最后一个如果Hash冲突时会形成Node链表，在链表长度超过8，Node数组超过64时会将链表结构转换为红黑树的结构，break再一次进入循环</li><li>如果添加成功就调用**addCount（）**方法统计size，并且检查是否需要扩容</li></ol></blockquote><p><strong>新增槽点值时的线程安全</strong></p><p>此时为了保证线程安全，做了四处优化：</p><ol><li>通过自旋死循环保证一定可以新增成功。</li></ol><p>在新增之前，通过 for (Node&lt;K,V>[] tab = table;;)这样的死循环来保证新增一定可以成功，一旦新增成功，就可以退出当前死循环，新增失败的话，会重复新增的步骤，直到新增成功为止。</p><ol start=2><li>当前槽点为空时，通过 CAS 新增。</li></ol><p>Java 这里的写法非常严谨，没有在判断槽点为空的情况下直接赋值，因为在判断槽点为空和赋值的瞬间，很有可能槽点已经被其他线程复制了，所以我们采用 CAS 算法，能够保证槽点为空的情况下赋值成功，如果恰好槽点已经被其他线程赋值，当前 CAS 操作失败，会再次执行 for 自旋，再走槽点有值的 put 流程，这里就是自旋 + CAS 的结合。</p><ol start=3><li>当前槽点有值，锁住当前槽点。</li></ol><p>put 时，如果当前槽点有值，就是 key 的 hash 冲突的情况，此时槽点上可能是链表或红黑树，我们通过锁住槽点，来保证同一时刻只会有一个线程能对槽点进行修改</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>V oldVal <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#79c0ff>null</span><span style=color:#ff7b72;font-weight:700>;</span><span style=color:#8b949e;font-style:italic>//锁定当前槽点，其余线程不能操作，保证了安全
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>synchronized</span> <span style=color:#ff7b72;font-weight:700>(</span>f<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span> <span style=color:#ff7b72;font-weight:700>...</span> <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><ol start=4><li>红黑树旋转时，锁住红黑树的根节点，保证同一时刻，当前红黑树只能被一个线程旋转</li></ol><p><a href=https://xie.infoq.cn/article/901e4fa89353a6dfb63490c3d target=_blank rel=noopener>ConcurrentHashMap核心原理，彻底给整明白了_Java_AI乔治_InfoQ写作社区</a></p><h3 id=transfer-扩容操作>transfer() 扩容操作<a hidden class=anchor aria-hidden=true href=#transfer-扩容操作>#</a></h3><p>transfer 方法的主要思路是：</p><ol><li><p>首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝；</p></li><li><p>拷贝数组的槽点时，先把原数组槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时，把原数组槽点赋值为转移节点；</p></li><li><p>这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在扩容完成之前，该槽点对应的数据是不会发生变化的；</p></li><li><p>从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点；</p></li><li><p>直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。</p></li></ol><p>扩容方法主要是通过在原数组上设置转移节点，put 时碰到转移节点时会等待扩容成功之后才能 put 的策略，来保证了整个扩容过程中肯定是线程安全的，因为数组的槽点一旦被设置成转移节点，在没有扩容完成之前，是无法进行操作的</p><blockquote><p>会使用多线程的方式来做扩容(数据迁移), 通过 ForwardingNode (转移节点) 来表示是否被迁移过 加上 synchronized 来保证线程安全</p><p>这里的多线程不是新开一个线程池去迁移, 而是让 <strong>操作数据的线程 暂停操作来帮忙处理数据迁移</strong>(例如put时就会有这个处理) (称为辅助扩容或者多线程扩容)</p></blockquote><h3 id=get操作>get操作<a hidden class=anchor aria-hidden=true href=#get操作>#</a></h3><p>ConcurrentHashMap的get操作的流程很简单，也很清晰，可以分为三个步骤来描述</p><ol><li>计算hash值，定位到该table索引位置，如果是首节点符合就返回</li><li>如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回</li><li>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null</li></ol><p>下图表示有节点成为了链表中的元素</p><p><img loading=lazy src=https://gitee.com/xiaokunji/my-images/raw/master/myMD/hashMap%e6%88%90%e9%93%be%e8%a1%a8.png alt=image-20220508220132620></p><blockquote><p>其中"xkj11" 与"xkj9" hash冲突, 则"11"成为"9"的后驱节点, 所以直接看tab是找不到"xkj11"的, 所以get时会找到"xkj9"(的hash值) 然后比较key值是否相等, 才能确定是否为该值</p></blockquote><p><a href=https://www.jianshu.com/p/865c813f2726 target=_blank rel=noopener>ConcurrentHashMap底层实现原理(JDK1.7 & 1.8) - 简书 (jianshu.com)</a></p><h2 id=23-面试题>2.3 面试题<a hidden class=anchor aria-hidden=true href=#23-面试题>#</a></h2><p><strong>ConcurrentHashMap 的 get 方法是否要加锁，为什么？</strong></p><p>get 方法不需要加锁。因为 Node 的元素 value 和指针 next 是用 <strong>volatile 修饰</strong>的，在多线程环境下线程A修改节点的 value 或者新增节点的时候是对线程B可见的。这也是它比其他并发集合比如 Hashtable、用 Collections.synchronizedMap()包装的 HashMap 效率高的原因之一。</p><p><strong>ConcurrentHashMap 支持 key 或者 value 为 null 吗？</strong></p><p>不支持</p><p><a href=https://blog.csdn.net/qq_40826814/article/details/115328565 target=_blank rel=noopener>ConcurrentHashMap 面试题_学习使我可乐的博客-CSDN博客_concurrenthashmap面试题</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/%E5%B9%B6%E5%8F%91.html>并发</a></li><li><a href=https://xiaokunji.com/zh/tags/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6.html>java及其框架</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/mybatis/%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8.html><span class=title>« 上一页</span><br><span>标签的使用</span></a>
<a class=next href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E7%AE%97%E6%B3%95/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.html><span class=title>下一页 »</span><br><span>布隆过滤器</span></a></nav></footer></article></main><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>