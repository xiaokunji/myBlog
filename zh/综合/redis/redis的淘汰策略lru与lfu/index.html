<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis的淘汰策略LRU与LFU | 米二</title><meta name=keywords content=" redis中的LRU实现,define LRU_BITS 24,define REDIS_LRU_BITS 24, redis中的LFU实现,  ldt(Last Decrement Time), logc(Logistic Counter), logc 算法调整, 扩展, 淘汰池的更新策略"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.github.io/zh/%E7%BB%BC%E5%90%88/redis/redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5lru%E4%B8%8Elfu/><link crossorigin=anonymous href=/assets/css/stylesheet.a2492b1919558dad2b0783841b531329520921f957f354ded4c3fc4d21dcc77f.css integrity="sha256-okkrGRlVja0rB4OEG1MTKVIJIflX81Te1MP8TSHcx38=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.github.io/img/Q.gif><link rel=apple-touch-icon href=https://xiaokunji.github.io/Q.gif><link rel=mask-icon href=https://xiaokunji.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.github.io/zh/%E7%BB%BC%E5%90%88/redis/redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5lru%E4%B8%8Elfu/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Redis的淘汰策略LRU与LFU"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.github.io/zh/%E7%BB%BC%E5%90%88/redis/redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5lru%E4%B8%8Elfu/"><meta property="article:section" content="综合"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis的淘汰策略LRU与LFU"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":3,"name":"Redis的淘汰策略LRU与LFU","item":"https://xiaokunji.github.io/zh/%E7%BB%BC%E5%90%88/redis/redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5lru%E4%B8%8Elfu/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis的淘汰策略LRU与LFU","name":"Redis的淘汰策略LRU与LFU","description":"     ","keywords":[" redis中的LRU实现","define LRU_BITS 24","define REDIS_LRU_BITS 24"," redis中的LFU实现","  ldt(Last Decrement Time)"," logc(Logistic Counter)"," logc 算法调整"," 扩展"," 淘汰池的更新策略"],"articleBody":"[toc]\n释放内存其实在每次处理命令时都会执行, 只是满足判断条件才执行 , 例如内存满了, 需要淘汰key等等条件, 若发现已用内存超出maxmemory，会计算需释放的内存量。这个 释放内存大小=已使用内存量-maxmemory。\nredis中的LRU实现 redis没有使用标准的LRU算法, 只是近似的LRU算法, 因为嫌LinkedList占用的空间太大了(因为起码要记录头尾指针)\n简述: redis通过计算每个key的闲置时间来决定是否要选它淘汰(全局时钟 减去 当前key的访问时钟), redis会随机选几个key, 它们的闲置时间都要大于一个阈值(其实会存入一个pool, 这个阈值就是pool中最小的闲置时间), 当内存不够时, 就从这几个key中淘汰闲置时间最大的值\n首先看一下全局时钟定义\n1 2 3 4 5 6 7 8 #define LRU_BITS 24 struct redisServer { pid_t pid; /* Main process pid. */ char *configfile; /* Absolute config file path, or NULL */ ….. unsigned lruclock:LRU_BITS; /* Clock for LRU eviction */ ... }; redisServer 中包含了redis服务器启动之后的基本信息(PID,配置文件路径,serverCron运行频率hz等),外部可调用模块信息，网络信息，RDB/AOF信息，日志信息，复制信息等等。\n上述结构体中lruclock:LRU_BITS,其中存储了服务器自启动之后的lru时钟，该时钟是全局的lru时钟。该时钟100ms更新一次。\n可以通过hz来调整,默认情况hz=10,因此每1000ms/10=100ms执行一次定时任务\n因此lrulock最大能到(2**24-1)/3600/24 = 194天,如果超过了这个时间，lrulock重新开始。对于redis server来说，server.lrulock表示的是一个全局的lrulock，\n如果全局时钟 小于 对象时钟, 则会再加上时钟最大值 REDIS_LRU_CLOCK_MAX , 也就是 194天 的秒数, 相当于是第二轮了\n1 2 3 4 5 6 7 8 9 10 11 /* Given an object returns the min number of seconds the object was never * requested, using an approximated LRU algorithm. */ #define REDIS_LRU_CLOCK_MAX ((1\u003c","wordCount":"4502","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-08-22T00:00:00Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.github.io/zh/%E7%BB%BC%E5%90%88/redis/redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5lru%E4%B8%8Elfu/"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.github.io/img/Q.gif"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.github.io/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.github.io/img/Q.gif alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.github.io/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.github.io/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.github.io/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.github.io/zh/post title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.github.io/zh/archives/ title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.github.io/zh/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.github.io/zh/categories title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.github.io/zh/links title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.github.io/zh/>content</a> <span>></span>
<a href=https://xiaokunji.github.io/zh/%E7%BB%BC%E5%90%88/>综合</a> <span>></span>
<a href=https://xiaokunji.github.io/zh/%E7%BB%BC%E5%90%88/redis/>Redis</a> <span>></span></ul></nav><h1 class=post-title>Redis的淘汰策略LRU与LFU</h1><div class=post-description></div><div class=post-meta><span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.github.io/zh/categories/%E7%BB%BC%E5%90%88/>综合</a></ul><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv></span></span>
<script src=https://cdn.staticfile.org/twikoo//twikoo.all.min.js></script><script>let url=document.documentURI,dnsUrl="https://xiaokunji.github.io/",urlSplit=url.split(dnsUrl),finalUrl=urlSplit[1];finalUrl[0]!=="/"&&(finalUrl="/"+finalUrl),twikoo.getCommentsCount({envId:null,region:null,urls:[finalUrl],includeReply:!1}).then(function(e){let t=e[0].count;const n=document.getElementById("comment_count");n.innerText=t}).catch(function(e){console.error(e)})</script>&nbsp;| 评论: &nbsp; <span id=comment_count></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#redis%e4%b8%ad%e7%9a%84lru%e5%ae%9e%e7%8e%b0 aria-label=redis中的LRU实现>redis中的LRU实现</a></li><li><a href=#redis%e4%b8%ad%e7%9a%84lfu%e5%ae%9e%e7%8e%b0 aria-label=redis中的LFU实现>redis中的LFU实现</a><ul><li><a href=#ldtlast-decrement-time aria-label="ldt(Last Decrement Time)">ldt(Last Decrement Time)</a></li><li><a href=#logclogistic-counter aria-label="logc(Logistic Counter)">logc(Logistic Counter)</a></li><li><a href=#logc-%e7%ae%97%e6%b3%95%e8%b0%83%e6%95%b4 aria-label="logc 算法调整">logc 算法调整</a></li></ul></li><li><a href=#%e6%89%a9%e5%b1%95 aria-label=扩展>扩展</a><ul><li><a href=#%e6%b7%98%e6%b1%b0%e6%b1%a0%e7%9a%84%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5 aria-label=淘汰池的更新策略>淘汰池的更新策略</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><blockquote><p>释放内存其实在每次处理命令时都会执行, 只是满足判断条件才执行 , 例如内存满了, 需要淘汰key等等条件, 若发现已用内存超出<code>maxmemory</code>，会计算需释放的内存量。这个 <code>释放内存大小=已使用内存量-maxmemory</code>。</p></blockquote><h1 id=redis中的lru实现>redis中的LRU实现<a hidden class=anchor aria-hidden=true href=#redis中的lru实现>#</a></h1><p>redis没有使用标准的LRU算法, 只是近似的LRU算法, 因为嫌LinkedList占用的空间太大了(因为起码要记录头尾指针)</p><blockquote><p>简述: redis通过计算每个key的闲置时间来决定是否要选它淘汰(全局时钟 减去 当前key的访问时钟), redis会随机选几个key, 它们的闲置时间都要大于一个阈值(其实会存入一个pool, 这个阈值就是pool中最小的闲置时间), 当内存不够时, 就<strong>从这几个key中淘汰闲置时间最大的值</strong></p></blockquote><p>首先看一下全局时钟定义</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#define LRU_BITS 24
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>redisServer</span> {
</span></span><span style=display:flex><span>       pid_t pid; <span style=color:#75715e>/* Main process pid. */</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>configfile; <span style=color:#75715e>/* Absolute config file path, or NULL */</span>
</span></span><span style=display:flex><span>       <span style=color:#960050;background-color:#1e0010>…</span>..
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>unsigned</span> lruclock:LRU_BITS; <span style=color:#75715e>/* Clock for LRU eviction */</span>
</span></span><span style=display:flex><span>       ...
</span></span><span style=display:flex><span>};
</span></span></code></pre></td></tr></table></div></div><p>redisServer 中包含了redis服务器启动之后的基本信息(PID,配置文件路径,serverCron运行频率hz等),外部可调用模块信息，网络信息，RDB/AOF信息，日志信息，复制信息等等。</p><p>上述结构体中<code>lruclock:LRU_BITS</code>,其中存储了服务器自启动之后的lru时钟，该时钟是全局的lru时钟。<strong>该时钟100ms更新一次</strong>。</p><blockquote><p>可以通过hz来调整,默认情况hz=10,因此每1000ms/10=100ms执行一次定时任务</p></blockquote><p>因此lrulock最大能到(2**24-1)/3600/24 = 194天,如果超过了这个时间，lrulock重新开始。对于redis server来说，server.lrulock表示的是一个全局的lrulock，</p><blockquote><p>如果全局时钟 小于 对象时钟, 则会再加上时钟最大值 <code>REDIS_LRU_CLOCK_MAX</code> , 也就是 194天 的秒数, 相当于是第二轮了</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* Given an object returns the min number of seconds the object was never
</span></span></span><span style=display:flex><span><span style=color:#75715e> * requested, using an approximated LRU algorithm. */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define REDIS_LRU_CLOCK_MAX ((1&lt;&lt;REDIS_LRU_BITS)-1) </span><span style=color:#75715e>/* Max value of obj-&gt;lru */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define REDIS_LRU_CLOCK_RESOLUTION 1 </span><span style=color:#75715e>/* LRU clock resolution in seconds */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>estimateObjectIdleTime</span>(robj <span style=color:#f92672>*</span>o) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (server.lruclock <span style=color:#f92672>&gt;=</span> o<span style=color:#f92672>-&gt;</span>lru) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (server.lruclock <span style=color:#f92672>-</span> o<span style=color:#f92672>-&gt;</span>lru) <span style=color:#f92672>*</span> REDIS_LRU_CLOCK_RESOLUTION;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ((REDIS_LRU_CLOCK_MAX <span style=color:#f92672>-</span> o<span style=color:#f92672>-&gt;</span>lru) <span style=color:#f92672>+</span> server.lruclock) <span style=color:#f92672>*</span> REDIS_LRU_CLOCK_RESOLUTION;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></blockquote><p>那么对于每个redisObject都有一个自己的lrulock。这样每redisObject就可以根据自己的lrulock和全局的server.lrulock比较，来确定是否能够被淘汰掉。</p><p>再看一下 redisObject的实现</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define REDIS_LRU_BITS 24
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> redisObject {
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>unsigned</span> type:<span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>unsigned</span> encoding:<span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 从这里看出, 这个字段在不同淘汰策略下, 存的内容是不一样的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     <span style=color:#66d9ef>unsigned</span> lru:LRU_BITS; <span style=color:#75715e>/* LRU time (relative to server.lruclock) or
</span></span></span><span style=display:flex><span><span style=color:#75715e>                             * LFU data (least significant 8 bits frequency
</span></span></span><span style=display:flex><span><span style=color:#75715e>                             * and most significant 16 bits decreas time). */</span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>int</span> refcount;
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr;
</span></span><span style=display:flex><span>} robj
</span></span></code></pre></td></tr></table></div></div><p>在Redis的dict中每次按key获取一个值的时候，都会调用lookupKey函数,如果配置使用了LRU模式,该函数会更新value中的lru字段为当前秒级别的时间戳</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>robj <span style=color:#f92672>*</span><span style=color:#a6e22e>lookupKey</span>(redisDb <span style=color:#f92672>*</span>db, robj <span style=color:#f92672>*</span>key, <span style=color:#66d9ef>int</span> flags) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (server.maxmemory_policy <span style=color:#f92672>&amp;</span> MAXMEMORY_FLAG_LFU) { <span style=color:#75715e>//如果配置的是lfu方式，则更新lfu
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>updateLFU</span>(val);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                val<span style=color:#f92672>-&gt;</span>lru <span style=color:#f92672>=</span> <span style=color:#a6e22e>LRU_CLOCK</span>();<span style=color:#75715e>//否则按lru方式更新
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>第一次随机选取的key都会放入一个pool中(pool的大小为16),pool中的key是按lru大小顺序排列的。接下来每次随机选取的key lru值必须大于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接<strong>从pool中选取一个lru最大的值然后将其淘汰</strong>。这样一来，每次移除的Key并不仅仅是随机选择的N个Key里面最大的，而且还是pool里面idle time最大的</p><p>随机选的key的数量默认为5, 由 <code>server.maxmemory_samples</code> 控制, <code>maxmemory_samples</code> 就是样本大小, 值越大, 约接近LRU, 淘汰的正确率越高, 性能消耗也越大</p><blockquote><p>采用"pool"，把一个全局排序问题 转化成为了 局部的比较问题。(尽管排序本质上也是比较，囧)。要想知道idle time 最大的key，精确的LRU需要对全局的key的idle time排序，然后就能找出idle time最大的key了。但是可以采用一种近似的思想，即随机采样(samping)若干个key，这若干个key就代表着全局的key，把samping得到的key放到pool里面，每次采样之后更新pool，使得pool里面总是保存着随机选择过的key的idle time最大的那些key。需要evict key时，直接从pool里面取出idle time最大的key，将之evict掉。这种思想是很值得借鉴的。</p></blockquote><h1 id=redis中的lfu实现>redis中的LFU实现<a hidden class=anchor aria-hidden=true href=#redis中的lfu实现>#</a></h1><blockquote><p>简述: 它和LRU规则一样, 利用在key中时间钟字段, 不过把内部时钟的24位分成两部分，前16位还代表时钟，<strong>后8位代表一个计数器</strong>。8位只能代表255，但是redis并没有采用线性上升的方式，而是结合增长因子来计数, 而且还有衰退因子来减少计数。也会和LRU一样, 存在一个淘汰池, <strong>从淘汰池中redis会对内部时钟最小的key进行淘汰</strong>（最小表示最不频繁使用），注意这个过程也是根据策略随机选择键</p></blockquote><p>在LFU模式下，Redis对象头的24bit lru字段被分成两段来存储，高16bit存储ldt(Last Decrement Time)，低8bit存储logc(Logistic Counter)。</p><p><img loading=lazy src=Redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5LRU%E4%B8%8ELFU.assets/5dd759c2c31876ed554585f5cd0e9193.png alt="lru_24 bit.png"></p><h2 id=ldtlast-decrement-time>ldt(Last Decrement Time)<a hidden class=anchor aria-hidden=true href=#ldtlast-decrement-time>#</a></h2><p>高16bit用来记录最近一次计数器降低的时间，由于只有8bit，存储的是Unix分钟时间戳取模2^16，16bit能表示的最大值为65535（65535/24/60≈45.5），大概45.5天会折返（折返指的是取模后的值重新从0开始）。</p><p>源码如下:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* Return the current time in minutes, just taking the least significant
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 16 bits. The returned time is suitable to be stored as LDT (last decrement
</span></span></span><span style=display:flex><span><span style=color:#75715e> * time) for the LFU implementation. */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// server.unixtime是Redis缓存的Unix时间戳
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 可以看出使用的Unix的分钟时间戳，取模2^16
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>LFUGetTimeInMinutes</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (server.unixtime<span style=color:#f92672>/</span><span style=color:#ae81ff>60</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>65535</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#75715e>/* Given an object last access time, compute the minimum number of minutes
</span></span></span><span style=display:flex><span><span style=color:#75715e> * that elapsed since the last access. Handle overflow (ldt greater than
</span></span></span><span style=display:flex><span><span style=color:#75715e> * the current 16 bits minutes time) considering the time as wrapping
</span></span></span><span style=display:flex><span><span style=color:#75715e> * exactly once. */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>LFUTimeElapsed</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> ldt) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 获取系统当前的LFU time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> now <span style=color:#f92672>=</span> <span style=color:#a6e22e>LFUGetTimeInMinutes</span>();
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果now &gt;= ldt 直接取差值  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (now <span style=color:#f92672>&gt;=</span> ldt) <span style=color:#66d9ef>return</span> now<span style=color:#f92672>-</span>ldt;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果now &lt; ldt 增加上65535
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 注意Redis 认为折返就只有一次折返，多次折返也是一次，我思考了很久感觉这个应该是可以接受的，本身Redis的淘汰算法就带有随机性  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>65535</span><span style=color:#f92672>-</span>ldt<span style=color:#f92672>+</span>now;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h2 id=logclogistic-counter>logc(Logistic Counter)<a hidden class=anchor aria-hidden=true href=#logclogistic-counter>#</a></h2><p>低8位用来记录访问频次，8bit能表示的最大值为255，logc肯定无法记录真实的Rediskey的访问次数，其实从名字可以看出存储的是访问次数的对数值，每个<strong>新加入的key的logc初始值为5（LFU_INITI_VAL）</strong>，这样可以保证新加入的值不会被首先选中淘汰；logc每次key被访问时都会更新；此外，logc会随着时间衰减。</p><h2 id=logc-算法调整>logc 算法调整<a hidden class=anchor aria-hidden=true href=#logc-算法调整>#</a></h2><p>redis.conf 提供了两个配置项，用于调整LFU的算法从而控制Logistic Counter的增长和衰减。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#a6e22e>--</span> <span style=color:#e6db74>用于调整Logistic Counter的增长速度，lfu-log-factor值越大，Logistic Counter增长越慢。</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>lfu-log-factor</span> <span style=color:#e6db74>10</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>--</span> <span style=color:#e6db74>用于调整Logistic Counter的衰减速度，它是一个以分钟为单位的数值，默认值为1,；lfu-decay-time值越大，衰减越慢。</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>lfu-decay-time</span> <span style=color:#e6db74>1</span>
</span></span></code></pre></td></tr></table></div></div><p>增长的源码:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* Logarithmically increment a counter. The greater is the current counter value
</span></span></span><span style=display:flex><span><span style=color:#75715e> * the less likely is that it gets really implemented. Saturate it at 255. */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint8_t</span> <span style=color:#a6e22e>LFULogIncr</span>(<span style=color:#66d9ef>uint8_t</span> counter) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Logistic Counter最大值为255  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (counter <span style=color:#f92672>==</span> <span style=color:#ae81ff>255</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>255</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 取一个0~1的随机数r  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>double</span> r <span style=color:#f92672>=</span> (<span style=color:#66d9ef>double</span>)<span style=color:#a6e22e>rand</span>()<span style=color:#f92672>/</span>RAND_MAX;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// counter减去LFU_INIT_VAL （LFU_INIT_VAL为每个key的Logistic Counter初始值，默认为5）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>double</span> baseval <span style=color:#f92672>=</span> counter <span style=color:#f92672>-</span> LFU_INIT_VAL;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果衰减之后已经小于5了，那么baseval &lt; 0取0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (baseval <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) baseval <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// lfu-log-factor在这里被使用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 可以看出如果lfu_log_factor的值越大，p越小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// r &lt; p的概率就越小，Logistic Counter增加的概率就越小（因此lfu_log_factor越大增长越缓慢）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>double</span> p <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span><span style=color:#f92672>/</span>(baseval<span style=color:#f92672>*</span>server.lfu_log_factor<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>&lt;</span> p) counter<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> counter;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>衰减的源代码：</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* If the object decrement time is reached decrement the LFU counter but
</span></span></span><span style=display:flex><span><span style=color:#75715e> * do not update LFU fields of the object, we update the access time
</span></span></span><span style=display:flex><span><span style=color:#75715e> * and counter in an explicit way when the object is really accessed.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * And we will times halve the counter according to the times of
</span></span></span><span style=display:flex><span><span style=color:#75715e> * elapsed time than server.lfu_decay_time.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Return the object frequency counter.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * This function is used in order to scan the dataset for the best object
</span></span></span><span style=display:flex><span><span style=color:#75715e> * to fit: as we check for the candidate, we incrementally decrement the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * counter of the scanned objects if needed. */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>LFUDecrAndReturn</span>(robj <span style=color:#f92672>*</span>o) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 获取lru的高16位，也就是ldt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> ldt <span style=color:#f92672>=</span> o<span style=color:#f92672>-&gt;</span>lru <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span>;  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 获取lru的低8位，也就是logc  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> counter <span style=color:#f92672>=</span> o<span style=color:#f92672>-&gt;</span>lru <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>255</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 根据配置的lfu-decay-time计算Logistic Counter需要衰减的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> num_periods <span style=color:#f92672>=</span> server.lfu_decay_time <span style=color:#f92672>?</span> <span style=color:#a6e22e>LFUTimeElapsed</span>(ldt) <span style=color:#f92672>/</span> server.lfu_decay_time : <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (num_periods)
</span></span><span style=display:flex><span>    counter <span style=color:#f92672>=</span> (num_periods <span style=color:#f92672>&gt;</span> counter) <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> counter <span style=color:#f92672>-</span> num_periods;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> counter;
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>LFU 与 LRU 有一个共同点，当内存达到max_memory时，选择key是随机抓取的，因此Redis为了使这种随机性更加准确，设计了一个淘汰池，这个淘汰池对于LFU和LRU算的都适应，只是淘汰池的排序算法有区别而已。</p><h1 id=扩展>扩展<a hidden class=anchor aria-hidden=true href=#扩展>#</a></h1><h2 id=淘汰池的更新策略>淘汰池的更新策略<a hidden class=anchor aria-hidden=true href=#淘汰池的更新策略>#</a></h2><p>这个淘汰池就是使用LRU和LFU时, 需要淘汰key时, 是从淘汰池按时间钟来淘汰, 源码如下:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">60
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">61
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">62
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">63
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">64
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">65
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">66
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">67
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">68
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">69
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">70
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">71
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">72
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">73
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">74
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">75
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">76
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">77
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">78
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">79
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">80
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">81
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">82
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">83
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">84
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">85
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">86
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">87
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">88
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">89
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">90
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">91
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">92
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">93
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">94
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">95
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">96
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">97
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">98
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>evictionPoolPopulate</span>(<span style=color:#66d9ef>int</span> dbid, dict <span style=color:#f92672>*</span>sampledict, dict <span style=color:#f92672>*</span>keydict, <span style=color:#66d9ef>struct</span> evictionPoolEntry <span style=color:#f92672>*</span>pool) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> j, k, count;
</span></span><span style=display:flex><span>    dictEntry <span style=color:#f92672>*</span>samples[server.maxmemory_samples];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    count <span style=color:#f92672>=</span> <span style=color:#a6e22e>dictGetSomeKeys</span>(sampledict,samples,server.maxmemory_samples);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> count; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> idle;
</span></span><span style=display:flex><span>        sds key;
</span></span><span style=display:flex><span>        robj <span style=color:#f92672>*</span>o;
</span></span><span style=display:flex><span>        dictEntry <span style=color:#f92672>*</span>de;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        de <span style=color:#f92672>=</span> samples[j];
</span></span><span style=display:flex><span>        key <span style=color:#f92672>=</span> <span style=color:#a6e22e>dictGetKey</span>(de);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* If the dictionary we are sampling from is not the main
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * dictionary (but the expires one) we need to lookup the key
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * again in the key dictionary to obtain the value object. */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (server.maxmemory_policy <span style=color:#f92672>!=</span> MAXMEMORY_VOLATILE_TTL) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (sampledict <span style=color:#f92672>!=</span> keydict) de <span style=color:#f92672>=</span> <span style=color:#a6e22e>dictFind</span>(keydict, key);
</span></span><span style=display:flex><span>            o <span style=color:#f92672>=</span> <span style=color:#a6e22e>dictGetVal</span>(de);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Calculate the idle time according to the policy. This is called
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * idle just because the code initially handled LRU, but is in fact
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * just a score where an higher score means better candidate. */</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 空闲时间的计算方式 LRU 、 LFU 、最快过期的可以 三种过期策略下 都是不同的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (server.maxmemory_policy <span style=color:#f92672>&amp;</span> MAXMEMORY_FLAG_LRU) {
</span></span><span style=display:flex><span>            idle <span style=color:#f92672>=</span> <span style=color:#a6e22e>estimateObjectIdleTime</span>(o);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (server.maxmemory_policy <span style=color:#f92672>&amp;</span> MAXMEMORY_FLAG_LFU) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* When we use an LRU policy, we sort the keys by idle time
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * so that we expire keys starting from greater idle time.
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * However when the policy is an LFU one, we have a frequency
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * estimation, and we want to evict keys with lower frequency
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * first. So inside the pool we put objects using the inverted
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * frequency subtracting the actual frequency to the maximum
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * frequency of 255. */</span>
</span></span><span style=display:flex><span>            idle <span style=color:#f92672>=</span> <span style=color:#ae81ff>255</span><span style=color:#f92672>-</span><span style=color:#a6e22e>LFUDecrAndReturn</span>(o);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (server.maxmemory_policy <span style=color:#f92672>==</span> MAXMEMORY_VOLATILE_TTL) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* In this case the sooner the expire the better. */</span>
</span></span><span style=display:flex><span>            idle <span style=color:#f92672>=</span> ULLONG_MAX <span style=color:#f92672>-</span> (<span style=color:#66d9ef>long</span>)<span style=color:#a6e22e>dictGetVal</span>(de);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>serverPanic</span>(<span style=color:#e6db74>&#34;Unknown eviction policy in evictionPoolPopulate()&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Insert the element inside the pool.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * First, find the first empty bucket or the first populated
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * bucket that has an idle time smaller than our idle time. */</span>
</span></span><span style=display:flex><span>        k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在这里判断 池中某一个key的空闲时间是否小于 当前key的空闲时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span> (k <span style=color:#f92672>&lt;</span> EVPOOL_SIZE <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>               pool[k].key <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>               pool[k].idle <span style=color:#f92672>&lt;</span> idle) k<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (k <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> pool[EVPOOL_SIZE<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>].key <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* Can&#39;t insert if the element is &lt; the worst element we have
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * and there are no empty buckets. */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (k <span style=color:#f92672>&lt;</span> EVPOOL_SIZE <span style=color:#f92672>&amp;&amp;</span> pool[k].key <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* Inserting into empty position. No setup needed before insert. */</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* Inserting in the middle. Now k points to the first element
</span></span></span><span style=display:flex><span><span style=color:#75715e>             * greater than the element to insert.  */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (pool[EVPOOL_SIZE<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>].key <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* Free space on the right? Insert at k shifting
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * all the elements from k to end to the right. */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* Save SDS before overwriting. */</span>
</span></span><span style=display:flex><span>                sds cached <span style=color:#f92672>=</span> pool[EVPOOL_SIZE<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>].cached;
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>memmove</span>(pool<span style=color:#f92672>+</span>k<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,pool<span style=color:#f92672>+</span>k,
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>sizeof</span>(pool[<span style=color:#ae81ff>0</span>])<span style=color:#f92672>*</span>(EVPOOL_SIZE<span style=color:#f92672>-</span>k<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>                pool[k].cached <span style=color:#f92672>=</span> cached;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* No free space on right? Insert at k-1 */</span>
</span></span><span style=display:flex><span>                k<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* Shift all elements on the left of k (included) to the
</span></span></span><span style=display:flex><span><span style=color:#75715e>                 * left, so we discard the element with smaller idle time. */</span>
</span></span><span style=display:flex><span>                sds cached <span style=color:#f92672>=</span> pool[<span style=color:#ae81ff>0</span>].cached; <span style=color:#75715e>/* Save SDS before overwriting. */</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (pool[<span style=color:#ae81ff>0</span>].key <span style=color:#f92672>!=</span> pool[<span style=color:#ae81ff>0</span>].cached) <span style=color:#a6e22e>sdsfree</span>(pool[<span style=color:#ae81ff>0</span>].key);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>memmove</span>(pool,pool<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,<span style=color:#66d9ef>sizeof</span>(pool[<span style=color:#ae81ff>0</span>])<span style=color:#f92672>*</span>k);
</span></span><span style=display:flex><span>                pool[k].cached <span style=color:#f92672>=</span> cached;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Try to reuse the cached SDS string allocated in the pool entry,
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * because allocating and deallocating this object is costly
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * (according to the profiler, not my fantasy. Remember:
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * premature optimizbla bla bla bla. */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> klen <span style=color:#f92672>=</span> <span style=color:#a6e22e>sdslen</span>(key);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (klen <span style=color:#f92672>&gt;</span> EVPOOL_CACHED_SDS_SIZE) {
</span></span><span style=display:flex><span>            pool[k].key <span style=color:#f92672>=</span> <span style=color:#a6e22e>sdsdup</span>(key);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>memcpy</span>(pool[k].cached,key,klen<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>sdssetlen</span>(pool[k].cached,klen);
</span></span><span style=display:flex><span>            pool[k].key <span style=color:#f92672>=</span> pool[k].cached;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        pool[k].idle <span style=color:#f92672>=</span> idle;
</span></span><span style=display:flex><span>        pool[k].dbid <span style=color:#f92672>=</span> dbid;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><a href=https://cloud.tencent.com/developer/article/1925123 target=_blank rel=noopener>Redis的LRU缓存淘汰算法实现 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href=https://www.cnblogs.com/linxiyue/p/10955533.html target=_blank rel=noopener>Redis中的LFU算法 - 再见紫罗兰 - 博客园 (cnblogs.com)</a></p><p><a href=https://blog.csdn.net/qq_41125219/article/details/120445829 target=_blank rel=noopener>Redis精通系列——LFU算法详述(Least Frequently Used - 最不经常使用)_李子捌的博客-CSDN博客_lfu算法</a></p><p><a href=https://www.jianshu.com/p/c8aeb3eee6bc target=_blank rel=noopener>Redis的缓存淘汰策略LRU与LFU - 简书 (jianshu.com)</a></p><p><a href=https://www.cnblogs.com/hapjin/p/10933405.html target=_blank rel=noopener>Redis的LRU算法 - 演变历程详解 (cnblogs.com)</a></p><p><a href=https://blog.csdn.net/belongtocode/article/details/102989685 target=_blank rel=noopener>全面讲解LRU算法_Apple_Web的博客-CSDN博客_lru 算法</a></p><p><a href=http://www.redis.cn/articles/20161114002.html target=_blank rel=noopener>由浅入深介绍 Redis LRU 策略的具体实现 &ndash; Redis中国用户组（CRUG）</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.github.io/zh/tags/redis/>Redis</a></li><li><a href=https://xiaokunji.github.io/zh/tags/%E7%BB%BC%E5%90%88/>综合</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.github.io/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7%E7%AF%87/python%E6%90%AD%E5%BB%BAidle%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/python%E6%90%AD%E5%BB%BAidle%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/><span class=title>« 上一页</span><br><span>python搭建idle开发环境</span></a>
<a class=next href=https://xiaokunji.github.io/zh/%E7%BB%BC%E5%90%88/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><span class=title>下一页 »</span><br><span>redis底层数据结构</span></a></nav></footer></article></main><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.github.io/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>