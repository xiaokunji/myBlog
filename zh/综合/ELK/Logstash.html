<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Logstash | 米二</title><meta name=keywords content=" 1.input, 1.1 file插件, 1.2 TCP/UDP插件, 2.filter, 2.1 date插件, 2.2 grok插件, 2.3 dissect插件,dissect可以自动处理空的匹配值,dissect分割后的字段值都是字符串，可以使用convert_datatype属性进行类型转换, 2.4 mutate插件, 2.5 json插件, 2.6 geoip插件, 2.7 ruby插件, 3.output, 3.1 elasticsearch插件"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/ELK/Logstash.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/ELK/Logstash.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Logstash"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/ELK/Logstash.html"><meta property="article:section" content="综合"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-08T04:01:12+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Logstash"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"Logstash","item":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/ELK/Logstash.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Logstash","name":"Logstash","description":"     ","keywords":[" 1.input"," 1.1 file插件"," 1.2 TCP/UDP插件"," 2.filter"," 2.1 date插件"," 2.2 grok插件"," 2.3 dissect插件","dissect可以自动处理空的匹配值","dissect分割后的字段值都是字符串，可以使用convert_datatype属性进行类型转换"," 2.4 mutate插件"," 2.5 json插件"," 2.6 geoip插件"," 2.7 ruby插件"," 3.output"," 3.1 elasticsearch插件"],"articleBody":"[toc]\nlogstash全是插件,从input到output,幸运的是官方文档都有些,https://www.elastic.co/guide/en/logstash/6.5/index.html ,\n总感觉logstash和flume很相似,他们都有三个级别,前,中,后,但是他们还是区别,logstash更倾向于日志收集,比较轻量级,flume更倾向于链路路由,比较重量级,https://blog.csdn.net/jek123456/article/details/65658790\n1.input 能从许多地方读取信息,从beats(专门读文件(log)的)工具,elasticsearch,shell,文件,jdbc,kafka,redis,rabbitmp,tcp/udp等等\n1.1 file插件 input{ file{ path =\u003e [\"/var/log/nginx/access.log\", \"/var/log/nginx/error.log\"] #处理的文件的路径, 可以定义多个路径 exclude =\u003e \"*.zip\" #匹配排除 sincedb_path =\u003e \"/data/\" #sincedb数据文件的路径, 默认/plugins/inputs/file codec =\u003e \"plain\" #默认是plain,可通过这个参数设置编码方式 # codec =\u003e multiline { # 管理多线事件,将java的异常归纳到一条数据中 # pattern =\u003e“^\\s” # what =\u003e“previous” # } tags =\u003e [\"nginx\"] #添加标记 type =\u003e \"nginx\" #添加类型 discover_interval =\u003e 2 #每隔多久去查一次文件, 默认15s stat_interval =\u003e 1 #每隔多久去查一次文件是否被修改过, 默认1s start_position =\u003e \"beginning\" #从什么位置开始读取文件数据, beginning和end, 默认是结束位置end } } 原文：https://blog.csdn.net/gekkoou/article/details/809 1.2 TCP/UDP插件 input{ tcp{ port =\u003e 8888 #端口 mode =\u003e \"server\" #操作模式, server:监听客户端连接, client:连接到服务器 host =\u003e \"0.0.0.0\" #当mode为server, 指定监听地址, 当mode为client, 指定连接地址, 默认0.0.0.0 ssl_enable =\u003e false #是否启用SSL, 默认false ssl_cert =\u003e \"\" #SSL证书路径 ssl_extra_chain_certs =\u003e [] #将额外的X509证书添加到证书链中 ssl_key =\u003e \"\" #SSL密钥路径 ssl_key_passphrase =\u003e \"nil\" #SSL密钥密码, 默认nil ssl_verify =\u003e true #核实与CA的SSL连接的另一端的身份 tcp_keep_alive =\u003e false #TCP是否保持alives } } input{ udp{ buffer_size =\u003e 65536 #从网络读取的最大数据包大小, 默认65536 host =\u003e 0.0.0.0 #监听地址 port =\u003e 8888 #端口 queue_size =\u003e 2000 #在内存中保存未处理的UDP数据包的数量, 默认2000 workers =\u003e 2 #处理信息包的数量, 默认2 } } 原文：https://blog.csdn.net/gekkoou/article/details/809 2.filter Filter是Logstash功能强大的主要原因，它可以对Logstash Event进行丰富的处理，比如说解析数据、删除字段、类型转换等等，常见的有如下几个：\ndate: 日志解析 grok：正则匹配解析 dissect：分割符解析 mutate：对字段做处理，比如重命名、删除、替换等 json：按照json解析字段内容到指定字段中 geoip：增加地理位置数据 ruby： 利用ruby代码来动态修改Logstash Event 2.1 date插件 从字段解析日期以用作事件的Logstash时间戳，以下配置解析名为logdate的字段以设置Logstash时间戳：\nfilter { date { match =\u003e [ \"logdate\", \"MMM dd yyyy HH:mm:ss\" ] } } 返回结果:\n{\"logdate\":\"Jan 01 2018 12:02:03\"} { \"@version\" =\u003e \"1\", \"host\" =\u003e \"Node2\", \"@timestamp\" =\u003e 2018-01-01T04:02:03.000Z, \"logdate\" =\u003e \"Jan 01 2018 12:02:03\" } 说明：\nmatch：类型为数组，用于指定日期匹配的格式，可以一次指定多种日志格式\nmatch =\u003e [ \"logdate\", \"MMM dd yyyy HH:mm:ss\" ,\"MMM d yyyy HH:mm:ss\",\"ISO8601\"] target:类型为字符串，用于指定赋值的字段名，默认是@timestamp timezone：类型为字符串，用于指定时区 关于logstash时区的问题可以参考：logstash 时间戳时区问题 2.2 grok插件 将非结构化事件数据分析到字段中。 这个工具非常适用于系统日志，Apache和其他网络服务器日志，MySQL日志，以及通常为人类而不是计算机消耗的任何日志格式。但是消耗的资源也十分巨大\nfilter { grok { match =\u003e { \"message\" =\u003e \"%{IP:client} %{WORD:method} %{URIPATHPARAM:request} %{NUMBER:bytes} %{NUMBER:duration}\" } } } 测试:\n55.3.244.1 GET /index.html 15824 0.043 以下配置将消息解析为字段：\nclient: 55.3.244.1 method: GET request: /index.html bytes: 15824 duration: 0.043 Grok语法：\n%{SYNTAX:SEMANTIC} # SYNTAX为grok pattern的名称，SEMANTIC为赋值字段名称 %{NUMBER:duration}可以匹配数值类型，但是grok匹配出的内容都是字符串类型，可以通过在最后指定为int或者float来强制转换类型。 %{NUMBER:duration:float} 常见pattern可以查看：GitHub 或者logstash家目录下的：\nvendor/bundle/jruby/2.3.0/gems/logstash-patterns-core-4.1.2/patterns 自定义匹配规则：\n格式：(?the pattern here)\npattern_definitions参数，以键值对的方式定义pattern名称和内容 pattern_dir参数，以文件的形式被读取 filter{ grok { match =\u003e {\"message\"=\u003e\"%{SERVICE:service}\"} pattern_definitions =\u003e {\"SERVICE\" =\u003e \"[a-z0-9]{10,11}\"} #patterns_dir =\u003e [\"/opt/logstash/patterns\", \"/opt/logstash/extra_patterns\"] } } tag_on_failure: 默认是_grokparsefailure,可以基于此做判断 调试： 正则表达式： https://regexr.com/ grok： http://grokdebug.herokuapp.com/ http://grok.elasticsearch.cn/ x-pack\n2.3 dissect插件 基于分隔符原理解析数据，解决grok解析时消耗过多cpu资源的问题\n使用分隔符将非结构化事件数据提取到字段中。 解剖过滤器不使用正则表达式，速度非常快。 但是，如果数据的结构因行而异，grok过滤器更合适。\ndissect的应用有一定的局限性：主要适用于每行格式相似且分隔符明确简单的场景 dissect语法比较简单，有一系列字段(field)和分隔符(delimiter)组成\n%{}字段 %{}之间是分隔符 例如，假设日志中包含以下消息：\nApr 26 12:20:02 localhost systemd[1]: Starting system activity accounting tool... 以下配置解析消息：\nfilter { dissect { mapping =\u003e { \"message\" =\u003e \"%{ts} %{+ts} %{+ts} %{src} %{prog}[%{pid}]: %{msg}\" } } } 解剖过滤器应用后，事件将被解剖到以下领域：\n{ \"msg\" =\u003e \"Starting system activity accounting tool...\", \"@timestamp\" =\u003e 2017-04-26T19:33:39.257Z, \"src\" =\u003e \"localhost\", \"@version\" =\u003e \"1\", \"host\" =\u003e \"localhost.localdomain\", \"pid\" =\u003e \"1\", \"message\" =\u003e \"Apr 26 12:20:02 localhost systemd[1]: Starting system activity accounting tool...\", \"type\" =\u003e \"stdin\", \"prog\" =\u003e \"systemd\", \"ts\" =\u003e \"Apr 26 12:20:02\" } 说明\nApr 26 12:20:02 %{ts} %{+ts} %{+ts} #+代表该匹配值追加到ts字段下 { \"ts\":\"Apr 26 12:20:02\" } two three one go %{+order/2} %{+order/3} %{+order/1} %{+order/4} #/后面的数字代表拼接的次序 { \"order\": \"one two three go\" } a=1\u0026b=2 %{?key1}=%{\u0026key1}\u0026%{?key2}=%{\u0026key2} #%{?}代表忽略匹配值，但是富裕字段名，用于后续匹配用；%{\u0026}代表将匹配值赋予key1的匹配值 { \"a\":\"1\", \"b\":\"2\" } #dissect可以自动处理空的匹配值 John Smith,Big Oaks,Wood Lane,Hambledown,Canterbury,CB34RY %{name},%{addr1},%{addr2},%{addr3},%{city},%{zip} Jane Doe,4321 Fifth Avenue,,,New York,87432 { \"name\":\"Jane Doe\", \"addr1\":\"4321 Fifth Avenue\", \"addr2\":\"\", \"addr3\":\"\", \"city\":\"New York\", \"zip\":\"87432\" } #dissect分割后的字段值都是字符串，可以使用convert_datatype属性进行类型转换 filter{ dissect{ convert_datatype =\u003e {age =\u003e \"int\"} } } 2.4 mutate插件 使用最频繁的操作，可以对字段进行各种操作，比如重命名、删除、替换、更新等，主要操作如下：\nconvert #类型转换 gsub #字符串替换 split/join/merge #字符串切割、数组合并为字符串、数组合并为数组 rename #字段重命名 update/replace #字段内容更新或替换 remove_field #删除字段 convert：实现字段类型的转换，类型为hash,仅支持转换为integer、float、string和Boolean filter{ mutate{ convert =\u003e {\"age\" =\u003e \"integer\"} } } gsub：对字段内容进行替换，类型为数组，每3项为一个替换配置 filter { mutate { gsub =\u003e [ # replace all forward slashes with underscore \"fieldname\", \"/\", \"_\", # replace backslashes, question marks, hashes, and minuses # with a dot \".\" \"fieldname2\", \"[\\?#-]\", \".\" ] } } split: 将字符串切割为数组 filter { mutate { split =\u003e { \"fieldname\" =\u003e \",\" } } } join：将数组拼接为字符串 merge：将两个数组合并为1个数组，字符串会被转为1个元素的数组进行操作 rename：字段重命名 update/replace：更新字段内容，区别在于update只在字段存在时生效，而replace在字段不存在时会执行新增字段的操作 filter { mutate { update =\u003e { \"sample\" =\u003e \"My new message\" } update =\u003e { \"message\" =\u003e \"source from c:%{source_host}\" } #%{source_host}可以引用logstash Event中的字段值 } } input { stdin{type=\u003estdin} } filter{ dissect{ mapping =\u003e {\"message\" =\u003e \"%{a}-%{b}-%{c}\"} } mutate{ replace =\u003e {\"d\" =\u003e\"source from c:%{c}\"} } } output{ stdout{codec=\u003erubydebug} } hi-hello-123 { \"a\" =\u003e \"hi\", \"b\" =\u003e \"hello\", \"@timestamp\" =\u003e 2018-06-29T02:01:24.473Z, \"c\" =\u003e \"123\", \"d\" =\u003e \"source from c:123\", \"@version\" =\u003e \"1\", \"host\" =\u003e \"Node2\", \"message\" =\u003e \"hi-hello-123\", \"type\" =\u003e \"stdin\" } 2.5 json插件 将字段内容为json格式的数据进行解析\nfilter { json { source =\u003e \"message\" #要解析的字段名 target =\u003e \"msg_json\" #解析后的存储字段，默认和message同级别 } } 2.6 geoip插件 常用的插件，根据ip地址提供对应的地域信息，比如经纬度、城市名等，方便进行地理数据分析\nfilter { geoip { source =\u003e \"clientip\" } } 2.7 ruby插件 最灵活的插件，可以 以ruby语言来随心所欲的修改Logstash Event对象,ruby能实现逻辑,理论上来说可以完成你想要的任何操作,反正很吊就对了(前提是你得会ruby语言)\nfilter{ ruby{ code =\u003e 'size = event.get(\"message\").size; event.set(\"message_size\",size)' } } ruby { code =\u003e \"event.set('@read_timestamp',event.get('@timestamp'))\" } 原文：https://blog.csdn.net/wfs1994/article/details/80862952\n3.output 能输出到很多地方,比如,csv,elasticsearch,shell,file,kafka,mongDB,rabbitMq,solr,更多的参见官网\n3.1 elasticsearch插件 elasticsearch{ hosts=\u003e[\"172.132.12.3:9200\"] action=\u003e\"index\" index=\u003e\"indextemplate-logstash\" #document_type=\u003e\"%{@type}\" document_id=\u003e\"ignore\" template=\u003e\"/opt/logstash-conf/es-template.json\" template_name=\u003e\"es-template.json\" template_overwrite=\u003etrue } 来自: https://yq.aliyun.com/articles/197785 下载工具:https://motrix.app/zh-CN/\n","wordCount":"3461","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-09-08T04:01:12.394867588Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/ELK/Logstash.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88.html>综合</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/ELK.html>ELK</a> <span>></span></ul></nav><h1 class=post-title>Logstash</h1><div class=post-description></div><div class=post-meta>创建:&nbsp;<span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;更新:&nbsp;2023-09-08&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/%E7%BB%BC%E5%90%88.html>综合</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv>1</span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#1input aria-label=1.input>1.input</a><ul><li><a href=#11-file%e6%8f%92%e4%bb%b6 aria-label="1.1 file插件">1.1 file插件</a></li><li><a href=#12-tcpudp%e6%8f%92%e4%bb%b6 aria-label="1.2 TCP/UDP插件">1.2 TCP/UDP插件</a></li></ul></li><li><a href=#2filter aria-label=2.filter>2.filter</a><ul><li><a href=#21-date%e6%8f%92%e4%bb%b6 aria-label="2.1 date插件">2.1 date插件</a></li><li><a href=#22-grok%e6%8f%92%e4%bb%b6 aria-label="2.2 grok插件">2.2 grok插件</a></li><li><a href=#23-dissect%e6%8f%92%e4%bb%b6 aria-label="2.3 dissect插件">2.3 dissect插件</a></li><li><a href=#24-mutate%e6%8f%92%e4%bb%b6 aria-label="2.4 mutate插件">2.4 mutate插件</a></li><li><a href=#25-json%e6%8f%92%e4%bb%b6 aria-label="2.5 json插件">2.5 json插件</a></li><li><a href=#26-geoip%e6%8f%92%e4%bb%b6 aria-label="2.6 geoip插件">2.6 geoip插件</a></li><li><a href=#27-ruby%e6%8f%92%e4%bb%b6 aria-label="2.7 ruby插件">2.7 ruby插件</a></li></ul></li><li><a href=#3output aria-label=3.output>3.output</a><ul><li><a href=#31-elasticsearch%e6%8f%92%e4%bb%b6 aria-label="3.1 elasticsearch插件">3.1 elasticsearch插件</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><p>logstash全是插件,从input到output,幸运的是官方文档都有些,https://www.elastic.co/guide/en/logstash/6.5/index.html ,</p><blockquote><p>总感觉logstash和flume很相似,他们都有三个级别,前,中,后,但是他们还是区别,logstash更倾向于日志收集,比较轻量级,flume更倾向于链路路由,比较重量级,https://blog.csdn.net/jek123456/article/details/65658790</p></blockquote><h1 id=1input>1.input<a hidden class=anchor aria-hidden=true href=#1input>#</a></h1><p>能从许多地方读取信息,从<code>beats</code>(专门读文件(log)的)工具,<code>elasticsearch</code>,<code>shell</code>,<code>文件</code>,<code>jdbc</code>,<code>kafka</code>,<code>redis</code>,<code>rabbitmp</code>,<code>tcp/udp</code>等等</p><h2 id=11-file插件>1.1 file插件<a hidden class=anchor aria-hidden=true href=#11-file插件>#</a></h2><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>input{
</span></span><span style=display:flex><span>    file{
</span></span><span style=display:flex><span>        path =&gt; [&#34;/var/log/nginx/access.log&#34;, &#34;/var/log/nginx/error.log&#34;] #处理的文件的路径, 可以定义多个路径
</span></span><span style=display:flex><span>        exclude =&gt; &#34;*.zip&#34; #匹配排除
</span></span><span style=display:flex><span>        sincedb_path =&gt; &#34;/data/&#34; #sincedb数据文件的路径, 默认&lt;path.data&gt;/plugins/inputs/file
</span></span><span style=display:flex><span>        codec =&gt; &#34;plain&#34; #默认是plain,可通过这个参数设置编码方式
</span></span><span style=display:flex><span>       # codec =&gt; multiline {  # 管理多线事件,将java的异常归纳到一条数据中
</span></span><span style=display:flex><span>       #   pattern =&gt;“^\s”
</span></span><span style=display:flex><span>       #   what =&gt;“previous”
</span></span><span style=display:flex><span>       # }
</span></span><span style=display:flex><span>        tags =&gt; [&#34;nginx&#34;] #添加标记
</span></span><span style=display:flex><span>        type =&gt; &#34;nginx&#34; #添加类型
</span></span><span style=display:flex><span>        discover_interval =&gt; 2 #每隔多久去查一次文件, 默认15s
</span></span><span style=display:flex><span>        stat_interval =&gt; 1 #每隔多久去查一次文件是否被修改过, 默认1s
</span></span><span style=display:flex><span>        start_position =&gt; &#34;beginning&#34; #从什么位置开始读取文件数据, beginning和end, 默认是结束位置end
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>原文：https://blog.csdn.net/gekkoou/article/details/809
</span></span></code></pre></div><h2 id=12-tcpudp插件>1.2 TCP/UDP插件<a hidden class=anchor aria-hidden=true href=#12-tcpudp插件>#</a></h2><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>input{
</span></span><span style=display:flex><span>    tcp{
</span></span><span style=display:flex><span>       port =&gt; 8888 #端口
</span></span><span style=display:flex><span>       mode =&gt; &#34;server&#34; #操作模式, server:监听客户端连接, client:连接到服务器
</span></span><span style=display:flex><span>       host =&gt; &#34;0.0.0.0&#34; #当mode为server, 指定监听地址, 当mode为client, 指定连接地址, 默认0.0.0.0
</span></span><span style=display:flex><span>       ssl_enable =&gt; false #是否启用SSL, 默认false
</span></span><span style=display:flex><span>       ssl_cert =&gt; &#34;&#34; #SSL证书路径
</span></span><span style=display:flex><span>       ssl_extra_chain_certs =&gt; [] #将额外的X509证书添加到证书链中
</span></span><span style=display:flex><span>       ssl_key =&gt; &#34;&#34; #SSL密钥路径
</span></span><span style=display:flex><span>       ssl_key_passphrase =&gt; &#34;nil&#34; #SSL密钥密码, 默认nil
</span></span><span style=display:flex><span>       ssl_verify =&gt; true #核实与CA的SSL连接的另一端的身份
</span></span><span style=display:flex><span>       tcp_keep_alive =&gt; false #TCP是否保持alives
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>input{
</span></span><span style=display:flex><span>    udp{
</span></span><span style=display:flex><span>       buffer_size =&gt; 65536 #从网络读取的最大数据包大小, 默认65536
</span></span><span style=display:flex><span>       host =&gt; 0.0.0.0 #监听地址
</span></span><span style=display:flex><span>       port =&gt; 8888 #端口
</span></span><span style=display:flex><span>       queue_size =&gt; 2000 #在内存中保存未处理的UDP数据包的数量, 默认2000
</span></span><span style=display:flex><span>       workers =&gt; 2 #处理信息包的数量, 默认2
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>原文：https://blog.csdn.net/gekkoou/article/details/809
</span></span></code></pre></div><h1 id=2filter>2.filter<a hidden class=anchor aria-hidden=true href=#2filter>#</a></h1><p>  Filter是Logstash功能强大的主要原因，它可以对Logstash Event进行丰富的处理，比如说解析数据、删除字段、类型转换等等，常见的有如下几个：</p><ul><li>date: 日志解析</li><li>grok：正则匹配解析</li><li>dissect：分割符解析</li><li>mutate：对字段做处理，比如重命名、删除、替换等</li><li>json：按照json解析字段内容到指定字段中</li><li>geoip：增加地理位置数据</li><li>ruby： 利用ruby代码来动态修改Logstash Event</li></ul><h2 id=21-date插件>2.1 date插件<a hidden class=anchor aria-hidden=true href=#21-date插件>#</a></h2><p>从字段解析日期以用作事件的Logstash时间戳，以下配置解析名为logdate的字段以设置Logstash时间戳：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>filter {
</span></span><span style=display:flex><span>  date {
</span></span><span style=display:flex><span>    match =&gt; [ &#34;logdate&#34;, &#34;MMM dd yyyy HH:mm:ss&#34; ]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>返回结果:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>{&#34;logdate&#34;:&#34;Jan 01 2018 12:02:03&#34;} 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>      &#34;@version&#34; =&gt; &#34;1&#34;,
</span></span><span style=display:flex><span>          &#34;host&#34; =&gt; &#34;Node2&#34;,
</span></span><span style=display:flex><span>    &#34;@timestamp&#34; =&gt; 2018-01-01T04:02:03.000Z,
</span></span><span style=display:flex><span>       &#34;logdate&#34; =&gt; &#34;Jan 01 2018 12:02:03&#34;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>说明：<br>match：类型为数组，用于指定日期匹配的格式，可以一次指定多种日志格式</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>match =&gt; [ &#34;logdate&#34;, &#34;MMM dd yyyy HH:mm:ss&#34; ,&#34;MMM d yyyy HH:mm:ss&#34;,&#34;ISO8601&#34;]
</span></span></code></pre></div><ul><li>target:类型为字符串，用于指定赋值的字段名，默认是@timestamp</li><li>timezone：类型为字符串，用于指定时区</li></ul><p>关于logstash时区的问题可以参考：<a href=https://www.zybuluo.com/StrGlee/note/1179723 target=_blank rel=noopener>logstash 时间戳时区问题</a></p><h2 id=22-grok插件>2.2 grok插件<a hidden class=anchor aria-hidden=true href=#22-grok插件>#</a></h2><p>将非结构化事件数据分析到字段中。 这个工具非常适用于系统日志，Apache和其他网络服务器日志，MySQL日志，以及通常为人类而不是计算机消耗的任何日志格式。但是消耗的资源也十分巨大</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>filter {
</span></span><span style=display:flex><span>  grok {
</span></span><span style=display:flex><span>    match =&gt; { &#34;message&#34; =&gt; &#34;%{IP:client} %{WORD:method} %{URIPATHPARAM:request} %{NUMBER:bytes} %{NUMBER:duration}&#34; }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>测试:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>55.3.244.1 GET /index.html 15824 0.043
</span></span></code></pre></div><p>以下配置将消息解析为字段：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>client: 55.3.244.1
</span></span><span style=display:flex><span>method: GET
</span></span><span style=display:flex><span>request: /index.html
</span></span><span style=display:flex><span>bytes: 15824
</span></span><span style=display:flex><span>duration: 0.043
</span></span></code></pre></div><p>Grok语法：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>%{SYNTAX:SEMANTIC}   # SYNTAX为grok pattern的名称，SEMANTIC为赋值字段名称
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>%{NUMBER:duration}可以匹配数值类型，但是grok匹配出的内容都是字符串类型，可以通过在最后指定为int或者float来强制转换类型。
</span></span><span style=display:flex><span>%{NUMBER:duration:float}
</span></span></code></pre></div><p>常见pattern可以查看：<a href=https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns target=_blank rel=noopener>GitHub</a>
或者logstash家目录下的：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>vendor/bundle/jruby/2.3.0/gems/logstash-patterns-core-4.1.2/patterns
</span></span></code></pre></div><p>自定义匹配规则：<br>格式：<code>(?&lt;field_name>the pattern here)</code></p><ul><li>pattern_definitions参数，以键值对的方式定义pattern名称和内容</li><li>pattern_dir参数，以文件的形式被读取</li></ul><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>filter{
</span></span><span style=display:flex><span>    grok {
</span></span><span style=display:flex><span>        match =&gt; {&#34;message&#34;=&gt;&#34;%{SERVICE:service}&#34;}
</span></span><span style=display:flex><span>        pattern_definitions =&gt; {&#34;SERVICE&#34; =&gt; &#34;[a-z0-9]{10,11}&#34;}
</span></span><span style=display:flex><span>        #patterns_dir =&gt; [&#34;/opt/logstash/patterns&#34;, &#34;/opt/logstash/extra_patterns&#34;]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>tag_on_failure: 默认是_grokparsefailure,可以基于此做判断</li></ul><p>调试：
正则表达式：
<a href=https://regexr.com/ target=_blank rel=noopener>https://regexr.com/</a></p><p>grok：
<a href=http://grokdebug.herokuapp.com/ target=_blank rel=noopener>http://grokdebug.herokuapp.com/</a>
<a href=http://grok.elasticsearch.cn/ target=_blank rel=noopener>http://grok.elasticsearch.cn/</a><br>x-pack</p><h2 id=23-dissect插件>2.3 dissect插件<a hidden class=anchor aria-hidden=true href=#23-dissect插件>#</a></h2><p>基于分隔符原理解析数据，解决grok解析时消耗过多cpu资源的问题</p><p>使用分隔符将非结构化事件数据提取到字段中。 解剖过滤器不使用正则表达式，速度非常快。 但是，如果数据的结构因行而异，grok过滤器更合适。</p><p>dissect的应用有一定的局限性：主要适用于每行格式相似且分隔符明确简单的场景
dissect语法比较简单，有一系列字段(field)和分隔符(delimiter)组成</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>%{}字段
</span></span><span style=display:flex><span>%{}之间是分隔符
</span></span></code></pre></div><p>例如，假设日志中包含以下消息：<br><code>Apr 26 12:20:02 localhost systemd[1]: Starting system activity accounting tool...</code>
以下配置解析消息：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>filter {
</span></span><span style=display:flex><span>  dissect {
</span></span><span style=display:flex><span>    mapping =&gt; { &#34;message&#34; =&gt; &#34;%{ts} %{+ts} %{+ts} %{src} %{prog}[%{pid}]: %{msg}&#34; }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>解剖过滤器应用后，事件将被解剖到以下领域：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>{
</span></span><span style=display:flex><span>  &#34;msg&#34;        =&gt; &#34;Starting system activity accounting tool...&#34;,
</span></span><span style=display:flex><span>  &#34;@timestamp&#34; =&gt; 2017-04-26T19:33:39.257Z,
</span></span><span style=display:flex><span>  &#34;src&#34;        =&gt; &#34;localhost&#34;,
</span></span><span style=display:flex><span>  &#34;@version&#34;   =&gt; &#34;1&#34;,
</span></span><span style=display:flex><span>  &#34;host&#34;       =&gt; &#34;localhost.localdomain&#34;,
</span></span><span style=display:flex><span>  &#34;pid&#34;        =&gt; &#34;1&#34;,
</span></span><span style=display:flex><span>  &#34;message&#34;    =&gt; &#34;Apr 26 12:20:02 localhost systemd[1]: Starting system activity accounting tool...&#34;,
</span></span><span style=display:flex><span>  &#34;type&#34;       =&gt; &#34;stdin&#34;,
</span></span><span style=display:flex><span>  &#34;prog&#34;       =&gt; &#34;systemd&#34;,
</span></span><span style=display:flex><span>  &#34;ts&#34;         =&gt; &#34;Apr 26 12:20:02&#34;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>说明</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Apr 26 12:20:02
</span></span><span style=display:flex><span>%{ts} %{+ts} %{+ts}     #+代表该匹配值追加到ts字段下
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    &#34;ts&#34;:&#34;Apr 26 12:20:02&#34;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>two three one go
</span></span><span style=display:flex><span>%{+order/2} %{+order/3} %{+order/1} %{+order/4}     #/后面的数字代表拼接的次序
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    &#34;order&#34;: &#34;one two three go&#34;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a=1&amp;b=2
</span></span><span style=display:flex><span>%{?key1}=%{&amp;key1}&amp;%{?key2}=%{&amp;key2}  #%{?}代表忽略匹配值，但是富裕字段名，用于后续匹配用；%{&amp;}代表将匹配值赋予key1的匹配值
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    &#34;a&#34;:&#34;1&#34;,
</span></span><span style=display:flex><span>    &#34;b&#34;:&#34;2&#34;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>#dissect可以自动处理空的匹配值
</span></span><span style=display:flex><span>John Smith,Big Oaks,Wood Lane,Hambledown,Canterbury,CB34RY
</span></span><span style=display:flex><span>%{name},%{addr1},%{addr2},%{addr3},%{city},%{zip}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Jane Doe,4321 Fifth Avenue,,,New York,87432
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    &#34;name&#34;:&#34;Jane Doe&#34;,
</span></span><span style=display:flex><span>    &#34;addr1&#34;:&#34;4321 Fifth Avenue&#34;,
</span></span><span style=display:flex><span>    &#34;addr2&#34;:&#34;&#34;,
</span></span><span style=display:flex><span>    &#34;addr3&#34;:&#34;&#34;,
</span></span><span style=display:flex><span>    &#34;city&#34;:&#34;New York&#34;,
</span></span><span style=display:flex><span>    &#34;zip&#34;:&#34;87432&#34;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>#dissect分割后的字段值都是字符串，可以使用convert_datatype属性进行类型转换
</span></span><span style=display:flex><span>filter{
</span></span><span style=display:flex><span>    dissect{
</span></span><span style=display:flex><span>        convert_datatype =&gt; {age =&gt; &#34;int&#34;}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=24-mutate插件>2.4 mutate插件<a hidden class=anchor aria-hidden=true href=#24-mutate插件>#</a></h2><p>使用最频繁的操作，可以对字段进行各种操作，比如重命名、删除、替换、更新等，主要操作如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>convert   #类型转换
</span></span><span style=display:flex><span>gsub      #字符串替换
</span></span><span style=display:flex><span>split/join/merge    #字符串切割、数组合并为字符串、数组合并为数组
</span></span><span style=display:flex><span>rename    #字段重命名
</span></span><span style=display:flex><span>update/replace   #字段内容更新或替换
</span></span><span style=display:flex><span>remove_field     #删除字段
</span></span></code></pre></div><ul><li><code>convert</code>：实现字段类型的转换，类型为hash,仅支持转换为integer、float、string和Boolean</li></ul><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>filter{
</span></span><span style=display:flex><span>    mutate{
</span></span><span style=display:flex><span>        convert =&gt; {&#34;age&#34; =&gt; &#34;integer&#34;}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>gsub</code>：对字段内容进行替换，类型为数组，每3项为一个替换配置</li></ul><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>filter {
</span></span><span style=display:flex><span>  mutate {
</span></span><span style=display:flex><span>    gsub =&gt; [
</span></span><span style=display:flex><span>      # replace all forward slashes with underscore
</span></span><span style=display:flex><span>      &#34;fieldname&#34;, &#34;/&#34;, &#34;_&#34;,
</span></span><span style=display:flex><span>      # replace backslashes, question marks, hashes, and minuses
</span></span><span style=display:flex><span>      # with a dot &#34;.&#34;
</span></span><span style=display:flex><span>      &#34;fieldname2&#34;, &#34;[\?#-]&#34;, &#34;.&#34;
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><ul><li><code>split</code>: 将字符串切割为数组</li></ul><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>filter {
</span></span><span style=display:flex><span>  mutate {
</span></span><span style=display:flex><span>     split =&gt; { &#34;fieldname&#34; =&gt; &#34;,&#34; }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}   
</span></span></code></pre></div><ul><li><code>join</code>：将数组拼接为字符串</li><li><code>merge</code>：将两个数组合并为1个数组，字符串会被转为1个元素的数组进行操作</li><li><code>rename</code>：字段重命名</li><li><code>update/replace</code>：更新字段内容，区别在于update只在字段存在时生效，而replace在字段不存在时会执行新增字段的操作</li></ul><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>filter {
</span></span><span style=display:flex><span>  mutate {
</span></span><span style=display:flex><span>    update =&gt; { &#34;sample&#34; =&gt; &#34;My new message&#34; }
</span></span><span style=display:flex><span>    update =&gt; { &#34;message&#34; =&gt; &#34;source from c:%{source_host}&#34; }   #%{source_host}可以引用logstash Event中的字段值
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}     
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>input {
</span></span><span style=display:flex><span>        stdin{type=&gt;stdin}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>filter{
</span></span><span style=display:flex><span>        dissect{ mapping =&gt; {&#34;message&#34; =&gt; &#34;%{a}-%{b}-%{c}&#34;} }
</span></span><span style=display:flex><span>        mutate{ replace =&gt; {&#34;d&#34; =&gt;&#34;source from c:%{c}&#34;} }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>output{
</span></span><span style=display:flex><span>        stdout{codec=&gt;rubydebug}
</span></span><span style=display:flex><span>}   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hi-hello-123
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>             &#34;a&#34; =&gt; &#34;hi&#34;,
</span></span><span style=display:flex><span>             &#34;b&#34; =&gt; &#34;hello&#34;,
</span></span><span style=display:flex><span>    &#34;@timestamp&#34; =&gt; 2018-06-29T02:01:24.473Z,
</span></span><span style=display:flex><span>             &#34;c&#34; =&gt; &#34;123&#34;,
</span></span><span style=display:flex><span>             &#34;d&#34; =&gt; &#34;source from c:123&#34;,
</span></span><span style=display:flex><span>      &#34;@version&#34; =&gt; &#34;1&#34;,
</span></span><span style=display:flex><span>          &#34;host&#34; =&gt; &#34;Node2&#34;,
</span></span><span style=display:flex><span>       &#34;message&#34; =&gt; &#34;hi-hello-123&#34;,
</span></span><span style=display:flex><span>          &#34;type&#34; =&gt; &#34;stdin&#34;
</span></span><span style=display:flex><span>}       
</span></span></code></pre></div><h2 id=25-json插件>2.5 json插件<a hidden class=anchor aria-hidden=true href=#25-json插件>#</a></h2><p>将字段内容为json格式的数据进行解析</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>filter {
</span></span><span style=display:flex><span>  json {
</span></span><span style=display:flex><span>    source =&gt; &#34;message&#34;     #要解析的字段名
</span></span><span style=display:flex><span>    target =&gt; &#34;msg_json&#34;    #解析后的存储字段，默认和message同级别
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><h2 id=26-geoip插件>2.6 geoip插件<a hidden class=anchor aria-hidden=true href=#26-geoip插件>#</a></h2><p>常用的插件，根据ip地址提供对应的地域信息，比如经纬度、城市名等，方便进行地理数据分析</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>filter {
</span></span><span style=display:flex><span>  geoip {
</span></span><span style=display:flex><span>    source =&gt; &#34;clientip&#34;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=27-ruby插件>2.7 ruby插件<a hidden class=anchor aria-hidden=true href=#27-ruby插件>#</a></h2><p>最灵活的插件，可以 以ruby语言来随心所欲的修改Logstash Event对象,ruby能实现逻辑,理论上来说可以完成你想要的任何操作,反正很吊就对了(前提是你得会ruby语言)</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>filter{
</span></span><span style=display:flex><span>    ruby{
</span></span><span style=display:flex><span>        code =&gt; &#39;size = event.get(&#34;message&#34;).size;
</span></span><span style=display:flex><span>                event.set(&#34;message_size&#34;,size)&#39;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ruby {
</span></span><span style=display:flex><span>        code =&gt; &#34;event.set(&#39;@read_timestamp&#39;,event.get(&#39;@timestamp&#39;))&#34;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>原文：https://blog.csdn.net/wfs1994/article/details/80862952</p><h1 id=3output>3.output<a hidden class=anchor aria-hidden=true href=#3output>#</a></h1><p>能输出到很多地方,比如,<code>csv</code>,<code>elasticsearch</code>,<code>shell</code>,<code>file</code>,<code>kafka</code>,<code>mongDB</code>,<code>rabbitMq</code>,<code>solr</code>,更多的参见官网</p><h2 id=31-elasticsearch插件>3.1 elasticsearch插件<a hidden class=anchor aria-hidden=true href=#31-elasticsearch插件>#</a></h2><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>  elasticsearch{  
</span></span><span style=display:flex><span>    hosts=&gt;[&#34;172.132.12.3:9200&#34;]  
</span></span><span style=display:flex><span>    action=&gt;&#34;index&#34;  
</span></span><span style=display:flex><span>    index=&gt;&#34;indextemplate-logstash&#34;  
</span></span><span style=display:flex><span>    #document_type=&gt;&#34;%{@type}&#34;  
</span></span><span style=display:flex><span>    document_id=&gt;&#34;ignore&#34;  
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>    template=&gt;&#34;/opt/logstash-conf/es-template.json&#34;  
</span></span><span style=display:flex><span>    template_name=&gt;&#34;es-template.json&#34;  
</span></span><span style=display:flex><span>    template_overwrite=&gt;true       
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    来自: https://yq.aliyun.com/articles/197785
</span></span></code></pre></div><p>下载工具:https://motrix.app/zh-CN/</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/ELK.html>ELK</a></li><li><a href=https://xiaokunji.com/zh/tags/%E7%BB%BC%E5%90%88.html>综合</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/log4j2%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97.html><span class=title>« 上一页</span><br><span>log4j2异步日志</span></a>
<a class=next href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/lombok.html><span class=title>下一页 »</span><br><span>lombok</span></a></nav></footer></article></main><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>