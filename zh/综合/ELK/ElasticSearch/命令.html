<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>命令 | 米二</title><meta name=keywords content=" 前言, 1. 基本格式, 2. 命令, 2.1 创建索引, 2.2 插入数据, 2.3 修改数据, 2.4 查看, 2.5 删除, 2.6 简单排序, 3. 复杂查询, 3.1 Query and filter context, 3.1.1 Query context, 3.1.2 Filter context, 3.2 全文查询( Full text), 3.1.1  match  query, 3.1.2 Match Phrase Query, 3.1.3 Multi Match Query, 3.1.4 Query String Query, 3.2 单词级查询(term text), 3.2.1  Term Query, 3.2.2  Terms Query, 3.2.3 Range Query, 3.2.4 Exsit Query, 3.2.5 Prefix Query, 3.2.6 Wildcard Query, 3.2.7 Regexp Query, 3.3 聚合查询, 3.3.1  Metrics aggregations, 3.3.1.1 Min Aggregation, 3.3.1.2 Max Aggregation, 3.3.1.3 Avg Aggregation, 3.3.1.4  Sum Aggregation, 3.3.1.5  Count Aggregation, 3.3.1.6 Cardinality Aggregation, 3.3.1.7 Stats Aggregation, 3.3.1.8  Extended Stats Aggregation, 3.3.1.9 Percentiles Aggregation, 3.3.1.10 Percentiles Ranks Aggregation, 3.3.2  bucket aggregations, 3.3.2.1 Terms Aggregation, 3.2.2.2  Filter Aggregation, 3.2.2.3 Filters Aggregation, 3.2.2.4 Range Aggregation, 3.2.2.5 Date Range Aggr,  3.2.2.6 Range Aggr, 3.4 复合查询, 3.4.1 Bool query, 3.4.2  boosting query"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/ELK/ElasticSearch/%E5%91%BD%E4%BB%A4.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/ELK/ElasticSearch/%E5%91%BD%E4%BB%A4.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="命令"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/ELK/ElasticSearch/%E5%91%BD%E4%BB%A4.html"><meta property="article:section" content="综合"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-11T17:02:27+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="命令"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"命令","item":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/ELK/ElasticSearch/%E5%91%BD%E4%BB%A4.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"命令","name":"命令","description":"     ","keywords":[" 前言"," 1. 基本格式"," 2. 命令"," 2.1 创建索引"," 2.2 插入数据"," 2.3 修改数据"," 2.4 查看"," 2.5 删除"," 2.6 简单排序"," 3. 复杂查询"," 3.1 Query and filter context"," 3.1.1 Query context"," 3.1.2 Filter context"," 3.2 全文查询( Full text)"," 3.1.1  match  query"," 3.1.2 Match Phrase Query"," 3.1.3 Multi Match Query"," 3.1.4 Query String Query"," 3.2 单词级查询(term text)"," 3.2.1  Term Query"," 3.2.2  Terms Query"," 3.2.3 Range Query"," 3.2.4 Exsit Query"," 3.2.5 Prefix Query"," 3.2.6 Wildcard Query"," 3.2.7 Regexp Query"," 3.3 聚合查询"," 3.3.1  Metrics aggregations"," 3.3.1.1 Min Aggregation"," 3.3.1.2 Max Aggregation"," 3.3.1.3 Avg Aggregation"," 3.3.1.4  Sum Aggregation"," 3.3.1.5  Count Aggregation"," 3.3.1.6 Cardinality Aggregation"," 3.3.1.7 Stats Aggregation"," 3.3.1.8  Extended Stats Aggregation"," 3.3.1.9 Percentiles Aggregation"," 3.3.1.10 Percentiles Ranks Aggregation"," 3.3.2  bucket aggregations"," 3.3.2.1 Terms Aggregation"," 3.2.2.2  Filter Aggregation"," 3.2.2.3 Filters Aggregation"," 3.2.2.4 Range Aggregation"," 3.2.2.5 Date Range Aggr","  3.2.2.6 Range Aggr"," 3.4 复合查询"," 3.4.1 Bool query"," 3.4.2  boosting query"],"articleBody":"[toc]\n前言 本文以命令行为主\n其本质还是发送http请求去操作数据\n1. 基本格式 es是以RESTFul风格来命名API的，其API的基本格式如下：\nhttp://:/\u003c索引\u003e/\u003c类型\u003e/\u003c文档id\u003e\n这里需要注意的是，该格式从es7.0.0开始，移除Type（类型）这个概念，新的基本格式如下：\nhttp://:/\u003c索引\u003e/_doc/\u003c文档id\u003e\nType（类型）字段那里变为固定值 _doc\nes的动作是以http方法来决定的: 常用的http方法: GET/PUT/POST/DELETE\npost 主做修改, put主做创建\npost也有创建的功能,特别是插入数据生成随机id时\n2. 命令 2.1 创建索引 curl -XPUT http://localhost:9200/xkj_test 没有指定mappings,故为非结构化索引,也没有字段\n// 结构化索引: 指定了mappings curl -X PUT 'localhost:9200/accounts' -d ' { \"mappings\": { // mappings 映射 \"man\": { // type \"properties\": { // 具体属性 \"name\": { // 字段名 \"type\":\"text\" // 字段类型 // ....还有其他可以选,比如拆分规则,权重值 }, \"country\": { \"type\":\"keyword\" }, \"age\": { \"type\":\"integer\" }, \"date\": { \"type\": \"date\", \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\" } } }, // \"worman\": {} // 6.x版本只支持一个type } } }' 其核心是里面的json字符串\n2.2 插入数据 curl -X POST 'localhost:9200/accounts/person/1000' -d ' // 这个1000表示id,如果不写es会自动生成一个,如果连索引和类型也没有也会一并创建,如果id已存在则修改 { \"user\": \"张三\", \"title\": \"工程师\", \"desc\": \"数据库管理\" }' 格式是 ip:port/索引/类型/id, 参数是各属性的json字符串\n2.3 修改数据 post http://localhost:9200/test/_doc/1/_update { \"script\": { \"lang\": \"painless\", \"inline\": \"ctx._source.age += 30\" } } 关键字”script”: 标志以脚本的方式修改文档\n“lang”：表示以何种脚本语言进行修改，“painless”表示以es内置的脚本语言进行修改。此外es还支持多种脚本语言，如Python，js等等\n“inline”：指定脚本内容 “ctx”代表es上下文，_source 代表文档\n根据条件修改信息:\nPOST my_index/_update_by_query { \"script\": { \"source\": \"ctx._source['ipsub']=0\" }, \"query\": { \"bool\": { \"must_not\": [ { \"exists\": { \"field\": \"ipsub\" } } ] } } 上面语句是根据是否存在\"ipsub\"字段，如果不存在，给信息增加字段\"ipsub\"，并且赋值0\n2.4 查看 查看xkj_test索引数据格式 curl -X GET http://localhost:9200/xkj_test/ 查看xkj_test索引下指定id查看 curl -X GET 'localhost:9200/xkj_test/person/1000?pretty=true' 根据条件查询 curl -X POST 'localhost:9200/accounts/person/_search' -d ' // 要带上 _search 关键字 { \"query\" : { \"match\" : [{ \"desc\" : \"软件\" },{ \"desc\" : \"软件 工程\" }]} }' and 查询: match写多个条件\nor 查询: 利用空格的分词,达到or的效果(我猜的)\n_score ：匹配度\n_source：文档的字段\n来源: https://www.jianshu.com/p/083d99a1db6e es的查询五花八门,最好的技术书籍就是官网,以后好好看,如果要查数据,借助可视化界面就够用了\nhttps://www.elastic.co/guide/en/elasticsearch/reference/current/index.html 2.5 删除 删除xkj_test索引\ndelete http://localhost:9200/xkj_test/ 删除xkj_test索引下的数据(指定id)\ndelete http://localhost:9200/xkj_test/_doc/1 根据条件删除xkj_test索引下test1类型的数据\npost http://localhost:9200/xkj_test/test1/_delete_by_query { \"query\": { \"range\": { \"createDate\": { \"lt\": \"now-31d\" } } } } 解释: 删除 createDate 字段下31天前的数据\n利用_delete_by_query插件去批量删除\nhttps://blog.csdn.net/weixin_44034192/article/details/89372934 2.6 简单排序 按照指定字段排序,(默认按照分数排序)\nGET books/_search { \"sort\": [ \"price\": { \"order\": \"desc\" }, \"age\": { \"order\": \"desc\" } ] } // 按照价格降序排,再按年龄排 在 Elasticsearch 中，默认排序是按照相关性的评分（_score）进行降序排序，也可以按照字段的值排序、多级排序、多值字段排序、基于 geo（地理位置）排序以及自定义脚本排序，除此之外，对于相关性的评分也可以用 rescore 二次、三次打分，它可以限定重新打分的窗口大小（window size），并针对作用范围内的文档修改其得分，从而达到精细化控制结果相关性的目的。\n3. 复杂查询 3.1 Query and filter context 查询子句的行为取决于它是用在查询上下文（query context）还是用在过滤器上下文（filter context）：\n3.1.1 Query context 在查询上下文中的查询子句回答了“这个文档与这个查询子句的匹配程度是怎样的？”问题。除了决定文档是否匹配以外，查询子句还会计算一个“_score”，它表示文档与其他文档的相关程度(分数)。\n3.1.2 Filter context 在过滤器上下文中，一个查询子句回答了“这个文档与查询子句匹配吗？”的问题。这个答案是简单的Yes或者No，也不会计算分数。过滤上下文主要用于过滤结构化数据\nPS：Query VS Filter\n查询反应的是文档与查询子句的匹配程度，而过滤反应的是文档是否匹配查询子句 一个是筛选是否满足条件，情况无非两种：是或不是；一个是看满足条件的记录与查询条件的匹配程度 哪些满足条件，这是过滤；满足条件的这些记录与条件的匹配程度，这是查询 过滤不会计算评分，查询会计算评分 3.2 全文查询( Full text) 3.1.1 match query match查询接受文本/数值/日期类型的数据，分析它们，并构造一个查询。\n相当于模糊查询\nmatch是一种布尔类型的查询。这意味着它对提供的文本进行分析，并在分析的过程中为提供的文本构造一个布尔查询。operator 选项可以设置为 or 或者 and 以此来控制布尔子句（默认是 or ）。例如\ncurl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"match\" : { \"skuName\" : \"空调\" } } }' 3.1.2 Match Phrase Query match_phrase 查询与 match类似，但是它是用于精确匹配或单词接近匹配的。例如：\ncurl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"match_phrase\" : { \"skuName\" : \"this is a test\" } } }' 3.1.3 Multi Match Query multi_match 相当于 match 的多字段版本, multi_match可以指定多个字段，而match只能针对一个字段\ncurl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"multi_match\" : { \"query\": \"this is a test\", \"fields\": [ \"subject\", \"skuName\" ] } } } ' fields 里的字段用 * 支持模糊匹配, 写成这种 [ \"subject^3\", \"skuName\" ] 表示subject比skuName重要3倍 3.1.4 Query String Query 支持Lucene查询字符串语法，允许指定 AND | OR | NOT ，并且在单个查询字符串中进行多字段查询, 分词后对每个词都查询\ncurl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"query_string\" : { \"default_field\" : \"skuName\", \"query\" : \"this that thus\" } } } ' // 在skuName中查询 this , that , thus 三个词 , 其实质解析成: \" this OR that OR thus\", 你可以替换OR为AND/NOT // 还可以指定快 例如: \"query\" : \"(new york city) OR (big apple)\" 这样将被拆分成 “new york city” 和 “big apple” 两部分，并且每一部分都被分析器独立分析 curl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"query_string\" : { \"fields\" : [\"content\", \"name\"], \"query\" : \"this AND that\" } } } ' // 等价于 curl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"query_string\": { \"query\": \"(content:this OR name:this) AND (content:that OR name:that)\" } } } ' 注意，按操作符拆分\nquery_string的参数包括：\nquery　实例被解析的查询文本\ndefault_field　如果没有指定前缀字段的话，这是默认的查询字段。（默认查询所有字段）\ndefault_operator　如果没有明确指定操作符的话，那么这是默认的操作符。例如，如果默认操作符是OR的话，那么“my name is jack”将被翻译成“my OR name OR is OR jack”，同理，如果是AND，则被翻译成“my AND name AND is AND jack”\nanalyzer　用来解析查询字符串的解析器的名字\nallow_leading_wildcard　如果设置了，那么 * 或 ? 允许作为第一个字符。默认是true\nlenient　如果设置为true，则格式失败将被忽略\n3.2 单词级查询(term text) 全文本查询会在执行之前对查询字符串进行分析，而单词级别查询会对存储在反向索引中的精确的term进行操作。\n这些查询通常用于结构化的数据，比如：numbers ， dates ，enums 等，而不是对全文本字段。\n（PS：也就是说，全文本查询之前要先对文本内容进行分词，而单词级别的查询直接在相应字段的反向索引中精确查找，单词级别的查询一般用于数值、日期等类型的字段上）\n3.2.1 Term Query 在指定的字段中查找包含指定的精确的term的文档\nterm查询将在反向索引（或者叫倒排索引）中查找包含特定的精确的term的文档。例如：\ncurl -X POST \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"term\" : { \"user\" : \"Kimchy\" } } } ' // 查询倒排索引(切词后)中user包含\"kimchy\"字符串的值, 3.2.2 Terms Query 查找包含指定字段中指定的任何确切term的文档\n筛选出与所提供的terms中任何一个匹配的文档\ncurl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"terms\" : { \"user\" : [\"kimchy\", \"elasticsearch\"]} } } ' // 查询 切词后包含\"kimchy\"或者 \"elasticsearch\"文档 3.2.3 Range Query 查找指定字段在指定范围内包含值（日期、数字或字符串）的文档。\n下面的例子返回age字段的值在10到20之间的文档：\ncurl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"range\" : { \"age\" : { \"gte\" : 10, \"lte\" : 20, \"boost\" : 2.0 } } } } ' range查询可以接受下列参数：\ngte　大于或等于\ngt　大于\nlte　小于或等于\nlt　小于\nboost　设置boost值，默认是1.0\n在日期范围查询的时候，我们可以指定日期格式。例如：(时间格式es会自动转化,用字符串去查时间格式也能行)\ncurl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"range\" : { \"born\" : { \"gte\": \"01/01/2012\", \"lte\": \"2013\", \"format\": \"dd/MM/yyyy||yyyy\" } } } } ' // 这个例子是查询在2012-01-01到2013-12-31之间出生的人 curl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"range\" : { \"timestamp\" : { \"gte\": \"2015-01-01 00:00:00\", \"lte\": \"now\", \"time_zone\": \"+01:00\" } } } } ' 3.2.4 Exsit Query 在特定的字段中查找非空值的文档\ncurl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"exists\" : { \"field\" : \"user\" } } } ' 3.2.5 Prefix Query 查找包含带有指定前缀的term的文档\ncurl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"prefix\" : { \"user\" : \"ki\" } } } ' 3.2.6 Wildcard Query 支持通配符查询，*表示任意字符，?表示任意单个字符\n这个查询效率比较慢\ncurl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"wildcard\" : { \"user\" : \"ki*y\" } } } ' 3.2.7 Regexp Query curl -X GET \"localhost:9200/_search\" -H 'Content-Type: application/json' -d' { \"query\": { \"regexp\":{ \"name.first\": \"s.*y\" } } } ' prefix 和 wildcard 和 regexp 三者工作方式是一样的 ,需要扫描倒排索引中的词列表才能找到所有匹配的词，然后依次获取每个词相关的文档 ID\n性能对比: prefix \u003e wildcard \u003e regexp\nwildcard 和 regexp要避免左模糊查询\n官网 3.3 聚合查询 Elasticsearch 的聚合（Aggregations）功能十分强大，允许在数据上做复杂的分析统计。Elasticsearch 提供的聚合分析功能主要有指标聚合（metrics aggregations）、桶聚合（bucket aggregations）、管道聚合（pipeline aggregations） 三大类，\n所有的聚合，无论它们是什么类型，都遵从以下的规则。\n使用查询中同样的 JSON 请求来定义它们，而且你是使用键 aggregations 或者是 aggs 来进行标记。需要给每个聚合起一个名字，指定它的类型以及和该类型相关的选项。 它们运行在查询的结果之上。和查询不匹配的文档不会计算在内，除非你使用 global 聚集将不匹配的文档囊括其中。 可以进一步过滤查询的结果，而不影响聚集。 以下是聚合的基本结构：\n\"aggregations\" : { \"\" : { \"\" : { } [,\"meta\" : { [] } ]? [,\"aggregations\" : { []+ } ]? } [,\"\" : { ... } ]* } 在最上层有一个 aggregations 的键，可以缩写为 aggs。 在下面一层，需要为聚合指定一个名字。可以在请求的返回中看到这个名字。在同一个请求中使用多个聚合时，这一点非常有用，它让你可以很容易地理解每组结果的含义。 最后，必须要指定聚合的类型。 关于聚合分析的值来源，可以取字段的值，也可以是脚本计算的结果。\n但是用脚本计算的结果时，需要注意脚本的性能和安全性；尽管多数聚集类型允许使用脚本，但是脚本使得聚集变得缓慢，因为脚本必须在每篇文档上运行。为了避免脚本的运行，可以在索引阶段进行计算。\n此外，脚本也可以被人可能利用进行恶意代码攻击，尽量使用沙盒（sandbox）内的脚本语言。\ntext类型默认不支持聚合\n查询所有球员的平均年龄是多少，并对球员的平均薪水加 188（也可以理解为每名球员加 188 后的平均薪水）。\nPOST /player/_search?size=0 { \"aggs\": { \"avg_age\": { \"avg\": { \"field\": \"age\" } }, \"avg_salary_188\": { \"avg\": { \"script\": { \"source\": \"doc.salary.value + 188\" } } } } } // 默认情况下，包含聚合的搜索会返回搜索命中和聚合结果, size 表示返回命中的文档数量,设为0表示只返回聚合结果 3.3.1 Metrics aggregations 指标聚合（又称度量聚合）主要从不同文档的分组中提取统计数据，或者，从来自其他聚合的文档桶来提取统计数据。\n这些统计数据通常来自数值型字段，如最小或者平均价格。用户可以单独获取每项统计数据，或者也可以使用 stats 聚合来同时获取它们。更高级的统计数据，如平方和或者是标准差，可以通过 extended stats 聚合来获取。\n3.3.1.1 Min Aggregation Min Aggregation 用于最小值统计。例如，统计 sales 索引中价格最低的是哪本书，查询语句如下：\nGET /sales/_search?size=0 { \"aggs\" : { \"min_price\" : { \"min\" : { \"field\" : \"price\" } } } } 聚合结果如下：\n{ ... \"aggregations\": { \"min_price\": { \"value\": 18.0 } } } 3.3.1.2 Max Aggregation Max Aggregation 用于最大值统计。例如，统计 sales 索引中type是hat的且价格最高的是哪本书，并且计算出对应的价格的 2 倍值，查询语句如下：\nGET /sales/_search?size=0 { \"query\" : { \"constant_score\" : { \"filter\" : { \"match\" : { \"type\" : \"hat\" } } } }, \"aggs\" : { \"max_price\" : { \"max\" : { \"field\" : \"price\" , \"missing\": 60 } }, \"max_price_2\" : { \"max\" : { \"field\" : \"price\", \"script\": { \"source\": \"_value * 2.0\" } } } } } 指定的 field，在脚本中可以用 _value 取字段的值。\n如果指定字段没有值，可以通过 missing 指定默认值；若未指定默认值，缺失该字段值的文档将被忽略（计算）。\n聚合结果如下：\n{ ... \"aggregations\": { \"max_price\": { \"value\": 188.0 }, \"max_price_2\": { \"value\": 376.0 } } } 3.3.1.3 Avg Aggregation Avg Aggregation 用于计算平均值。例如，统计 exams 索引中考试的平均分数，\nGET /exams/_search?size=0 { \"aggs\" : { \"avg_grade\" : { \"avg\" : { \"field\" : \"grade\" } } } } { ... \"aggregations\": { \"avg_grade\": { \"value\": 78.0 } } } 除了常规的平均值聚合计算外，elasticsearch 还提供了加权平均值的聚合计算， 详情参见 Elasticsearch 指标聚合之 Weighted Avg Aggregation 。\n用加权平均值代替原本值\n3.3.1.4 Sum Aggregation Sum Aggregation 用于计算总和。\nGET /exams/_search?size=0 { \"aggs\" : { \"hat_prices\" : { \"sum\" : { \"field\" : \"price\" } } } } { ... \"aggregations\": { \"hat_prices\": { \"value\": 567.0 } } } 3.3.1.5 Count Aggregation Count Aggregation 可按字段统计文档数量。例如，统计 books 索引中包含 author 字段的文档数量，查询语句如下：\nGET /books/_search?size=0 { \"aggs\" : { \"doc_count\" : { \"value_count\" : { \"field\" : \"author\" } } } } { ... \"aggregations\": { \"doc_count\": { \"value\": 5 } } } 3.3.1.6 Cardinality Aggregation Cardinality Aggregation 用于基数统计，其作用是先执行类似 SQL 中的 distinct 操作，去掉集合中的重复项，然后统计排重后的集合长度。\n例如，在 books 索引中对 language 字段进行 cardinality 操作可以统计出编程语言的种类数，查询语句如下：\nGET /books/_search?size=0 { \"aggs\" : { \"all_lan\" : { \"cardinality\" : { \"field\" : \"language\" } }, \"title_cnt\" : { \"cardinality\" : { \"field\" : \"title.keyword\" } } } } 假设 title 字段为文本类型（text），去重时需要指定 keyword，表示把 title 作为整体去重，即不分词统计。\n{ ... \"aggregations\": { \"all_lan\": { \"value\": 8 }, \"title_cnt\": { \"value\": 18 } } } 3.3.1.7 Stats Aggregation Stats Aggregation 用于基本统计，会一次返回 count、max、min、avg 和 sum 这 5 个指标。例如，在 exams 索引中对 grade 字段进行分数相关的基本统计，查询语句如下：\nGET /exams/_search?size=0 { \"aggs\" : { \"grades_stats\" : { \"stats\" : { \"field\" : \"grade\" } } } } 3.3.1.8 Extended Stats Aggregation Extended Stats Aggregation 用于高级统计，和基本统计功能类似，但是会比基本统计多出以下几个统计结果，sum_of_squares（平方和）、variance（方差）、std_deviation（标准差）、std_deviation_bounds（平均值加/减两个标准差的区间）。在 exams 索引中对 grade 字段进行分数相关的高级统计，查询语句如下：\nGET /exams/_search?size=0 { \"aggs\" : { \"grades_stats\" : { \"extended_stats\" : { \"field\" : \"grade\" } } } } 3.3.1.9 Percentiles Aggregation Percentiles Aggregation 用于百分位统计。百分位数是一个统计学术语，如果将一组数据从大到小排序，并计算相应的累计百分位，某一百分位所对应数据的值就称为这一百分位的百分位数。默认情况下，累计百分位为 [ 1, 5, 25, 50, 75, 95, 99 ],也可以用percents指定范围。以下例子给出了在 latency 索引中对 load_time 字段进行加载时间的百分位统计，查询语句如下：\nGET latency/_search { \"size\": 0, \"aggs\" : { \"load_time_outlier\" : { \"percentiles\" : { \"field\" : \"load_time\" , \"percents\":[30,45] //查询第30%和45%的数据 } } } } 需要注意的是，如上的 load_time 字段必须是数字类型。\n{ ... \"aggregations\": { \"load_time_outlier\": { \"values\" : { \"1.0\": 5.0, \"5.0\": 25.0, \"25.0\": 165.0, \"50.0\": 445.0, \"75.0\": 725.0, \"95.0\": 945.0, \"99.0\": 985.0 } } } } 第1%位的数据是5\n第5%位的数据是25\n……\n第99%位的数据是99\n3.3.1.10 Percentiles Ranks Aggregation Percentiles Ranks Aggregation 与 Percentiles Aggregation 统计恰恰相反，就是想看当前数值处在什么范围内（百分位）， 假如你查一下当前值 500 和 600 所处的百分位，发现是 90.01 和 100，那么说明有 90.01 % 的数值都在 500 以内，100 % 的数值在 600 以内。\nGET latency/_search { \"size\": 0, \"aggs\" : { \"load_time_ranks\" : { \"percentile_ranks\" : { \"field\" : \"load_time\", \"values\" : [500, 600] } } } } 同样 load_time 字段必须是数字类型。\n{ ... \"aggregations\": { \"load_time_ranks\": { \"values\" : { \"500.0\": 90.01, \"600.0\": 100.0 } } } } 可以设置 keyed 参数为 true，将对应的 values 作为桶 key 一起返回，默认是 false。\nGET latency/_search { \"size\": 0, \"aggs\": { \"load_time_ranks\": { \"percentile_ranks\": { \"field\": \"load_time\", \"values\": [500, 600], \"keyed\": true } } } } { ... \"aggregations\": { \"load_time_ranks\": { \"values\": [ { \"key\": 500.0, \"value\": 90.01 }, { \"key\": 600.0, \"value\": 100.0 } ] } } } 3.3.2 bucket aggregations bucket 可以理解为一个桶，它会遍历文档中的内容，凡是符合某一要求的就放入一个桶中，分桶相当于 SQL 中的 group by。从另外一个角度，可以将指标聚合看成单桶聚合，即把所有文档放到一个桶中，而桶聚合是多桶型聚合，它根据相应的条件进行分组。\n桶数最多 65536 个,可修改\n3.3.2.1 Terms Aggregation Terms Aggregation 用于词项的分组聚合。最为经典的用例是获取 X 中最频繁（top frequent）的项目，其中 X 是文档中的某个字段，如用户的名称、标签或分类。由于 terms 聚集统计的是每个词条，而不是整个字段值，因此通常需要在一个非分析型的字段上运行这种聚集。原因是, 你期望“big data”作为词组统计，而不是“big”单独统计一次，“data”再单独统计一次。\n支持字段类型 Keyword, Numeric, ip, boolean, binary.\n用户可以使用 terms 聚集，从分析型字段（如内容）中抽取最为频繁的词条。还可以使用这种信息来生成一个单词云。\n{ \"aggs\": { \"profit_terms\": { \"terms\": { \"field\": \"skuName\" } } } } 结果:\n{ ... \"aggregations\": { \"genres\": { \"doc_count_error_upper_bound\": 0, // 错误文档的个数 \"sum_other_doc_count\": 0, // 未统计的文档个数 \"buckets\": [ { \"key\": \"electronic\", \"doc_count\": 6 }, { \"key\": \"rock\", \"doc_count\": 3 }, { \"key\": \"jazz\", \"doc_count\": 2 } ] } } } 返回值中,默认按doc_count数量降序排序, 可以用order字段指定排序规则\n可以用size字段控制返回的桶数\n3.2.2.2 Filter Aggregation Filter Aggregation 是过滤器聚合，可以把符合过滤器中的条件的文档分到一个桶中，即是单分组聚合。\n{ \"aggs\": { \"age_terms\": { \"filter\": {\"term\":{\"gender\":\"F\"}}, \"aggs\": { \"avg_age\": { \"avg\": { \"field\": \"age\" } } } } } } 在聚合操作中加入过滤,比 过滤后再聚合要差, 上面的效率比下面的效率要差\nPOST /sales/_search?size=0\u0026filter_path=aggregations { \"query\": { \"term\": { \"type\": \"t-shirt\" } }, \"aggs\": { \"avg_price\": { \"avg\": { \"field\": \"price\" } } } } 3.2.2.3 Filters Aggregation Filters Aggregation 是多过滤器聚合，可以把符合多个过滤条件的文档分到不同的桶中，即每个分组关联一个过滤条件，并收集所有满足自身过滤条件的文档。\n{ \"size\": 0, \"aggs\": { \"messages\": { \"filters\": { \"filters\": { \"errors\": { \"match\": { \"body\": \"error\" } }, \"warnings\": { \"match\": { \"body\": \"warning\" } } } } } } } 在这个例子里，我们分析日志信息。聚合会创建两个关于日志数据的分组，一个收集包含错误信息的文档，另一个收集包含告警信息的文档。而且每个分组会按月份划分。\nfilters 写多个过滤器比 写过filter效率好\n3.2.2.4 Range Aggregation Range Aggregation 范围聚合是一个基于多组值来源的聚合，可以让用户定义一系列范围，每个范围代表一个分组。在聚合执行的过程中，从每个文档提取出来的值都会检查每个分组的范围，并且使相关的文档落入分组中。注意，范围聚合的每个范围内包含 from 值但是排除 to 值。\n{ \"aggs\": { \"age_range\": { \"range\": { \"field\": \"age\", \"ranges\": [{ \"to\": 25 }, { \"from\": 25, \"to\": 35 }, { \"from\": 35 }] }, \"aggs\": { \"bmax\": { \"max\": { \"field\": \"balance\" } } } } } } } 3.2.2.5 Date Range Aggr 日期范围聚合是专用于日期值的范围聚合。该聚合和正常的 范围 聚合的区别主要在于：该聚合可以用 日期数学 表达式表示 from 值 和 to 值，还可以指定 返回 from 和 to 响应字段的日期格式。注意，该聚合包含 from 值，但不包含 to 值。(左闭右开的区间)\nPOST /sales/_search?size=0 { \"aggs\": { \"range\": { \"date_range\": { \"field\": \"date\", \"format\": \"MM-yyyy\", \"ranges\": [ { \"to\": \"now-10M/M\" }, { \"from\": \"now-10M/M\" } ] } } } } to: \u003c 现在减去 10 个月，向下舍入到月初\nfrom: \u003e= 现在减去 10 个月，向下舍入到月初\n在上面的例子中，我们创建了两个范围桶，第一个桶会将早于 10 个月之前的所有文档存储，第二个桶会将从 10 月之前开始的文档存储。\n{ ... \"aggregations\": { \"range\": { \"buckets\": [ { \"to\": 1.4436576E12, \"to_as_string\": \"10-2015\", \"doc_count\": 7, \"key\": \"*-10-2015\" }, { \"from\": 1.4436576E12, \"from_as_string\": \"10-2015\", \"doc_count\": 0, \"key\": \"10-2015-*\" } ] } } } 时间格式和java的一样\nes-中文文档 3.2.2.6 Range Aggr 基于多桶值源的聚合，使用户能够定义一组范围 - 每个范围代表一个桶。 在聚合过程中，将从每个文档中提取的值根据每个存储区范围进行检查，并将相关/匹配文档“存储”到“存储区”中。 请注意，该聚合包含 from 值，但不包含 to 值\nGET /_search { \"aggs\": { \"price_ranges\": { \"range\": { \"field\": \"price\", \"ranges\": [ { \"to\": 100.0 }, { \"from\": 100.0, \"to\": 200.0 }, { \"from\": 200.0 } ] } } } } 结果:\n{ ... \"aggregations\": { \"price_ranges\": { \"buckets\": [ { \"key\": \"*-100.0\", \"to\": 100.0, \"doc_count\": 2 }, { \"key\": \"100.0-200.0\", \"from\": 100.0, \"to\": 200.0, \"doc_count\": 2 }, { \"key\": \"200.0-*\", \"from\": 200.0, \"doc_count\": 3 } ] } } } 3.4 复合查询 复合查询包装其他复合查询或叶查询，以组合它们的结果和分数，改变它们的行为，或者从查询切换到过滤上下文。\n简单的说是 将多种查询条件组合到一起\n3.4.1 Bool query filter\n子句在过滤器上下文中执行，这意味着计分被忽略，并且子句被视为用于缓存。(过滤掉不要的数据)\nmust\n子句（查询）必须出现在匹配的文档中，并将有助于得分。(用来做匹配的,表示需要出现在文档里)\nmust_not\n子句（查询）不得出现在匹配的文档中。子句在过滤器上下文中执行，这意味着计分被忽略，并且子句被视为用于缓存。\nshould\n子句（查询）应出现在匹配的文档中。【注意should的最小匹配数】\n关于should子句，特别要注意：\n如果这个布尔查询位于query context，并且有must或者filter子句，那么即使should子句没有匹配任何文档，也没关系\n如果是位于filter context，或者既没有must也没有filter，那么至少有\"指定\"个should查询必须匹配文档。这个行为可以通过设置minimum_should_match参数来显式地控制。(至少满足几个should子句), 可以是正负整数/正负百分比等各种比例 (默认值是0)\n参数详情 GET product/_search { \"query\": { \"bool\": { \"filter\": [ { \"range\": { \"sellPrice\": { \"gte\": 1 } } } ], \"must\": [ { \"match\": { \"skuName\": \"空调\" } } ] } } , \"_source\": \"skuName\" } // 查询skuName中\"空调\"的文档,并且过滤出sellPrice大于等于1的文档 filter 子句类可包含 bool query，实现更复杂的逻辑, (俄罗斯套娃之深圳分套)\n// 多个条件 GET service-java-logs-2021.07.16/_search { \"_source\": \"message\", \"query\": { \"bool\": { \"must\": [ { \"match_phrase\": { \"message\": \"ERROR\" } } ], \"must_not\": [ { \"wildcard\": { \"message\": \"*navigation*\" } }, { \"match\": { \"message\": \"defaultParameterMap\" } }, { \"match\": { \"message\": \"parameters\" } } ], \"filter\": [ { \"term\": { \"log.file.path.keyword\": \"/opt/online-shop-manage/logs/online-shop-manage-provider.log\" } } ] } } } 3.4.2 boosting query 来源:\nhttps://www.cnblogs.com/hong-fithing/p/11221020.html http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html https://www.cnblogs.com/hirampeng/p/10035858.html https://www.cnblogs.com/cjsblog/p/9910788.html 微信es系列 https://www.knowledgedict.com/tutorial/elasticsearch-sort.html ","wordCount":"8322","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-09-11T17:02:27.955865206+08:00","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/ELK/ElasticSearch/%E5%91%BD%E4%BB%A4.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88.html>综合</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/ELK.html>ELK</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/ELK/ElasticSearch.html>ElasticSearch</a> <span>></span></ul></nav><h1 class=post-title>命令</h1><div class=post-description></div><div class=post-meta>创建:&nbsp;<span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;更新:&nbsp;2023-09-11&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/%E7%BB%BC%E5%90%88.html>综合</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv>1</span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#1-%e5%9f%ba%e6%9c%ac%e6%a0%bc%e5%bc%8f aria-label="1. 基本格式">1. 基本格式</a></li><li><a href=#2-%e5%91%bd%e4%bb%a4 aria-label="2. 命令">2. 命令</a><ul><li><a href=#21-%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95 aria-label="2.1 创建索引">2.1 创建索引</a></li><li><a href=#22-%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae aria-label="2.2 插入数据">2.2 插入数据</a></li><li><a href=#23-%e4%bf%ae%e6%94%b9%e6%95%b0%e6%8d%ae aria-label="2.3 修改数据">2.3 修改数据</a></li><li><a href=#24-%e6%9f%a5%e7%9c%8b aria-label="2.4 查看">2.4 查看</a></li><li><a href=#25-%e5%88%a0%e9%99%a4 aria-label="2.5 删除">2.5 删除</a></li><li><a href=#26-%e7%ae%80%e5%8d%95%e6%8e%92%e5%ba%8f aria-label="2.6 简单排序">2.6 简单排序</a></li></ul></li><li><a href=#3-%e5%a4%8d%e6%9d%82%e6%9f%a5%e8%af%a2 aria-label="3. 复杂查询">3. 复杂查询</a><ul><li><a href=#31-query-and-filter-context aria-label="3.1 Query and filter context">3.1 Query and filter context</a><ul><li><a href=#311-query-context aria-label="3.1.1 Query context">3.1.1 Query context</a></li><li><a href=#312-filter-context aria-label="3.1.2 Filter context">3.1.2 Filter context</a></li></ul></li><li><a href=#32-%e5%85%a8%e6%96%87%e6%9f%a5%e8%af%a2-full-text aria-label="3.2 全文查询( Full text)">3.2 全文查询( Full text)</a><ul><li><a href=#311--match--query aria-label="3.1.1  match  query">3.1.1 match query</a></li><li><a href=#312-match-phrase-query aria-label="3.1.2 Match Phrase Query">3.1.2 Match Phrase Query</a></li><li><a href=#313-multi-match-query aria-label="3.1.3 Multi Match Query">3.1.3 Multi Match Query</a></li><li><a href=#314-query-string-query aria-label="3.1.4 Query String Query">3.1.4 Query String Query</a></li></ul></li><li><a href=#32-%e5%8d%95%e8%af%8d%e7%ba%a7%e6%9f%a5%e8%af%a2term-text aria-label="3.2 单词级查询(term text)">3.2 单词级查询(term text)</a><ul><li><a href=#321--term-query aria-label="3.2.1  Term Query">3.2.1 Term Query</a></li><li><a href=#322--terms-query aria-label="3.2.2  Terms Query">3.2.2 Terms Query</a></li><li><a href=#323-range-query aria-label="3.2.3 Range Query">3.2.3 Range Query</a></li><li><a href=#324-exsit-query aria-label="3.2.4 Exsit Query">3.2.4 Exsit Query</a></li><li><a href=#325-prefix-query aria-label="3.2.5 Prefix Query">3.2.5 Prefix Query</a></li><li><a href=#326-wildcard-query aria-label="3.2.6 Wildcard Query">3.2.6 Wildcard Query</a></li><li><a href=#327-regexp-query aria-label="3.2.7 Regexp Query">3.2.7 Regexp Query</a></li></ul></li><li><a href=#33-%e8%81%9a%e5%90%88%e6%9f%a5%e8%af%a2 aria-label="3.3 聚合查询">3.3 聚合查询</a><ul><li><a href=#331--metrics-aggregations aria-label="3.3.1  Metrics aggregations">3.3.1 Metrics aggregations</a><ul><li><a href=#3311-min-aggregation aria-label="3.3.1.1 Min Aggregation">3.3.1.1 Min Aggregation</a></li><li><a href=#3312-max-aggregation aria-label="3.3.1.2 Max Aggregation">3.3.1.2 Max Aggregation</a></li><li><a href=#3313-avg-aggregation aria-label="3.3.1.3 Avg Aggregation">3.3.1.3 Avg Aggregation</a></li><li><a href=#3314--sum-aggregation aria-label="3.3.1.4  Sum Aggregation">3.3.1.4 Sum Aggregation</a></li><li><a href=#3315--count-aggregation aria-label="3.3.1.5  Count Aggregation">3.3.1.5 Count Aggregation</a></li><li><a href=#3316-cardinality-aggregation aria-label="3.3.1.6 Cardinality Aggregation">3.3.1.6 Cardinality Aggregation</a></li><li><a href=#3317-stats-aggregation aria-label="3.3.1.7 Stats Aggregation">3.3.1.7 Stats Aggregation</a></li><li><a href=#3318--extended-stats-aggregation aria-label="3.3.1.8  Extended Stats Aggregation">3.3.1.8 Extended Stats Aggregation</a></li><li><a href=#3319-percentiles-aggregation aria-label="3.3.1.9 Percentiles Aggregation">3.3.1.9 Percentiles Aggregation</a></li><li><a href=#33110-percentiles-ranks-aggregation aria-label="3.3.1.10 Percentiles Ranks Aggregation">3.3.1.10 Percentiles Ranks Aggregation</a></li></ul></li><li><a href=#332--bucket-aggregations aria-label="3.3.2  bucket aggregations">3.3.2 bucket aggregations</a><ul><li><a href=#3321-terms-aggregation aria-label="3.3.2.1 Terms Aggregation">3.3.2.1 Terms Aggregation</a></li><li><a href=#3222--filter-aggregation aria-label="3.2.2.2  Filter Aggregation">3.2.2.2 Filter Aggregation</a></li><li><a href=#3223-filters-aggregation aria-label="3.2.2.3 Filters Aggregation">3.2.2.3 Filters Aggregation</a></li><li><a href=#3224-range-aggregation aria-label="3.2.2.4 Range Aggregation">3.2.2.4 Range Aggregation</a></li><li><a href=#3225-date-range-aggr aria-label="3.2.2.5 Date Range Aggr">3.2.2.5 Date Range Aggr</a></li><li><a href=#3226-range-aggr aria-label="3.2.2.6 Range Aggr">3.2.2.6 Range Aggr</a></li></ul></li></ul></li><li><a href=#34-%e5%a4%8d%e5%90%88%e6%9f%a5%e8%af%a2 aria-label="3.4 复合查询">3.4 复合查询</a><ul><li><a href=#341-bool-query aria-label="3.4.1 Bool query">3.4.1 Bool query</a></li><li><a href=#342--boosting-query aria-label="3.4.2  boosting query">3.4.2 boosting query</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h1><p>本文以命令行为主</p><blockquote><p>其本质还是发送http请求去操作数据</p></blockquote><h1 id=1-基本格式>1. 基本格式<a hidden class=anchor aria-hidden=true href=#1-基本格式>#</a></h1><p>es是以RESTFul风格来命名API的，其API的基本格式如下：</p><p><code>http://&lt;ip>:&lt;port>/&lt;索引>/&lt;类型>/&lt;文档id></code></p><p>这里需要注意的是，该格式从es7.0.0开始，移除Type（类型）这个概念，新的基本格式如下：</p><p><code>http://&lt;ip>:&lt;port>/&lt;索引>/_doc/&lt;文档id></code></p><p>Type（类型）字段那里变为固定值 _doc</p><p>es的动作是以http方法来决定的: 常用的http方法: <code>GET/PUT/POST/DELETE</code></p><blockquote><p>post 主做修改, put主做创建</p><p>post也有创建的功能,特别是插入数据生成随机id时</p></blockquote><h1 id=2-命令>2. 命令<a hidden class=anchor aria-hidden=true href=#2-命令>#</a></h1><h2 id=21-创建索引>2.1 创建索引<a hidden class=anchor aria-hidden=true href=#21-创建索引>#</a></h2><p><code>curl -XPUT http://localhost:9200/xkj_test</code> 没有指定mappings,故为非结构化索引,也没有字段</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 结构化索引: 指定了mappings
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#f85149>curl</span> <span style=color:#f85149>-X</span> <span style=color:#f85149>PUT</span> <span style=color:#f85149>&#39;localhost:</span><span style=color:#a5d6ff>9200</span><span style=color:#f85149>/accounts&#39;</span> <span style=color:#f85149>-d</span> <span style=color:#f85149>&#39;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&#34;mappings&#34;</span>: { <span style=color:#8b949e;font-style:italic>// mappings 映射
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>        <span style=color:#7ee787>&#34;man&#34;</span>: { <span style=color:#8b949e;font-style:italic>// type
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>            <span style=color:#7ee787>&#34;properties&#34;</span>: { <span style=color:#8b949e;font-style:italic>// 具体属性
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                <span style=color:#7ee787>&#34;name&#34;</span>: { <span style=color:#8b949e;font-style:italic>// 字段名
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                    <span style=color:#7ee787>&#34;type&#34;</span>:<span style=color:#a5d6ff>&#34;text&#34;</span> <span style=color:#8b949e;font-style:italic>// 字段类型
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                    <span style=color:#8b949e;font-style:italic>// ....还有其他可以选,比如拆分规则,权重值
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>                },
</span></span><span style=display:flex><span>                <span style=color:#7ee787>&#34;country&#34;</span>: {
</span></span><span style=display:flex><span>                    <span style=color:#7ee787>&#34;type&#34;</span>:<span style=color:#a5d6ff>&#34;keyword&#34;</span>
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                <span style=color:#7ee787>&#34;age&#34;</span>: {
</span></span><span style=display:flex><span>                    <span style=color:#7ee787>&#34;type&#34;</span>:<span style=color:#a5d6ff>&#34;integer&#34;</span>
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                <span style=color:#7ee787>&#34;date&#34;</span>: {
</span></span><span style=display:flex><span>                    <span style=color:#7ee787>&#34;type&#34;</span>: <span style=color:#a5d6ff>&#34;date&#34;</span>,
</span></span><span style=display:flex><span>                    <span style=color:#7ee787>&#34;format&#34;</span>: <span style=color:#a5d6ff>&#34;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&#34;</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>//         &#34;worman&#34;: {} // 6.x版本只支持一个type
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>   		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#f85149>}&#39;</span>
</span></span></code></pre></div><blockquote><p>其核心是里面的json字符串</p></blockquote><p><img loading=lazy src=https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721123224362-996727299.png alt=一张网图></p><h2 id=22-插入数据>2.2 插入数据<a hidden class=anchor aria-hidden=true href=#22-插入数据>#</a></h2><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#f85149>curl</span> <span style=color:#f85149>-X</span> <span style=color:#f85149>POST</span> <span style=color:#f85149>&#39;localhost:</span><span style=color:#a5d6ff>9200</span><span style=color:#f85149>/accounts/person/</span><span style=color:#a5d6ff>1000</span><span style=color:#f85149>&#39;</span> <span style=color:#f85149>-d</span> <span style=color:#f85149>&#39;</span> 
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 这个1000表示id,如果不写es会自动生成一个,如果连索引和类型也没有也会一并创建,如果id已存在则修改
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>{
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;user&#34;</span>: <span style=color:#a5d6ff>&#34;张三&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;title&#34;</span>: <span style=color:#a5d6ff>&#34;工程师&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;desc&#34;</span>: <span style=color:#a5d6ff>&#34;数据库管理&#34;</span>
</span></span><span style=display:flex><span>}<span style=color:#f85149>&#39;</span> 
</span></span></code></pre></div><blockquote><p>格式是 <code>ip:port/索引/类型/id</code>, 参数是各属性的json字符串</p></blockquote><h2 id=23-修改数据>2.3 修改数据<a hidden class=anchor aria-hidden=true href=#23-修改数据>#</a></h2><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#f85149>post</span> <span style=color:#f85149>http:</span><span style=color:#8b949e;font-style:italic>//localhost:9200/test/_doc/1/_update
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;script&#34;</span>: {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&#34;lang&#34;</span>: <span style=color:#a5d6ff>&#34;painless&#34;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&#34;inline&#34;</span>: <span style=color:#a5d6ff>&#34;ctx._source.age += 30&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>关键字”script”: 标志以脚本的方式修改文档</p><p>“lang”：表示以何种脚本语言进行修改，“painless”表示以es内置的脚本语言进行修改。此外es还支持多种脚本语言，如Python，js等等</p><p>“inline”：指定脚本内容 “ctx”代表es上下文，_source 代表文档</p></blockquote><p>根据条件修改信息:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#f85149>POST</span> <span style=color:#f85149>my_index/_update_by_query</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;script&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&#34;source&#34;</span>: <span style=color:#a5d6ff>&#34;ctx._source[&#39;ipsub&#39;]=0&#34;</span> 
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;query&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&#34;bool&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#7ee787>&#34;must_not&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#7ee787>&#34;exists&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:#7ee787>&#34;field&#34;</span>: <span style=color:#a5d6ff>&#34;ipsub&#34;</span>
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><blockquote><p>上面语句是根据是否存在"ipsub"字段，如果不存在，给信息增加字段"ipsub"，并且赋值0</p></blockquote><h2 id=24-查看>2.4 查看<a hidden class=anchor aria-hidden=true href=#24-查看>#</a></h2><ol><li>查看xkj_test索引数据格式</li></ol><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#f85149>curl</span> <span style=color:#f85149>-X</span> <span style=color:#f85149>GET</span> <span style=color:#f85149>http:</span><span style=color:#8b949e;font-style:italic>//localhost:9200/xkj_test/
</span></span></span></code></pre></div><ol start=2><li>查看xkj_test索引下指定id查看</li></ol><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#f85149>curl</span> <span style=color:#f85149>-X</span> <span style=color:#f85149>GET</span> <span style=color:#f85149>&#39;localhost:</span><span style=color:#a5d6ff>9200</span><span style=color:#f85149>/xkj_test/person/</span><span style=color:#a5d6ff>1000</span><span style=color:#f85149>?pretty=</span><span style=color:#79c0ff>true</span><span style=color:#f85149>&#39;</span>
</span></span></code></pre></div><ol start=3><li>根据条件查询</li></ol><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#f85149>curl</span> <span style=color:#f85149>-X</span> <span style=color:#f85149>POST</span> <span style=color:#f85149>&#39;localhost:</span><span style=color:#a5d6ff>9200</span><span style=color:#f85149>/accounts/person/_search&#39;</span>  <span style=color:#f85149>-d</span> <span style=color:#f85149>&#39;</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 要带上  _search 关键字
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>{
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;query&#34;</span> : { <span style=color:#7ee787>&#34;match&#34;</span> : [{ <span style=color:#7ee787>&#34;desc&#34;</span> : <span style=color:#a5d6ff>&#34;软件&#34;</span> },{ <span style=color:#7ee787>&#34;desc&#34;</span> : <span style=color:#a5d6ff>&#34;软件 工程&#34;</span> }]}
</span></span><span style=display:flex><span>}<span style=color:#f85149>&#39;</span>
</span></span></code></pre></div><blockquote><p>and 查询: match写多个条件</p><p>or 查询: 利用空格的分词,达到or的效果(我猜的)</p><p><code>_score</code> ：匹配度</p><p><code>_source</code>：文档的字段</p><p>来源: <a href=https://www.jianshu.com/p/083d99a1db6e target=_blank rel=noopener>https://www.jianshu.com/p/083d99a1db6e</a></p></blockquote><p><b style=color:red>es的查询五花八门,最好的技术书籍就是官网,以后好好看,如果要查数据,借助可视化界面就够用了</b></p><blockquote><p><a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html target=_blank rel=noopener>https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></p></blockquote><h2 id=25-删除>2.5 删除<a hidden class=anchor aria-hidden=true href=#25-删除>#</a></h2><p><strong>删除xkj_test索引</strong></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#f85149>delete</span> <span style=color:#f85149>http:</span><span style=color:#8b949e;font-style:italic>//localhost:9200/xkj_test/
</span></span></span></code></pre></div><p><strong>删除xkj_test索引下的数据(指定id)</strong></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#f85149>delete</span> <span style=color:#f85149>http:</span><span style=color:#8b949e;font-style:italic>//localhost:9200/xkj_test/_doc/1
</span></span></span></code></pre></div><p><strong>根据条件删除xkj_test索引下test1类型的数据</strong></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#f85149>post</span> <span style=color:#f85149>http:</span><span style=color:#8b949e;font-style:italic>//localhost:9200/xkj_test/test1/_delete_by_query
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>{
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;query&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&#34;range&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#7ee787>&#34;createDate&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&#34;lt&#34;</span>: <span style=color:#a5d6ff>&#34;now-31d&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>解释: 删除 createDate 字段下31天前的数据</p><p>利用_delete_by_query插件去批量删除</p><p><a href=https://blog.csdn.net/weixin_44034192/article/details/89372934 target=_blank rel=noopener>https://blog.csdn.net/weixin_44034192/article/details/89372934</a></p></blockquote><h2 id=26-简单排序>2.6 简单排序<a hidden class=anchor aria-hidden=true href=#26-简单排序>#</a></h2><p>按照指定字段排序,(默认按照分数排序)</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET books/_search
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;sort&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;price&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;order&#34;: &#34;desc&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>    },
</span></span></span><span style=display:flex><span><span style=color:#f85149>     &#34;age&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;order&#34;: &#34;desc&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  ]
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>// 按照价格降序排,再按年龄排
</span></span></span></code></pre></div><blockquote><p>在 Elasticsearch 中，默认排序是<strong>按照相关性的评分（_score）<strong>进行降序排序，也可以按照</strong>字段的值排序</strong>、<strong>多级排序</strong>、<strong>多值字段排序、基于 geo（地理位置）排序以及自定义脚本排序</strong>，除此之外，对于相关性的评分也可以用 rescore 二次、三次打分，它可以限定重新打分的窗口大小（window size），并针对作用范围内的文档修改其得分，从而达到精细化控制结果相关性的目的。</p></blockquote><h1 id=3-复杂查询>3. 复杂查询<a hidden class=anchor aria-hidden=true href=#3-复杂查询>#</a></h1><h2 id=31-query-and-filter-context>3.1 Query and filter context<a hidden class=anchor aria-hidden=true href=#31-query-and-filter-context>#</a></h2><p>查询子句的行为取决于它是用在查询上下文（query context）还是用在过滤器上下文（filter context）：</p><h3 id=311-query-context>3.1.1 Query context<a hidden class=anchor aria-hidden=true href=#311-query-context>#</a></h3><p>在查询上下文中的查询子句回答了“这个文档与这个查询子句的匹配程度是怎样的？”问题。除了决定文档是否匹配以外，查询子句<strong>还会计算一个“_score”</strong>，它表示文档与其他文档的相关程度(分数)。</p><h3 id=312-filter-context>3.1.2 Filter context<a hidden class=anchor aria-hidden=true href=#312-filter-context>#</a></h3><p>在过滤器上下文中，一个查询子句回答了“这个文档与查询子句匹配吗？”的问题。这个答案是简单的Yes或者No，<strong>也不会计算分数</strong>。过滤上下文主要用于过滤结构化数据</p><blockquote><p>PS：Query VS Filter</p><ol><li>查询反应的是文档与查询子句的匹配程度，而过滤反应的是文档是否匹配查询子句</li><li>一个是筛选是否满足条件，情况无非两种：是或不是；一个是看满足条件的记录与查询条件的匹配程度</li><li>哪些满足条件，这是过滤；满足条件的这些记录与条件的匹配程度，这是查询</li><li>过滤不会计算评分，查询会计算评分</li></ol></blockquote><h2 id=32-全文查询-full-text>3.2 全文查询( Full text)<a hidden class=anchor aria-hidden=true href=#32-全文查询-full-text>#</a></h2><h3 id=311--match--query>3.1.1 match query<a hidden class=anchor aria-hidden=true href=#311--match--query>#</a></h3><p>match查询接受文本/数值/日期类型的数据，分析它们，并构造一个查询。</p><blockquote><p><strong>相当于模糊查询</strong></p></blockquote><p>match是一种布尔类型的查询。这意味着它对提供的文本进行分析，并在分析的过程中为提供的文本构造一个布尔查询。operator 选项可以设置为 or 或者 and 以此来控制布尔子句（默认是 or ）。例如</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;match&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;skuName&#34; : &#34;空调&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}&#39;
</span></span></span></code></pre></div><h3 id=312-match-phrase-query>3.1.2 Match Phrase Query<a hidden class=anchor aria-hidden=true href=#312-match-phrase-query>#</a></h3><p>match_phrase 查询与 match类似，但是它是用于<strong>精确匹配或单词接近匹配</strong>的。例如：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;match_phrase&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;skuName&#34; : &#34;this is a test&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}&#39;
</span></span></span></code></pre></div><h3 id=313-multi-match-query>3.1.3 Multi Match Query<a hidden class=anchor aria-hidden=true href=#313-multi-match-query>#</a></h3><p>multi_match 相当于 match 的多字段版本, multi_match可以指定多个字段，而match只能针对一个字段</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;multi_match&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;query&#34;:    &#34;this is a test&#34;, 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;fields&#34;: [ &#34;subject&#34;, &#34;skuName&#34; ] 
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>fields 里的字段用 * 支持模糊匹配,  写成这种 [ &#34;subject^3&#34;, &#34;skuName&#34; ] 表示subject比skuName重要3倍
</span></span></span></code></pre></div><h3 id=314-query-string-query>3.1.4 Query String Query<a hidden class=anchor aria-hidden=true href=#314-query-string-query>#</a></h3><p>支持Lucene查询字符串语法，允许指定 AND | OR | NOT ，并且在单个查询字符串中进行多字段查询, 分词后对每个词都查询</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;query_string&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;default_field&#34; : &#34;skuName&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;query&#34; : &#34;this  that  thus&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>// 在skuName中查询 this , that , thus 三个词 , 其实质解析成: &#34; this OR that OR thus&#34;, 你可以替换OR为AND/NOT
</span></span></span><span style=display:flex><span><span style=color:#f85149>// 还可以指定快 例如:  &#34;query&#34; : &#34;(new york city) OR (big apple)&#34;  这样将被拆分成 “new york city” 和 “big apple” 两部分，并且每一部分都被分析器独立分析
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;query_string&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;fields&#34; : [&#34;content&#34;, &#34;name&#34;],
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;query&#34; : &#34;this AND that&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>// 等价于
</span></span></span><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;query_string&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;query&#34;: &#34;(content:this OR name:this) AND (content:that OR name:that)&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>&#39;
</span></span></span></code></pre></div><blockquote><p>注意，<strong>按操作符拆分</strong></p><p>query_string的参数包括：</p><p>query　　实例被解析的查询文本</p><p>default_field　　如果没有指定前缀字段的话，这是默认的查询字段。（默认查询所有字段）</p><p>default_operator　　如果没有明确指定操作符的话，那么这是默认的操作符。例如，如果默认操作符是OR的话，那么“my name is jack”将被翻译成“my OR name OR is OR jack”，同理，如果是AND，则被翻译成“my AND name AND is AND jack”</p><p>analyzer　　用来解析查询字符串的解析器的名字</p><p>allow_leading_wildcard　　如果设置了，那么 * 或 ? 允许作为第一个字符。默认是true</p><p>lenient　　如果设置为true，则格式失败将被忽略</p></blockquote><h2 id=32-单词级查询term-text>3.2 单词级查询(term text)<a hidden class=anchor aria-hidden=true href=#32-单词级查询term-text>#</a></h2><p>全文本查询会在执行之前对查询字符串进行分析，而单词级别查询会对存储在反向索引中的精确的term进行操作。</p><p>这些查询通常用于结构化的数据，比如：numbers ， dates ，enums 等，而不是对全文本字段。</p><p>（PS：也就是说，全文本查询之前要先对文本内容进行分词，而单词级别的查询直接在相应字段的反向索引中精确查找，单词级别的查询一般用于数值、日期等类型的字段上）</p><h3 id=321--term-query>3.2.1 Term Query<a hidden class=anchor aria-hidden=true href=#321--term-query>#</a></h3><p>在指定的字段中查找包含指定的精确的term的文档</p><p>term查询将在反向索引（或者叫倒排索引）中查找包含特定的精确的term的文档。例如：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X POST &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;term&#34; : { &#34;user&#34; : &#34;Kimchy&#34; } 
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>// 查询倒排索引(切词后)中user包含&#34;kimchy&#34;字符串的值,
</span></span></span></code></pre></div><h3 id=322--terms-query>3.2.2 Terms Query<a hidden class=anchor aria-hidden=true href=#322--terms-query>#</a></h3><p>查找包含指定字段中指定的任何确切term的文档</p><p>筛选出与所提供的terms中任何一个匹配的文档</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;terms&#34; : { &#34;user&#34; : [&#34;kimchy&#34;, &#34;elasticsearch&#34;]}
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>// 查询 切词后包含&#34;kimchy&#34;或者 &#34;elasticsearch&#34;文档
</span></span></span></code></pre></div><h3 id=323-range-query>3.2.3 Range Query<a hidden class=anchor aria-hidden=true href=#323-range-query>#</a></h3><p>查找指定字段在指定范围内包含值（日期、数字或字符串）的文档。</p><p>下面的例子返回age字段的值在10到20之间的文档：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;range&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;age&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>                &#34;gte&#34; : 10,
</span></span></span><span style=display:flex><span><span style=color:#f85149>                &#34;lte&#34; : 20,
</span></span></span><span style=display:flex><span><span style=color:#f85149>                &#34;boost&#34; : 2.0
</span></span></span><span style=display:flex><span><span style=color:#f85149>            }
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>&#39;
</span></span></span></code></pre></div><blockquote><p>range查询可以接受下列参数：</p><p>gte　　大于或等于</p><p>gt　　 大于</p><p>lte　　 小于或等于</p><p>lt　　 小于</p><p>boost　　设置boost值，默认是1.0</p></blockquote><p>在日期范围查询的时候，我们可以指定日期格式。例如：(时间格式es会自动转化,用字符串去查时间格式也能行)</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;range&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;born&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>                &#34;gte&#34;: &#34;01/01/2012&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>                &#34;lte&#34;: &#34;2013&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>                &#34;format&#34;: &#34;dd/MM/yyyy||yyyy&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>            }
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>// 这个例子是查询在2012-01-01到2013-12-31之间出生的人
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;range&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;timestamp&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>                &#34;gte&#34;: &#34;2015-01-01 00:00:00&#34;, 
</span></span></span><span style=display:flex><span><span style=color:#f85149>                &#34;lte&#34;: &#34;now&#34;, 
</span></span></span><span style=display:flex><span><span style=color:#f85149>                &#34;time_zone&#34;: &#34;+01:00&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>            }
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>&#39;
</span></span></span></code></pre></div><h3 id=324-exsit-query>3.2.4 Exsit Query<a hidden class=anchor aria-hidden=true href=#324-exsit-query>#</a></h3><p>在特定的字段中查找非空值的文档</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;exists&#34; : { &#34;field&#34; : &#34;user&#34; }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>&#39;
</span></span></span></code></pre></div><h3 id=325-prefix-query>3.2.5 Prefix Query<a hidden class=anchor aria-hidden=true href=#325-prefix-query>#</a></h3><p>查找包含带有指定前缀的term的文档</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{ 
</span></span></span><span style=display:flex><span><span style=color:#f85149>	&#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    	&#34;prefix&#34; : { &#34;user&#34; : &#34;ki&#34; }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>&#39;
</span></span></span></code></pre></div><h3 id=326-wildcard-query>3.2.6 Wildcard Query<a hidden class=anchor aria-hidden=true href=#326-wildcard-query>#</a></h3><p>支持通配符查询，*表示任意字符，?表示任意单个字符</p><blockquote><p>这个查询效率比较慢</p></blockquote><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;wildcard&#34; : { &#34;user&#34; : &#34;ki*y&#34; }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>&#39;
</span></span></span></code></pre></div><h3 id=327-regexp-query>3.2.7 Regexp Query<a hidden class=anchor aria-hidden=true href=#327-regexp-query>#</a></h3><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>curl -X GET &#34;localhost:9200/_search&#34; -H &#39;Content-Type: application/json&#39; -d&#39;
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;regexp&#34;:{
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;name.first&#34;: &#34;s.*y&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>&#39;
</span></span></span></code></pre></div><blockquote><p>prefix 和 wildcard 和 regexp 三者工作方式是一样的 ,需要扫描倒排索引中的词列表才能找到所有匹配的词，然后依次获取每个词相关的文档 ID</p><p>性能对比: prefix > wildcard > regexp</p><p><strong>wildcard 和 regexp要避免左模糊查询</strong></p><p><a href=https://www.elastic.co/guide/cn/elasticsearch/guide/current/_wildcard_and_regexp_queries.html target=_blank rel=noopener>官网</a></p></blockquote><h2 id=33-聚合查询>3.3 聚合查询<a hidden class=anchor aria-hidden=true href=#33-聚合查询>#</a></h2><p>Elasticsearch 的聚合（Aggregations）功能十分强大，允许在数据上做复杂的分析统计。Elasticsearch 提供的聚合分析功能主要有<strong>指标聚合（metrics aggregations）</strong>、<strong>桶聚合（bucket aggregations）</strong>、<strong>管道聚合（pipeline aggregations）</strong> 三大类，</p><p>所有的聚合，无论它们是什么类型，都遵从以下的规则。</p><ul><li>使用查询中同样的 JSON 请求来定义它们，而且你是使用键 aggregations 或者是 aggs 来进行标记。需要给每个聚合起一个名字，指定它的类型以及和该类型相关的选项。</li><li>它们运行在查询的结果之上。和查询不匹配的文档不会计算在内，除非你使用 global 聚集将不匹配的文档囊括其中。</li><li>可以进一步过滤查询的结果，而不影响聚集。</li></ul><p>以下是聚合的基本结构：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#a5d6ff>&#34;aggregations&#34;</span> <span style=color:#f85149>:</span> { <span style=color:#f85149>&lt;!--</span> <span style=color:#f85149>最外层的聚合键，也可以缩写为</span> <span style=color:#f85149>aggs</span> <span style=color:#f85149>--&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&#34;&lt;aggregation_name&gt;&#34;</span> : { <span style=color:#f85149>&lt;!--</span> <span style=color:#f85149>聚合的自定义名字</span> <span style=color:#f85149>--&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&#34;&lt;aggregation_type&gt;&#34;</span> : { <span style=color:#f85149>&lt;!--</span> <span style=color:#f85149>聚合的类型，指标相关的，如</span> <span style=color:#f85149>max、min、avg、sum，桶相关的</span> <span style=color:#f85149>terms、filter</span> <span style=color:#f85149>等</span> <span style=color:#f85149>--&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f85149>&lt;aggregation_body&gt;</span> <span style=color:#f85149>&lt;!--</span> <span style=color:#f85149>聚合体：对哪些字段进行聚合，可以取字段的值，也可以是脚本计算的结果</span> <span style=color:#f85149>--&gt;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        [,<span style=color:#a5d6ff>&#34;meta&#34;</span> <span style=color:#f85149>:</span> {  <span style=color:#f85149>[&lt;meta_data_body&gt;]</span> } ]<span style=color:#f85149>?</span> <span style=color:#f85149>&lt;!--</span> <span style=color:#f85149>元</span> <span style=color:#f85149>--&gt;</span>
</span></span><span style=display:flex><span>        [,<span style=color:#a5d6ff>&#34;aggregations&#34;</span> <span style=color:#f85149>:</span> { <span style=color:#f85149>[&lt;sub_aggregation&gt;]+</span> } ]<span style=color:#f85149>?</span> <span style=color:#f85149>&lt;!--</span> <span style=color:#f85149>在聚合里面在定义子聚合</span> <span style=color:#f85149>--&gt;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    [,<span style=color:#a5d6ff>&#34;&lt;aggregation_name_2&gt;&#34;</span> <span style=color:#f85149>:</span> { <span style=color:#f85149>...</span> } ]<span style=color:#f85149>*</span> <span style=color:#f85149>&lt;!--</span> <span style=color:#f85149>聚合的自定义名字</span> <span style=color:#a5d6ff>2</span> <span style=color:#f85149>--&gt;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><strong>在最上层有一个 aggregations 的键，可以缩写为 aggs</strong>。</li><li>在下面一层，需要为聚合指定一个名字。可以在请求的返回中看到这个名字。在同一个请求中使用多个聚合时，这一点非常有用，它让你可以很容易地理解每组结果的含义。</li><li>最后，必须要指定聚合的类型。</li></ul><blockquote><p>关于聚合分析的值来源，可以<strong>取字段的值</strong>，也可以是<strong>脚本计算的结果</strong>。</p><p>但是用脚本计算的结果时，需要注意脚本的性能和安全性；尽管多数聚集类型允许使用脚本，但是脚本使得聚集变得缓慢，因为脚本必须在每篇文档上运行。为了避免脚本的运行，可以在索引阶段进行计算。</p><p>此外，脚本也可以被人可能利用进行恶意代码攻击，尽量使用沙盒（sandbox）内的脚本语言。</p><p><strong>text类型默认不支持聚合</strong></p></blockquote><p>查询所有球员的平均年龄是多少，并对球员的平均薪水加 188（也可以理解为每名球员加 188 后的平均薪水）。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>POST /player/_search?size=0
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;avg_age&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;avg&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;field&#34;: &#34;age&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>      }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    },
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;avg_salary_188&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;avg&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;script&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;source&#34;: &#34;doc.salary.value + 188&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>      }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>// 默认情况下，包含聚合的搜索会返回搜索命中和聚合结果, size 表示返回命中的文档数量,设为0表示只返回聚合结果
</span></span></span></code></pre></div><h3 id=331--metrics-aggregations>3.3.1 Metrics aggregations<a hidden class=anchor aria-hidden=true href=#331--metrics-aggregations>#</a></h3><p>指标聚合（又称度量聚合）主要从不同文档的分组中提取统计数据，或者，从来自其他聚合的文档桶来提取统计数据。</p><p>这些统计数据通常来自数值型字段，如最小或者平均价格。用户可以单独获取每项统计数据，或者也可以使用 stats 聚合来同时获取它们。更高级的统计数据，如平方和或者是标准差，可以通过 extended stats 聚合来获取。</p><h4 id=3311-min-aggregation>3.3.1.1 Min Aggregation<a hidden class=anchor aria-hidden=true href=#3311-min-aggregation>#</a></h4><p>Min Aggregation 用于最小值统计。例如，统计 sales 索引中价格最低的是哪本书，查询语句如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET /sales/_search?size=0
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;min_price&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;min&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;field&#34; : &#34;price&#34; 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      } 
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><p>聚合结果如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  ...
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggregations&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;min_price&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;value&#34;: 18.0
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><h4 id=3312-max-aggregation>3.3.1.2 Max Aggregation<a hidden class=anchor aria-hidden=true href=#3312-max-aggregation>#</a></h4><p>Max Aggregation 用于最大值统计。例如，统计 sales 索引中type是hat的且价格最高的是哪本书，并且计算出对应的价格的 2 倍值，查询语句如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET /sales/_search?size=0
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;query&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;constant_score&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;filter&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;match&#34; : { &#34;type&#34; : &#34;hat&#34; }
</span></span></span><span style=display:flex><span><span style=color:#f85149>          }
</span></span></span><span style=display:flex><span><span style=color:#f85149>       }
</span></span></span><span style=display:flex><span><span style=color:#f85149>   },
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;max_price&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;max&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;field&#34; : &#34;price&#34; ,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;missing&#34;: 60
</span></span></span><span style=display:flex><span><span style=color:#f85149>      } 
</span></span></span><span style=display:flex><span><span style=color:#f85149>    },
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;max_price_2&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;max&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;field&#34; : &#34;price&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;script&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;source&#34;: &#34;_value * 2.0&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>        } 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      } 
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><p><strong>指定的 field，在脚本中可以用 _value 取字段的值</strong>。</p><p><strong>如果指定字段没有值，可以通过 missing 指定默认值；若未指定默认值，缺失该字段值的文档将被忽略（计算）</strong>。</p><p>聚合结果如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  ...
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggregations&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;max_price&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;value&#34;: 188.0
</span></span></span><span style=display:flex><span><span style=color:#f85149>    },
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;max_price_2&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;value&#34;: 376.0
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><h4 id=3313-avg-aggregation>3.3.1.3 Avg Aggregation<a hidden class=anchor aria-hidden=true href=#3313-avg-aggregation>#</a></h4><p>Avg Aggregation 用于计算平均值。例如，统计 exams 索引中考试的平均分数，</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET /exams/_search?size=0
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;avg_grade&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;avg&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;field&#34; : &#34;grade&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>      } 
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  ...
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggregations&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;avg_grade&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;value&#34;: 78.0
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><p>除了常规的平均值聚合计算外，elasticsearch 还提供了加权平均值的聚合计算， 详情参见 <a href=https://blog.csdn.net/wjzt7322/article/details/103566139 target=_blank rel=noopener>Elasticsearch 指标聚合之 Weighted Avg Aggregation</a>
。</p><blockquote><p>用加权平均值代替原本值</p></blockquote><h4 id=3314--sum-aggregation>3.3.1.4 Sum Aggregation<a hidden class=anchor aria-hidden=true href=#3314--sum-aggregation>#</a></h4><p>Sum Aggregation 用于计算总和。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET /exams/_search?size=0
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;hat_prices&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;sum&#34; : { &#34;field&#34; : &#34;price&#34; } 
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  ...
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggregations&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;hat_prices&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;value&#34;: 567.0
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><h4 id=3315--count-aggregation>3.3.1.5 Count Aggregation<a hidden class=anchor aria-hidden=true href=#3315--count-aggregation>#</a></h4><p>Count Aggregation 可按字段统计文档数量。例如，统计 books 索引中包含 author 字段的文档数量，查询语句如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET /books/_search?size=0
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;doc_count&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;value_count&#34; : { &#34;field&#34; : &#34;author&#34; } 
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  ...
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggregations&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;doc_count&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;value&#34;: 5
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><h4 id=3316-cardinality-aggregation>3.3.1.6 Cardinality Aggregation<a hidden class=anchor aria-hidden=true href=#3316-cardinality-aggregation>#</a></h4><p>Cardinality Aggregation 用于基数统计，其作用是先执行类似 SQL 中的 distinct 操作，去掉集合中的重复项，然后统计排重后的集合长度。</p><p>例如，在 books 索引中对 language 字段进行 cardinality 操作可以统计出编程语言的种类数，查询语句如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET /books/_search?size=0
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;all_lan&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;cardinality&#34; : { &#34;field&#34; : &#34;language&#34; } 
</span></span></span><span style=display:flex><span><span style=color:#f85149>    },
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;title_cnt&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;cardinality&#34; : { &#34;field&#34; : &#34;title.keyword&#34; } 
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><p><strong>假设 title 字段为文本类型（text），去重时需要指定 keyword，表示把 title 作为整体去重，即不分词统计</strong>。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  ...
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggregations&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;all_lan&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;value&#34;: 8
</span></span></span><span style=display:flex><span><span style=color:#f85149>    },
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;title_cnt&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;value&#34;: 18
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><h4 id=3317-stats-aggregation>3.3.1.7 Stats Aggregation<a hidden class=anchor aria-hidden=true href=#3317-stats-aggregation>#</a></h4><p>Stats Aggregation 用于基本统计，会一次返回 count、max、min、avg 和 sum 这 5 个指标。例如，在 exams 索引中对 grade 字段进行分数相关的基本统计，查询语句如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET /exams/_search?size=0
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;grades_stats&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;stats&#34; : { &#34;field&#34; : &#34;grade&#34; } 
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><h4 id=3318--extended-stats-aggregation>3.3.1.8 Extended Stats Aggregation<a hidden class=anchor aria-hidden=true href=#3318--extended-stats-aggregation>#</a></h4><p>Extended Stats Aggregation 用于高级统计，和基本统计功能类似，但是会比基本统计多出以下几个统计结果，sum_of_squares（平方和）、variance（方差）、std_deviation（标准差）、std_deviation_bounds（平均值加/减两个标准差的区间）。在 exams 索引中对 grade 字段进行分数相关的高级统计，查询语句如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET /exams/_search?size=0
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;grades_stats&#34; : { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;extended_stats&#34; : { &#34;field&#34; : &#34;grade&#34; } 
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><h4 id=3319-percentiles-aggregation>3.3.1.9 Percentiles Aggregation<a hidden class=anchor aria-hidden=true href=#3319-percentiles-aggregation>#</a></h4><p>Percentiles Aggregation 用于百分位统计。百分位数是一个统计学术语，如果将一组数据从大到小排序，并计算相应的累计百分位，某一百分位所对应数据的值就称为这一百分位的百分位数。默认情况下，累计百分位为 [ 1, 5, 25, 50, 75, 95, 99 ],也可以用<code>percents</code>指定范围。以下例子给出了在 latency 索引中对 load_time 字段进行加载时间的百分位统计，查询语句如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET latency/_search
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;size&#34;: 0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;load_time_outlier&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;percentiles&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;field&#34; : &#34;load_time&#34; ,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;percents&#34;:[30,45] //查询第30%和45%的数据
</span></span></span><span style=display:flex><span><span style=color:#f85149>      }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><p><strong>需要注意的是，如上的 <code>load_time</code> 字段必须是数字类型</strong>。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  ...
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggregations&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;load_time_outlier&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;values&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;1.0&#34;: 5.0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;5.0&#34;: 25.0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;25.0&#34;: 165.0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;50.0&#34;: 445.0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;75.0&#34;: 725.0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;95.0&#34;: 945.0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;99.0&#34;: 985.0
</span></span></span><span style=display:flex><span><span style=color:#f85149>      }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><blockquote><p>第1%位的数据是5</p><p>第5%位的数据是25</p><p>&mldr;&mldr;</p><p>第99%位的数据是99</p></blockquote><h4 id=33110-percentiles-ranks-aggregation>3.3.1.10 Percentiles Ranks Aggregation<a hidden class=anchor aria-hidden=true href=#33110-percentiles-ranks-aggregation>#</a></h4><p>Percentiles Ranks Aggregation 与 Percentiles Aggregation 统计恰恰相反，就是想看当前数值处在什么范围内（百分位）， 假如你查一下当前值 500 和 600 所处的百分位，发现是 90.01 和 100，那么说明有 90.01 % 的数值都在 500 以内，100 % 的数值在 600 以内。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET latency/_search
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;size&#34;: 0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;aggs&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;load_time_ranks&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;percentile_ranks&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;field&#34; : &#34;load_time&#34;, 
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;values&#34; : [500, 600]
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>      }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><p><strong><code>同样 load_time</code> 字段必须是数字类型</strong>。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  ...
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggregations&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;load_time_ranks&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;values&#34; : {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;500.0&#34;: 90.01,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;600.0&#34;: 100.0
</span></span></span><span style=display:flex><span><span style=color:#f85149>      }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><p>可以设置 <code>keyed</code> 参数为 <code>true</code>，将对应的 values 作为桶 key 一起返回，默认是 <code>false</code>。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET latency/_search
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;size&#34;: 0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;load_time_ranks&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;percentile_ranks&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;field&#34;: &#34;load_time&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;values&#34;: [500, 600],
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;keyed&#34;: true
</span></span></span><span style=display:flex><span><span style=color:#f85149>      }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  ...
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggregations&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;load_time_ranks&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;values&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#f85149>        {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;key&#34;: 500.0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;value&#34;: 90.01
</span></span></span><span style=display:flex><span><span style=color:#f85149>        },
</span></span></span><span style=display:flex><span><span style=color:#f85149>        {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;key&#34;: 600.0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;value&#34;: 100.0
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>      ]
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><h3 id=332--bucket-aggregations>3.3.2 bucket aggregations<a hidden class=anchor aria-hidden=true href=#332--bucket-aggregations>#</a></h3><p>bucket 可以理解为一个桶，它会遍历文档中的内容，凡是符合某一要求的就放入一个桶中，分桶相当于 SQL 中的 group by。从另外一个角度，可以将指标聚合看成单桶聚合，即把所有文档放到一个桶中，而桶聚合是多桶型聚合，它根据相应的条件进行分组。</p><blockquote><p>桶数最多 65536 个,可修改</p></blockquote><h4 id=3321-terms-aggregation>3.3.2.1 Terms Aggregation<a hidden class=anchor aria-hidden=true href=#3321-terms-aggregation>#</a></h4><p>Terms Aggregation 用于词项的分组聚合。最为经典的用例是获取 X 中最频繁（top frequent）的项目，其中 X 是文档中的某个字段，如用户的名称、标签或分类。由于 terms 聚集统计的是每个词条，而不是整个字段值，因此通常需要在一个非分析型的字段上运行这种聚集。原因是, 你期望“big data”作为词组统计，而不是“big”单独统计一次，“data”再单独统计一次。</p><blockquote><p>支持字段类型 Keyword, Numeric, ip, boolean, binary.</p></blockquote><p>用户可以使用 terms 聚集，从分析型字段（如内容）中抽取最为频繁的词条。还可以使用这种信息来生成一个单词云。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;profit_terms&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;terms&#34;: { 
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;field&#34;: &#34;skuName&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>      }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><p>结果:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  ...
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggregations&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;genres&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;doc_count_error_upper_bound&#34;: 0,   // 错误文档的个数
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;sum_other_doc_count&#34;: 0,    // 未统计的文档个数
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;buckets&#34;: [                        
</span></span></span><span style=display:flex><span><span style=color:#f85149>        {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;key&#34;: &#34;electronic&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;doc_count&#34;: 6
</span></span></span><span style=display:flex><span><span style=color:#f85149>        },
</span></span></span><span style=display:flex><span><span style=color:#f85149>        {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;key&#34;: &#34;rock&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;doc_count&#34;: 3
</span></span></span><span style=display:flex><span><span style=color:#f85149>        },
</span></span></span><span style=display:flex><span><span style=color:#f85149>        {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;key&#34;: &#34;jazz&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;doc_count&#34;: 2
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>      ]
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><blockquote><p>返回值中,默认按doc_count数量降序排序, 可以用order字段指定排序规则</p><p>可以用size字段控制返回的桶数</p></blockquote><h4 id=3222--filter-aggregation>3.2.2.2 Filter Aggregation<a hidden class=anchor aria-hidden=true href=#3222--filter-aggregation>#</a></h4><p>Filter Aggregation 是过滤器聚合，可以把符合过滤器中的条件的文档分到一个桶中，即是单分组聚合。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;age_terms&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;filter&#34;: {&#34;term&#34;:{&#34;gender&#34;:&#34;F&#34;}},
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;aggs&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;avg_age&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;avg&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;field&#34;: &#34;age&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>          }
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>      }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><blockquote><p>在聚合操作中加入过滤,比 过滤后再聚合要差, 上面的效率比下面的效率要差</p></blockquote><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>POST /sales/_search?size=0&amp;filter_path=aggregations
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;query&#34;: { &#34;term&#34;: { &#34;type&#34;: &#34;t-shirt&#34; } },
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;avg_price&#34;: { &#34;avg&#34;: { &#34;field&#34;: &#34;price&#34; } }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><h4 id=3223-filters-aggregation>3.2.2.3 Filters Aggregation<a hidden class=anchor aria-hidden=true href=#3223-filters-aggregation>#</a></h4><p>Filters Aggregation 是多过滤器聚合，可以把符合多个过滤条件的文档分到不同的桶中，即每个分组关联一个过滤条件，并收集所有满足自身过滤条件的文档。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;size&#34;: 0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;messages&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;filters&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;filters&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;errors&#34;: { &#34;match&#34;: { &#34;body&#34;: &#34;error&#34; } },
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;warnings&#34;: { &#34;match&#34;: { &#34;body&#34;: &#34;warning&#34; } }
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>      }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><p>在这个例子里，我们分析日志信息。聚合会创建两个关于日志数据的分组，一个收集包含错误信息的文档，另一个收集包含告警信息的文档。而且每个分组会按月份划分。</p><blockquote><p>filters 写多个过滤器比 写过filter效率好</p></blockquote><h4 id=3224-range-aggregation>3.2.2.4 Range Aggregation<a hidden class=anchor aria-hidden=true href=#3224-range-aggregation>#</a></h4><p>Range Aggregation 范围聚合是一个基于多组值来源的聚合，可以让用户定义一系列范围，每个范围代表一个分组。在聚合执行的过程中，从每个文档提取出来的值都会检查每个分组的范围，并且使相关的文档落入分组中。注意，范围聚合的每个范围内包含 from 值但是排除 to 值。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;age_range&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;range&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;field&#34;: &#34;age&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;ranges&#34;: [{
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;to&#34;: 25
</span></span></span><span style=display:flex><span><span style=color:#f85149>          },
</span></span></span><span style=display:flex><span><span style=color:#f85149>          {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;from&#34;: 25,
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;to&#34;: 35
</span></span></span><span style=display:flex><span><span style=color:#f85149>          },
</span></span></span><span style=display:flex><span><span style=color:#f85149>          {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;from&#34;: 35
</span></span></span><span style=display:flex><span><span style=color:#f85149>          }]
</span></span></span><span style=display:flex><span><span style=color:#f85149>        },
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;aggs&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;bmax&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;max&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>              &#34;field&#34;: &#34;balance&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>            }
</span></span></span><span style=display:flex><span><span style=color:#f85149>          }
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>      }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><h4 id=3225-date-range-aggr>3.2.2.5 Date Range Aggr<a hidden class=anchor aria-hidden=true href=#3225-date-range-aggr>#</a></h4><p>日期范围聚合是专用于日期值的范围聚合。该聚合和正常的 范围 聚合的区别主要在于：该聚合可以用 日期数学 表达式表示 from 值 和 to 值，还可以指定 返回 from 和 to 响应字段的日期格式。注意，该聚合包含 from 值，但不包含 to 值。(左闭右开的区间)</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>POST /sales/_search?size=0
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;range&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;date_range&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;field&#34;: &#34;date&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;format&#34;: &#34;MM-yyyy&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;ranges&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#f85149>          { &#34;to&#34;: &#34;now-10M/M&#34; },  
</span></span></span><span style=display:flex><span><span style=color:#f85149>          { &#34;from&#34;: &#34;now-10M/M&#34; } 
</span></span></span><span style=display:flex><span><span style=color:#f85149>        ]
</span></span></span><span style=display:flex><span><span style=color:#f85149>      }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><blockquote><p>to: &lt; 现在减去 10 个月，向下舍入到月初</p><p>from: >= 现在减去 10 个月，向下舍入到月初</p><p>在上面的例子中，我们创建了两个范围桶，第一个桶会将早于 10 个月之前的所有文档存储，第二个桶会将从 10 月之前开始的文档存储。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>    ...
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;aggregations&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;range&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;buckets&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#f85149>                {
</span></span></span><span style=display:flex><span><span style=color:#f85149>                    &#34;to&#34;: 1.4436576E12,
</span></span></span><span style=display:flex><span><span style=color:#f85149>                    &#34;to_as_string&#34;: &#34;10-2015&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>                    &#34;doc_count&#34;: 7,
</span></span></span><span style=display:flex><span><span style=color:#f85149>                    &#34;key&#34;: &#34;*-10-2015&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>                },
</span></span></span><span style=display:flex><span><span style=color:#f85149>                {
</span></span></span><span style=display:flex><span><span style=color:#f85149>                    &#34;from&#34;: 1.4436576E12,
</span></span></span><span style=display:flex><span><span style=color:#f85149>                    &#34;from_as_string&#34;: &#34;10-2015&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>                    &#34;doc_count&#34;: 0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>                    &#34;key&#34;: &#34;10-2015-*&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>                }
</span></span></span><span style=display:flex><span><span style=color:#f85149>            ]
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><blockquote><p>时间格式和java的一样</p><p><a href=https://learnku.com/docs/elasticsearch73/7.3/526-date-range-aggregation/7774 target=_blank rel=noopener>es-中文文档</a></p></blockquote><h4 id=3226-range-aggr>3.2.2.6 Range Aggr<a hidden class=anchor aria-hidden=true href=#3226-range-aggr>#</a></h4><p>基于多桶值源的聚合，使用户能够定义一组范围 - 每个范围代表一个桶。 在聚合过程中，将从每个文档中提取的值根据每个存储区范围进行检查，并将相关/匹配文档“存储”到“存储区”中。 请注意，该聚合包含 from 值，但不包含 to 值</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET /_search
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggs&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;price_ranges&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;range&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;field&#34;: &#34;price&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>        &#34;ranges&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#f85149>          { &#34;to&#34;: 100.0 },
</span></span></span><span style=display:flex><span><span style=color:#f85149>          { &#34;from&#34;: 100.0, &#34;to&#34;: 200.0 },
</span></span></span><span style=display:flex><span><span style=color:#f85149>          { &#34;from&#34;: 200.0 }
</span></span></span><span style=display:flex><span><span style=color:#f85149>        ]
</span></span></span><span style=display:flex><span><span style=color:#f85149>      }
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><p>结果:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  ...
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;aggregations&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;price_ranges&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;buckets&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#f85149>        {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;key&#34;: &#34;*-100.0&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;to&#34;: 100.0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;doc_count&#34;: 2
</span></span></span><span style=display:flex><span><span style=color:#f85149>        },
</span></span></span><span style=display:flex><span><span style=color:#f85149>        {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;key&#34;: &#34;100.0-200.0&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;from&#34;: 100.0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;to&#34;: 200.0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;doc_count&#34;: 2
</span></span></span><span style=display:flex><span><span style=color:#f85149>        },
</span></span></span><span style=display:flex><span><span style=color:#f85149>        {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;key&#34;: &#34;200.0-*&#34;,
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;from&#34;: 200.0,
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;doc_count&#34;: 3
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>      ]
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><h2 id=34-复合查询>3.4 复合查询<a hidden class=anchor aria-hidden=true href=#34-复合查询>#</a></h2><p>复合查询包装其他复合查询或叶查询，以组合它们的结果和分数，改变它们的行为，或者从查询切换到过滤上下文。</p><blockquote><p>简单的说是 将多种查询条件组合到一起</p></blockquote><h3 id=341-bool-query>3.4.1 Bool query<a hidden class=anchor aria-hidden=true href=#341-bool-query>#</a></h3><ul><li><p>filter</p><p>子句在过滤器上下文中执行，这意味着计分被忽略，并且子句被视为用于缓存。(<strong>过滤掉不要的数据</strong>)</p></li><li><p>must</p><p>子句（查询）必须出现在匹配的文档中，并将有助于得分。(<strong>用来做匹配的,表示需要出现在文档里</strong>)</p></li><li><p>must_not</p><p>子句（查询）不得出现在匹配的文档中。子句在过滤器上下文中执行，这意味着计分被忽略，并且子句被视为用于缓存。</p></li><li><p>should</p><p>子句（查询）应出现在匹配的文档中。【注意should的最小匹配数】</p></li></ul><blockquote><p>关于should子句，特别要注意：</p><p>如果这个布尔查询位于<code>query context</code>，并且有must或者filter子句，那么即使should子句没有匹配任何文档，也没关系</p><p>如果是位于<code>filter context</code>，或者既没有must也没有filter，那么至少有"指定"个should查询必须匹配文档。这个行为可以通过设置<code>minimum_should_match</code>参数来显式地控制。(至少满足几个should子句), 可以是正负整数/正负百分比等各种比例 (<strong>默认值是0</strong>)</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE3NjYwOQ==&amp;mid=2247483976&amp;idx=1&amp;sn=f9fc58f7f38ef79d4a652a9578ce1181&amp;chksm=974b59c6a03cd0d036f9e1cc9d211b999c9d3acdd664f4a250a1573089fdfe747c7784191066&amp;cur_album_id=1337850434433744897&amp;scene=190#rd" target=_blank rel=noopener>参数详情</a></p></blockquote><p><img loading=lazy src=https://img2018.cnblogs.com/blog/874963/201812/874963-20181201134433373-297882943.png alt=image></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>GET product/_search
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;bool&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>     &#34;filter&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#f85149>       {
</span></span></span><span style=display:flex><span><span style=color:#f85149>         &#34;range&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>           &#34;sellPrice&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>             &#34;gte&#34;: 1
</span></span></span><span style=display:flex><span><span style=color:#f85149>           }
</span></span></span><span style=display:flex><span><span style=color:#f85149>         }
</span></span></span><span style=display:flex><span><span style=color:#f85149>       }
</span></span></span><span style=display:flex><span><span style=color:#f85149>     ],
</span></span></span><span style=display:flex><span><span style=color:#f85149>     &#34;must&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#f85149>       {
</span></span></span><span style=display:flex><span><span style=color:#f85149>         &#34;match&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>           &#34;skuName&#34;: &#34;空调&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>         }
</span></span></span><span style=display:flex><span><span style=color:#f85149>       }
</span></span></span><span style=display:flex><span><span style=color:#f85149>     ]
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149> , &#34;_source&#34;: &#34;skuName&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span><span style=display:flex><span><span style=color:#f85149>// 查询skuName中&#34;空调&#34;的文档,并且过滤出sellPrice大于等于1的文档
</span></span></span></code></pre></div><blockquote><p>filter 子句类可包含 bool query，实现更复杂的逻辑, (俄罗斯套娃之深圳分套)</p></blockquote><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#f85149>// 多个条件
</span></span></span><span style=display:flex><span><span style=color:#f85149>GET service-java-logs-2021.07.16/_search
</span></span></span><span style=display:flex><span><span style=color:#f85149>{
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;_source&#34;: &#34;message&#34;, 
</span></span></span><span style=display:flex><span><span style=color:#f85149>  &#34;query&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>    &#34;bool&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;must&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#f85149>        {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;match_phrase&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;message&#34;: &#34;ERROR&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>          }
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>      ],
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;must_not&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#f85149>        {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;wildcard&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;message&#34;: &#34;*navigation*&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>          }
</span></span></span><span style=display:flex><span><span style=color:#f85149>        },
</span></span></span><span style=display:flex><span><span style=color:#f85149>        {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;match&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;message&#34;: &#34;defaultParameterMap&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>          }
</span></span></span><span style=display:flex><span><span style=color:#f85149>        },
</span></span></span><span style=display:flex><span><span style=color:#f85149>        {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;match&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;message&#34;: &#34;parameters&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>          }
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>      ], 
</span></span></span><span style=display:flex><span><span style=color:#f85149>      &#34;filter&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#f85149>        {
</span></span></span><span style=display:flex><span><span style=color:#f85149>          &#34;term&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#f85149>            &#34;log.file.path.keyword&#34;: &#34;/opt/online-shop-manage/logs/online-shop-manage-provider.log&#34;
</span></span></span><span style=display:flex><span><span style=color:#f85149>          }
</span></span></span><span style=display:flex><span><span style=color:#f85149>        }
</span></span></span><span style=display:flex><span><span style=color:#f85149>      ]
</span></span></span><span style=display:flex><span><span style=color:#f85149>    }
</span></span></span><span style=display:flex><span><span style=color:#f85149>  }
</span></span></span><span style=display:flex><span><span style=color:#f85149>}
</span></span></span></code></pre></div><h3 id=342--boosting-query>3.4.2 boosting query<a hidden class=anchor aria-hidden=true href=#342--boosting-query>#</a></h3><blockquote><p>来源:</p><p><a href=https://www.cnblogs.com/hong-fithing/p/11221020.html target=_blank rel=noopener>https://www.cnblogs.com/hong-fithing/p/11221020.html</a></p><p><a href=http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html target=_blank rel=noopener>http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html</a></p><p><a href=https://www.cnblogs.com/hirampeng/p/10035858.html target=_blank rel=noopener>https://www.cnblogs.com/hirampeng/p/10035858.html</a></p><p><a href=https://www.cnblogs.com/cjsblog/p/9910788.html target=_blank rel=noopener>https://www.cnblogs.com/cjsblog/p/9910788.html</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE3NjYwOQ==&amp;mid=2247483976&amp;idx=1&amp;sn=f9fc58f7f38ef79d4a652a9578ce1181&amp;chksm=974b59c6a03cd0d036f9e1cc9d211b999c9d3acdd664f4a250a1573089fdfe747c7784191066&amp;cur_album_id=1337850434433744897&amp;scene=190#rd" target=_blank rel=noopener>微信es系列</a></p><p><a href=https://www.knowledgedict.com/tutorial/elasticsearch-sort.html target=_blank rel=noopener>https://www.knowledgedict.com/tutorial/elasticsearch-sort.html</a></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/ElasticSearch.html>ElasticSearch</a></li><li><a href=https://xiaokunji.com/zh/tags/%E7%BB%BC%E5%90%88.html>综合</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Docker/%E5%91%BD%E4%BB%A4.html><span class=title>« 上一页</span><br><span>命令</span></a>
<a class=next href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Kubernetes/%E5%91%BD%E4%BB%A4.html><span class=title>下一页 »</span><br><span>命令</span></a></nav></footer></article></main><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>