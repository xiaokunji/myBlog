<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>IO多路复用 | 米二</title><meta name=keywords content=" 前言, **同步阻塞 IO**  (BIO), **同步非阻塞 IO (NIO)**, **IO 多路复用**, **select**, **poll**, **epoll**, 总结"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="IO多路复用"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"><meta property="article:section" content="综合"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-26T15:51:06+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="IO多路复用"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"IO多路复用","item":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"IO多路复用","name":"IO多路复用","description":"     ","keywords":[" 前言"," **同步阻塞 IO**  (BIO)"," **同步非阻塞 IO (NIO)**"," **IO 多路复用**"," **select**"," **poll**"," **epoll**"," 总结"],"articleBody":"[toc]\n前言 操作系统的一次IO过程\n应用程序发起的一次IO操作包含两个阶段：\nIO调用：应用程序进程向操作系统内核发起调用。\nIO执行：操作系统内核完成IO操作。\n操作系统内核完成IO操作还包括连个两个过程：\n准备数据阶段：数据从硬件拷贝到内核缓冲区，这里的硬件可以是磁盘，网卡等设备。\n拷贝数据阶段：将数据从内核缓冲区拷贝到用户空间缓冲区\n根据step1是否阻塞可以把IO操作划分为：\n阻塞IO\n非阻塞IO\n根据step2是否是否阻塞可以划分为：\n同步IO 异步IO 同步阻塞 IO (BIO) 服务端为了处理客户端的连接和请求的数据，写了如下代码。\nlistenfd = socket(); // 打开一个网络通信端口 bind(listenfd); // 绑定 listen(listenfd); // 监听 while(1) { connfd = accept(listenfd); // 阻塞建立连接 int n = read(connfd, buf); // 阻塞读数据 doSomeThing(buf); // 利用读到的数据做些什么 close(connfd); // 关闭连接，循环等待下一个连接 } 这段代码会执行得磕磕绊绊，就像这样。\n可以看到，服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。\n如果再把 read 函数的细节展开，我们会发现其阻塞在了两个阶段。\n这就是传统的阻塞 IO。\n整体流程如下图。\n所以，如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接。\n这肯定是不行的。\n文件描述符:\n既然在Linux操作系统中，你将一切都抽象为了文件，那么对于一个打开的文件，我应用程序怎么对应上呢？\n文件描述符应运而生\n文件描述符：简称fd，当应用程序请求内核打开/新建一个文件时，内核会返回一个文件描述符用于对应这个打开/新建的文件，其fd本质上就是一个非负整数，读写文件也是需要使用这个文件描述符来指定待读写的文件的\n理解文件描述符 - 简书 (jianshu.com) 同步非阻塞 IO (NIO) 为了解决上面的问题，其关键在于改造这个 read 函数。\n有一种聪明的办法是，每次都创建一个新的进程或线程，去调用 read 函数，并做业务处理。\nwhile(1) { connfd = accept(listenfd); // 阻塞建立连接 pthread_create（doWork); // 创建一个新的线程 } void doWork() { int n = read(connfd, buf); // 阻塞读数据 doSomeThing(buf); // 利用读到的数据做些什么 close(connfd); // 关闭连接，循环等待下一个连接 } 这样，当给一个客户端建立好连接后，就可以立刻等待新的客户端连接，而不用阻塞在原客户端的 read 请求上。\n不过，这不叫非阻塞 IO，只不过用了多线程的手段使得主线程没有卡在 read 函数上不往下走罢了。操作系统为我们提供的 read 函数仍然是阻塞的。\n所以真正的非阻塞 IO，不能是通过我们用户层的小把戏，而是要恳请操作系统为我们提供一个非阻塞的 read 函数。\n这个 read 函数的效果是，如果没有数据到达时（到达网卡并拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待。\n操作系统提供了这样的功能，只需要在调用 read 前，将文件描述符设置为非阻塞即可。\nfcntl(connfd, F_SETFL, O_NONBLOCK); int n = read(connfd, buffer) != SUCCESS); 这样，就需要用户线程循环调用 read，直到返回值不为 -1，再开始处理业务。\n这里我们注意到一个细节。\n非阻塞的 read，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的。\n当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。\n整体流程如下图\nIO 多路复用 多路复用是NIO的一种\n系统给我们提供一类函数（如 select、poll、epoll函数），它们可以同时监控多个connfd的操作，任何一个返回内核数据就绪，应用进程再发起recvfrom系统调用。\n多路复用: 多路指的是多个IO请求(准备数据阶段) , 复用指的是 复制数据阶段用同一个线程处理\n为每个客户端创建一个线程，服务器端的线程资源很容易被耗光。\n当然还有个聪明的办法，我们可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里。\nfdlist.add(connfd); 然后弄一个新的线程去不断遍历这个数组，调用每一个元素的非阻塞 read 方法。\nwhile(1) { for(fd \u003c-- fdlist) { if(read(fd) != -1) { doSomeThing(); } } } 这样，我们就成功用一个线程处理了多个客户端连接。\n你是不是觉得这有些多路复用的意思？\n但这和我们用多线程去将阻塞 IO 改造成看起来是非阻塞 IO 一样，这种遍历方式也只是我们用户自己想出的小把戏，每次遍历遇到 read 返回 -1 时仍然是一次浪费资源的系统调用。\n在 while 循环里做系统调用，就好比你做分布式项目时在 while 里做 rpc 请求一样，是不划算的。\n所以，还是得恳请操作系统老大，提供给我们一个有这样效果的函数，我们将一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题。\nselect select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理：\nselect系统调用的函数定义如下。\nint select( int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); // nfds:监控的文件描述符集里最大文件描述符加1 // readfds：监控有读数据到达文件描述符集合，传入传出参数 // writefds：监控写数据到达文件描述符集合，传入传出参数 // exceptfds：监控异常发生达文件描述符集合, 传入传出参数 // timeout：定时阻塞监控时间，3种情况 // 1.NULL，永远等下去 // 2.设置timeval，等待固定时间 // 3.设置timeval里时间均为0，检查描述字后立即返回，轮询 服务端代码，这样来写。\n首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。\nwhile(1) { connfd = accept(listenfd); fcntl(connfd, F_SETFL, O_NONBLOCK); fdlist.add(connfd); } 然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。\nwhile(1) { // 把一堆文件描述符 list 传给 select 函数 // 有已就绪的文件描述符就返回，nready 表示有多少个就绪的 nready = select(list); ... } 不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list。\n只不过，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。\nwhile(1) { nready = select(list); // 用户层依然要遍历，只不过少了很多无效的系统调用 for(fd \u003c-- fdlist) { if(fd != -1) { // 只读已就绪的文件描述符 read(fd, buf); // 总共只有 nready 个已就绪描述符，不用过多遍历 if(--nready == 0) break; } } } 正如刚刚的动图中所描述的，其直观效果如下。\n可以看出几个细节：\nselect 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）\nselect 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）\nselect 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）\n整个 select 的流程图如下:\n可以看到，这种方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用）。\npoll poll 也是操作系统提供的系统调用函数。\nint poll(struct pollfd *fds, nfds_tnfds, int timeout); struct pollfd { intfd; /*文件描述符*/ shortevents; /*监控的事件*/ shortrevents; /*监控事件中满足条件返回的事件*/ }; 它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。\nepoll epoll 是最终的大 boss，它解决了 select 和 poll 的一些问题。流程图如下:\n还记得上面说的 select 的三个细节么？\nselect 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）\nselect 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）\nselect 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）\n所以 epoll 主要就是针对这三点进行了改进。\n内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。\n内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。\n内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。\n具体，操作系统提供了这三个函数。\n第一步，创建一个 epoll 句柄\nint epoll_create(int size); 第二步，向内核添加、修改或删除要监控的文件描述符。\nint epoll_ctl( int epfd, int op, int fd, struct epoll_event *event); 第三步，类似发起了 select() 调用\nint epoll_wait( int epfd, struct epoll_event *events, int max events, int timeout); 使用起来，其内部原理就像如下一般丝滑。\n总结 一切的开始，都起源于这个 read 函数是操作系统提供的，而且是阻塞的，我们叫它 阻塞 IO。\n为了破这个局，程序员在用户态通过多线程来防止主线程卡死。\n后来操作系统发现这个需求比较大，于是在操作系统层面提供了非阻塞的 read 函数，这样程序员就可以在一个线程内完成多个文件描述符的读取，这就是 非阻塞 IO。\n但多个文件描述符的读取就需要遍历，当高并发场景越来越多时，用户态遍历的文件描述符也越来越多，相当于在 while 循环里进行了越来越多的系统调用。\n后来操作系统又发现这个场景需求量较大，于是又在操作系统层面提供了这样的遍历文件描述符的机制，这就是 IO 多路复用。\n多路复用有三个函数，最开始是 select，然后又发明了 poll 解决了 select 文件描述符的限制，然后又发明了 epoll 解决 select 的三个不足。\n所以，IO 模型的演进，其实就是时代的变化，倒逼着操作系统将更多的功能加到自己的内核而已。\n如果你建立了这样的思维，很容易发现网上的一些错误。\n比如好多文章说，多路复用之所以效率高，是因为用一个线程就可以监控多个文件描述符。\n这显然是知其然而不知其所以然，多路复用产生的效果，完全可以由用户态去遍历文件描述符并调用其非阻塞的 read 函数实现。而多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。\n就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。\nselect、poll、epoll的对比\nselect poll epoll 底层数据结构 数组 链表 红黑树和双链表 获取就绪的fd 遍历 遍历 事件回调 获取就绪的fd 遍历 遍历 事件回调 最大连接数 1024 无限制 无限制 fd数据拷贝 每次调用select，需要将fd数据从用户空间拷贝到内核空间 每次调用poll，需要将fd数据从用户空间拷贝到内核空间 使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间 图解IO模型——BIO，NIO，AIO - 简书 (jianshu.com) 彻底搞懂IO多路复用 (qq.com) 扩展阅读: 图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的! 看一遍就理解：IO模型详解 - 掘金 (juejin.cn) ","wordCount":"4122","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-08-26T15:51:06.080510167Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives/ title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>米二</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/>综合</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/>计算机基础</a> <span>></span></ul></nav><h1 class=post-title>IO多路复用</h1><div class=post-description></div><div class=post-meta><span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/%E7%BB%BC%E5%90%88/>综合</a></ul><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e5%90%8c%e6%ad%a5%e9%98%bb%e5%a1%9e-io--bio aria-label="同步阻塞 IO (BIO)"><strong>同步阻塞 IO</strong> (BIO)</a></li><li><a href=#%e5%90%8c%e6%ad%a5%e9%9d%9e%e9%98%bb%e5%a1%9e-io-nio aria-label="同步非阻塞 IO (NIO)"><strong>同步非阻塞 IO (NIO)</strong></a></li><li><a href=#io-%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8 aria-label="IO 多路复用"><strong>IO 多路复用</strong></a><ul><li><a href=#select aria-label=select><strong>select</strong></a></li><li><a href=#poll aria-label=poll><strong>poll</strong></a></li><li><a href=#epoll aria-label=epoll><strong>epoll</strong></a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h1><p><strong>操作系统的一次IO过程</strong></p><p>应用程序发起的一次IO操作包含两个阶段：</p><ul><li><p>IO调用：应用程序进程向操作系统内核发起调用。</p></li><li><p>IO执行：操作系统内核完成IO操作。</p></li></ul><p>操作系统内核完成IO操作还包括连个两个过程：</p><ol><li><p>准备数据阶段：数据从硬件拷贝到内核缓冲区，这里的硬件可以是磁盘，网卡等设备。</p></li><li><p>拷贝数据阶段：将数据从内核缓冲区拷贝到用户空间缓冲区</p></li></ol><p>根据step1是否阻塞可以把IO操作划分为：</p><ul><li><p>阻塞IO</p></li><li><p>非阻塞IO</p></li></ul><p>根据step2是否是否阻塞可以划分为：</p><ul><li>同步IO</li><li>异步IO</li></ul><p><img loading=lazy src=IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.assets/45ca61379486479988c1e05003a4b421tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp alt=img></p><h1 id=同步阻塞-io--bio><strong>同步阻塞 IO</strong> (BIO)<a hidden class=anchor aria-hidden=true href=#同步阻塞-io--bio>#</a></h1><p>服务端为了处理客户端的连接和请求的数据，写了如下代码。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>listenfd <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>socket</span>();   <span style=color:#8b949e;font-style:italic>// 打开一个网络通信端口
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#d2a8ff;font-weight:700>bind</span>(listenfd);        <span style=color:#8b949e;font-style:italic>// 绑定
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#d2a8ff;font-weight:700>listen</span>(listenfd);      <span style=color:#8b949e;font-style:italic>// 监听
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>while</span>(<span style=color:#a5d6ff>1</span>) {
</span></span><span style=display:flex><span>  connfd <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>accept</span>(listenfd);  <span style=color:#8b949e;font-style:italic>// 阻塞建立连接
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#ff7b72>int</span> n <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>read</span>(connfd, buf);  <span style=color:#8b949e;font-style:italic>// 阻塞读数据
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#d2a8ff;font-weight:700>doSomeThing</span>(buf);  <span style=color:#8b949e;font-style:italic>// 利用读到的数据做些什么
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#d2a8ff;font-weight:700>close</span>(connfd);     <span style=color:#8b949e;font-style:italic>// 关闭连接，循环等待下一个连接
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>}
</span></span></code></pre></div><p>这段代码会执行得磕磕绊绊，就像这样。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zArJDictJLnnRWwXriaXkgJFXnUsibFTlxjqSaBicqpeH4NhXBCqWuFgc7VQ/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1" alt=图片></p><p>可以看到，服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。</p><p>如果再把 read 函数的细节展开，我们会发现其阻塞在了两个阶段。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zADM8nrhNkEtFpSpLjGicOemZ5mt7orYF8vFC7g83lPVDeSbnlgKl7XaA/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1" alt=图片></p><p>这就是传统的阻塞 IO。</p><p>整体流程如下图。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAadgqoGRuEcAClAdesz7WTGhq6ugGbCKNiaghwqyAJJBC1GtVuYpkkmA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=图片></p><p>所以，如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接。</p><p>这肯定是不行的。</p><blockquote><p><strong>文件描述符</strong>:</p><p>既然在Linux操作系统中，你将一切都抽象为了文件，那么对于一个打开的文件，我应用程序怎么对应上呢？</p><p>文件描述符应运而生</p><p>文件描述符：简称fd，当应用程序请求内核打开/新建一个文件时，内核会返回一个文件描述符用于对应这个打开/新建的文件，其fd本质上就是一个非负整数，读写文件也是需要使用这个文件描述符来指定待读写的文件的</p><p><a href=https://www.jianshu.com/p/a2df1d402b4d target=_blank rel=noopener>理解文件描述符 - 简书 (jianshu.com)</a></p></blockquote><h1 id=同步非阻塞-io-nio><strong>同步非阻塞 IO (NIO)</strong><a hidden class=anchor aria-hidden=true href=#同步非阻塞-io-nio>#</a></h1><p>为了解决上面的问题，其关键在于改造这个 read 函数。</p><p>有一种聪明的办法是，每次都创建一个新的进程或线程，去调用 read 函数，并做业务处理。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff7b72>while</span>(<span style=color:#a5d6ff>1</span>) {
</span></span><span style=display:flex><span>  connfd <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>accept</span>(listenfd);  <span style=color:#8b949e;font-style:italic>// 阻塞建立连接
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  pthread_create<span style=color:#f85149>（</span>doWork);  <span style=color:#8b949e;font-style:italic>// 创建一个新的线程
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>}
</span></span><span style=display:flex><span><span style=color:#ff7b72>void</span> <span style=color:#d2a8ff;font-weight:700>doWork</span>() {
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>int</span> n <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>read</span>(connfd, buf);  <span style=color:#8b949e;font-style:italic>// 阻塞读数据
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#d2a8ff;font-weight:700>doSomeThing</span>(buf);  <span style=color:#8b949e;font-style:italic>// 利用读到的数据做些什么
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#d2a8ff;font-weight:700>close</span>(connfd);     <span style=color:#8b949e;font-style:italic>// 关闭连接，循环等待下一个连接
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>}
</span></span></code></pre></div><p>这样，当给一个客户端建立好连接后，就可以立刻等待新的客户端连接，而不用阻塞在原客户端的 read 请求上。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zA55fIbicSuYiad7vYdyLD0usibPibYiaAjBDR0gQPzArnzYlWXOZRyQzub3Q/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1" alt=图片></p><p>不过，这不叫非阻塞 IO，只不过用了多线程的手段使得主线程没有卡在 read 函数上不往下走罢了。操作系统为我们提供的 read 函数仍然是阻塞的。</p><p>所以真正的非阻塞 IO，不能是通过我们用户层的小把戏，<strong>而是要恳请操作系统为我们提供一个非阻塞的 read 函数</strong>。</p><p>这个 read 函数的效果是，如果没有数据到达时（到达网卡并拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待。</p><p>操作系统提供了这样的功能，只需要在调用 read 前，将文件描述符设置为非阻塞即可。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>fcntl</span>(connfd, F_SETFL, O_NONBLOCK);
</span></span><span style=display:flex><span><span style=color:#ff7b72>int</span> n <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>read</span>(connfd, buffer) <span style=color:#ff7b72;font-weight:700>!=</span> SUCCESS);
</span></span></code></pre></div><p>这样，就需要用户线程循环调用 read，直到返回值不为 -1，再开始处理业务。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAT6rHhibbzK5rXiarLuJU0P4MGrHNl35vVCV4JdS4FeejOkl8bBGz9nVQ/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1" alt=图片></p><p>这里我们注意到一个细节。</p><p>非阻塞的 read，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的。</p><p>当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。</p><p>整体流程如下图</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zA4NCGPZZo9ydSiczrguMdwqFNvibGlzbaopiauFxTqrIa5po5faEAoY7HA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=图片></p><h1 id=io-多路复用><strong>IO 多路复用</strong><a hidden class=anchor aria-hidden=true href=#io-多路复用>#</a></h1><blockquote><p>多路复用是NIO的一种</p><p>系统给我们提供一类函数（如 <strong>select</strong>、<strong>poll</strong>、<strong>epoll</strong>函数），它们可以同时监控多个connfd的操作，任何一个返回内核数据就绪，应用进程再发起<code>recvfrom</code>系统调用。</p><p>多路复用: <strong>多路</strong>指的是多个IO请求(准备数据阶段) , <strong>复用</strong>指的是 复制数据阶段用同一个线程处理</p></blockquote><p>为每个客户端创建一个线程，服务器端的线程资源很容易被耗光。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAibNxnhFichNdFVYbbTYQ45AhMnzQm7MYRwg3gWUYNib9MKUDpuibHRINlA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=图片></p><p>当然还有个聪明的办法，我们可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>fdlist.<span style=color:#d2a8ff;font-weight:700>add</span>(connfd);
</span></span></code></pre></div><p>然后弄一个新的线程去不断遍历这个数组，调用每一个元素的非阻塞 read 方法。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff7b72>while</span>(<span style=color:#a5d6ff>1</span>) {
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>for</span>(fd <span style=color:#ff7b72;font-weight:700>&lt;--</span> fdlist) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span>(<span style=color:#d2a8ff;font-weight:700>read</span>(fd) <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#d2a8ff;font-weight:700>doSomeThing</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样，我们就成功用一个线程处理了多个客户端连接。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zABlkKBoB04kDCApjketfzN9PWTwjwTng4ibWJTibCDmE3FsiaOTibAdaO3A/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1" alt=图片></p><p>你是不是觉得这有些多路复用的意思？</p><p>但这和我们用多线程去将阻塞 IO 改造成看起来是非阻塞 IO 一样，这种遍历方式也只是我们用户自己想出的小把戏，每次遍历遇到 read 返回 -1 时仍然是一次浪费资源的系统调用。</p><p>在 while 循环里做系统调用，就好比你做分布式项目时在 while 里做 rpc 请求一样，是不划算的。</p><p>所以，还是得恳请操作系统老大，提供给我们一个有这样效果的函数，我们将一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题。</p><h2 id=select><strong>select</strong><a hidden class=anchor aria-hidden=true href=#select>#</a></h2><p>select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理：</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAicgy5qFYcyoWPAV31k82icRe6I4Lya2F9qWcBlhHv3kzpgt9yjD7Hnpw/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1" alt=图片></p><p>select系统调用的函数定义如下。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>select</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>int</span> nfds,
</span></span><span style=display:flex><span>    fd_set <span style=color:#ff7b72;font-weight:700>*</span>readfds,
</span></span><span style=display:flex><span>    fd_set <span style=color:#ff7b72;font-weight:700>*</span>writefds,
</span></span><span style=display:flex><span>    fd_set <span style=color:#ff7b72;font-weight:700>*</span>exceptfds,
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>struct</span> timeval <span style=color:#ff7b72;font-weight:700>*</span>timeout);
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// nfds:监控的文件描述符集里最大文件描述符加1
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// readfds：监控有读数据到达文件描述符集合，传入传出参数
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// writefds：监控写数据到达文件描述符集合，传入传出参数
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// exceptfds：监控异常发生达文件描述符集合, 传入传出参数
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// timeout：定时阻塞监控时间，3种情况
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>//  1.NULL，永远等下去
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>//  2.设置timeval，等待固定时间
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询
</span></span></span></code></pre></div><p>服务端代码，这样来写。</p><p>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff7b72>while</span>(<span style=color:#a5d6ff>1</span>) {
</span></span><span style=display:flex><span>  connfd <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>accept</span>(listenfd);
</span></span><span style=display:flex><span>  <span style=color:#d2a8ff;font-weight:700>fcntl</span>(connfd, F_SETFL, O_NONBLOCK);
</span></span><span style=display:flex><span>  fdlist.<span style=color:#d2a8ff;font-weight:700>add</span>(connfd);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff7b72>while</span>(<span style=color:#a5d6ff>1</span>) {
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 把一堆文件描述符 list 传给 select 函数
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#8b949e;font-style:italic>// 有已就绪的文件描述符就返回，nready 表示有多少个就绪的
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  nready <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>select</span>(list);
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list。</p><p>只不过，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff7b72>while</span>(<span style=color:#a5d6ff>1</span>) {
</span></span><span style=display:flex><span>  nready <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#d2a8ff;font-weight:700>select</span>(list);
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 用户层依然要遍历，只不过少了很多无效的系统调用
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#ff7b72>for</span>(fd <span style=color:#ff7b72;font-weight:700>&lt;--</span> fdlist) {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span>(fd <span style=color:#ff7b72;font-weight:700>!=</span> <span style=color:#ff7b72;font-weight:700>-</span><span style=color:#a5d6ff>1</span>) {
</span></span><span style=display:flex><span>      <span style=color:#8b949e;font-style:italic>// 只读已就绪的文件描述符
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>      <span style=color:#d2a8ff;font-weight:700>read</span>(fd, buf);
</span></span><span style=display:flex><span>      <span style=color:#8b949e;font-style:italic>// 总共只有 nready 个已就绪描述符，不用过多遍历
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>      <span style=color:#ff7b72>if</span>(<span style=color:#ff7b72;font-weight:700>--</span>nready <span style=color:#ff7b72;font-weight:700>==</span> <span style=color:#a5d6ff>0</span>) <span style=color:#ff7b72>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>正如刚刚的动图中所描述的，其直观效果如下。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAicgy5qFYcyoWPAV31k82icRe6I4Lya2F9qWcBlhHv3kzpgt9yjD7Hnpw/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1" alt=图片></p><p>可以看出几个细节：</p><ol><li><p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p></li><li><p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p></li><li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p></li></ol><p>整个 select 的流程图如下:</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAr5qibfgLBad0zoCEWXxdqC9I4v4mAYLR2SiafwtG4qOmdicHxa1Sx8MKQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=图片></p><p>可以看到，这种方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用）。</p><h2 id=poll><strong>poll</strong><a hidden class=anchor aria-hidden=true href=#poll>#</a></h2><p>poll 也是操作系统提供的系统调用函数。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>poll</span>(<span style=color:#ff7b72>struct</span> pollfd <span style=color:#ff7b72;font-weight:700>*</span>fds, nfds_tnfds, <span style=color:#ff7b72>int</span> timeout);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> pollfd {
</span></span><span style=display:flex><span>  intfd; <span style=color:#8b949e;font-style:italic>/*文件描述符*/</span>
</span></span><span style=display:flex><span>  shortevents; <span style=color:#8b949e;font-style:italic>/*监控的事件*/</span>
</span></span><span style=display:flex><span>  shortrevents; <span style=color:#8b949e;font-style:italic>/*监控事件中满足条件返回的事件*/</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。</p><h2 id=epoll><strong>epoll</strong><a hidden class=anchor aria-hidden=true href=#epoll>#</a></h2><p>epoll 是最终的大 boss，它解决了 select 和 poll 的一些问题。流程图如下:</p><p><img loading=lazy src=IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.assets/58a287b7295c4dce91453fc1412270d4tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp alt=img></p><p>还记得上面说的 select 的三个细节么？</p><ol><li><p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p></li><li><p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p></li><li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p></li></ol><p>所以 epoll 主要就是针对这三点进行了改进。</p><ol><li><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p></li><li><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p></li><li><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p></li></ol><p>具体，操作系统提供了这三个函数。</p><p>第一步，创建一个 epoll 句柄</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>epoll_create</span>(<span style=color:#ff7b72>int</span> size);
</span></span></code></pre></div><p>第二步，向内核添加、修改或删除要监控的文件描述符。</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>epoll_ctl</span>(
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>int</span> epfd, <span style=color:#ff7b72>int</span> op, <span style=color:#ff7b72>int</span> fd, <span style=color:#ff7b72>struct</span> epoll_event <span style=color:#ff7b72;font-weight:700>*</span>event);
</span></span></code></pre></div><p>第三步，类似发起了 select() 调用</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>epoll_wait</span>(
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>int</span> epfd, <span style=color:#ff7b72>struct</span> epoll_event <span style=color:#ff7b72;font-weight:700>*</span>events, <span style=color:#ff7b72>int</span> max events, <span style=color:#ff7b72>int</span> timeout);
</span></span></code></pre></div><p>使用起来，其内部原理就像如下一般丝滑。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAjXNXJTV82eOqkbJdOrDpQpAaWiceBqvAXyFEOTdV5fC2dNsL29yBW7w/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1" alt=图片></p><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><p>一切的开始，都起源于这个 read 函数是操作系统提供的，而且是阻塞的，我们叫它 <strong>阻塞 IO</strong>。</p><p>为了破这个局，程序员在用户态通过多线程来防止主线程卡死。</p><p>后来操作系统发现这个需求比较大，于是在操作系统层面提供了非阻塞的 read 函数，这样程序员就可以在一个线程内完成多个文件描述符的读取，这就是 <strong>非阻塞 IO</strong>。</p><p>但多个文件描述符的读取就需要遍历，当高并发场景越来越多时，用户态遍历的文件描述符也越来越多，相当于在 while 循环里进行了越来越多的系统调用。</p><p>后来操作系统又发现这个场景需求量较大，于是又在操作系统层面提供了这样的遍历文件描述符的机制，这就是 <strong>IO 多路复用</strong>。</p><p>多路复用有三个函数，最开始是 select，然后又发明了 poll 解决了 select 文件描述符的限制，然后又发明了 epoll 解决 select 的三个不足。</p><p>所以，IO 模型的演进，其实就是时代的变化，倒逼着操作系统将更多的功能加到自己的内核而已。</p><p>如果你建立了这样的思维，很容易发现网上的一些错误。</p><p>比如好多文章说，多路复用之所以效率高，是因为用一个线程就可以监控多个文件描述符。</p><p>这显然是知其然而不知其所以然，多路复用产生的效果，完全可以由用户态去遍历文件描述符并调用其非阻塞的 read 函数实现。而多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。</p><p>就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加。</p><p><strong>select、poll、epoll的对比</strong></p><table><thead><tr><th></th><th>select</th><th>poll</th><th>epoll</th></tr></thead><tbody><tr><td>底层数据结构</td><td>数组</td><td>链表</td><td>红黑树和双链表</td></tr><tr><td>获取就绪的fd</td><td>遍历</td><td>遍历</td><td>事件回调</td></tr><tr><td>获取就绪的fd</td><td>遍历</td><td>遍历</td><td>事件回调</td></tr><tr><td>最大连接数</td><td>1024</td><td>无限制</td><td>无限制</td></tr><tr><td>fd数据拷贝</td><td>每次调用select，需要将fd数据从用户空间拷贝到内核空间</td><td>每次调用poll，需要将fd数据从用户空间拷贝到内核空间</td><td>使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间</td></tr></tbody></table><p><a href=https://www.jianshu.com/p/0a3ddba86de0 target=_blank rel=noopener>图解IO模型——BIO，NIO，AIO - 简书 (jianshu.com)</a></p><p><a href=https://mp.weixin.qq.com/s/kebjG5UosHmXa7AKCatSrA target=_blank rel=noopener>彻底搞懂IO多路复用 (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&amp;mid=2247484905&amp;idx=1&amp;sn=a74ed5d7551c4fb80a8abe057405ea5e&amp;chksm=a6e304d291948dc4fd7fe32498daaae715adb5f84ec761c31faf7a6310f4b595f95186647f1" target=_blank rel=noopener>扩展阅读: 图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的!</a></p><p><a href=https://juejin.cn/post/7036518015462015006#heading-4 target=_blank rel=noopener>看一遍就理解：IO模型详解 - 掘金 (juejin.cn)</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/>计算机基础</a></li><li><a href=https://xiaokunji.com/zh/tags/%E7%BB%BC%E5%90%88/>综合</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/spring/ioc%E6%8E%A7%E5%88%B6%E7%BF%BB%E8%BD%AC%E5%92%8Cdi%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/><span class=title>« 上一页</span><br><span>Ioc(控制翻转)和DI(依赖注入)</span></a>
<a class=next href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/io%E6%B5%81/><span class=title>下一页 »</span><br><span>IO流</span></a></nav></footer></article></main><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>