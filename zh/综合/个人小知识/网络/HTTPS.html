<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>HTTPS | 米二</title><meta name=keywords content=" 介绍, 基础知识, 非对称加密 , 对称加密 , 证书, CA, 数字签名 , HTTPS的协议栈层级, HTTPS交互消息, HTTPS的握手, RSA握手 (TLS1.1/1.2), DH 握手(TLS1.2), TLS1.3 握手, 证书链, CA组织, certificates(证书), 总结, Q&amp;A, 中间人攻击是什么, 为什么数据传输是用对称加密？, 用了 HTTPS 会被抓包吗？, HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/HTTPS.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/HTTPS.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="HTTPS"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/HTTPS.html"><meta property="article:section" content="综合"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-04T05:50:23+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="HTTPS"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"HTTPS","item":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/HTTPS.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"HTTPS","name":"HTTPS","description":"     ","keywords":[" 介绍"," 基础知识"," 非对称加密 "," 对称加密 "," 证书"," CA"," 数字签名 "," HTTPS的协议栈层级"," HTTPS交互消息"," HTTPS的握手"," RSA握手 (TLS1.1/1.2)"," DH 握手(TLS1.2)"," TLS1.3 握手"," 证书链"," CA组织"," certificates(证书)"," 总结"," Q\u0026A"," 中间人攻击是什么"," 为什么数据传输是用对称加密？"," 用了 HTTPS 会被抓包吗？"," HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？"],"articleBody":"[toc]\n介绍 HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http :体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。\n基础知识 非对称加密 加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 例如：RSA、DSA、ECDSA、 DH、ECDHE。\n既可以用公钥加密私钥解密（传输敏感信息场景），也可以用私钥加密公钥解密（用户认证场景）\n例如\n非对称加密利用成对的两个秘钥：K1 和 K2。小红用其中一个加密文本，小明可 以用另一个解密文本。比如，小红用 K1 加密，小明用 K2 解密：\n小红 : C = E(M, K1) 小明 : M = D(C, K2) 这样一来，双方中的一方（比如小红）可以生成 K1和K2，然后把其中一个秘钥 （比如K1）私藏，称为私钥；另一个（比如K2）公开，称为公钥。另一 方（比如小明）得到公钥之后，双方就可以通信。\n因为加密和解密的 秘钥值不一样, 所以是不可逆吧\nRSA 算法：该算法的命名以三位科学家的姓氏缩写组合得来，在计算机网络世界，一直是最广为使用的 “非对称加密算法”。\nECC 是非对称加密里的 “后起之秀”，它基于 “椭圆曲线离散对数” 的数学难题，使用特定的曲线方程和基点生成公钥和私钥，子算法 ECDHE 用于密钥交换，ECDSA 用于数字签名。\n对称加密 有流式、分组两种，加密和解密都是使用的同一个密钥。 例如：DES、AES-GCM、ChaCha20-Poly1305等。\n因为加密和解密的 秘钥值是一样的, 所以也是可逆\n证书 证书是用来认证公钥持有者的身份的电子文档，防止第三方进行冒充。一个证书中包含了公钥、持有者信息、证明证书内容有效的签名以及证书有效期，还有一些其他额外信息。操作系统、浏览器本身会预装一些它们信任的根证书，如果其中有该CA机构的根证书，那就可以拿到它对应的可信公钥了。\n实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做信任链或数字证书链，也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。\nCA CA就是签发电子证书的实体。\n数字签名 数字签名技术是将摘要信息用发送者的私钥加密 (CA的私钥)，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。 数字签名是个加密的过程，数字签名验证是个解密的过程。 普通数字签名算法有RSA、ElGamal、Fiat-Shamir、Guillou- Quisquarter、Schnorr、Ong-Schnorr-Shamir数字签名算法、Des/DSA,椭圆曲线数字签名算法和有限自动机数字签名算法等。\nHTTPS使用CA证书的传输方式就是使用了数字签名，非对称加密，对称加密等混合加密技术。\n所以上面用私钥加密, 就是用的CA证书的私钥\nCA数字签名的做法:\n小红把自己的公钥和ID（身份证号码，或者域名）合为身份证申请（certificate signing request，CSR），小红把CSR发给一个信任的人小亮。（被称为 certificate authority，CA） 小亮用自己的私钥加密小红的 CSR，得到的密文被称为数字签名（digital signature）。 小亮把 signature 和 CSR 的明文合在一起称为 CA签署的身份证（CA signed certificate，CRT），发给小红。 每当其他人（比如小明）找小红聊天（建立HTTPS连接）的时候，小红出示自己的小亮签署的身份证。 拿到这个身份证的人，只要小明是相信小亮的——在自己机器上安装了小亮的身份证，就可以从小亮的身份证中的CSR里提取小亮的公钥；\n然后用小亮的公钥解密小红的身份证中小亮的signature，得到一个小红的CSR； 如果这个CSR’和小红身份证中的CSR明文一致，则说明“这个小红的身份证是小亮确认过并且签名的”。\nHTTPS的协议栈层级 SSL/TLS协议严格的说位于OSI-7层模型传输层(TCP, UDP)协议之上、应用层之下的会话层。\n如上图所示 HTTPS 相比 HTTP 多了一层 SSL/TLS\nSSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。\nTLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。\n现在不会直接使用SSL协议了, 只是TLS的前身是SSL,且大家习惯了, 所以才会说https的协议是SSL\nTLS协议是一个分层协议，本身可以分为上下两层：\n下层为TLS记录层协议（record layer protocal) 上层为TLS握手层协议（handshake layer protocal) TLS协议的组成如下：\nHTTPS交互消息 说明(四次挥手)：\n浏览器向服务器发送随机数 client_random，TLS 版本和供筛选的加密套件列表。 服务器接收到，立即返回 服务端随机数server_random，以及双方都支持的加密套件 以及数字证书 (证书中附带公钥 Public key certificate)。 浏览器接收，先验证数字证书。若通过，接着使用加密套件的密钥协商算法 RSA 算法生成另一个随机数 pre_random，并且用证书里的公钥加密，传给服务器。 服务器用私钥解密这个被加密后的 pre_random 现在浏览器和服务器都拥有三样相同的凭证：client_random、server_random 和 pre_random。两者都用筛好的加密套件中的加密方法混合这三个随机数，生成数据传输的密钥。\n所以: HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。\nHTTPS是先进行TCP三次握手，再进行TLS四次握手 , 但如果是TLS1.3版本,可以TCP和TLS握手同时进行, 因为TCP的第三次握手时已经安全,可以携带数据了 (如果是TLS1.3 只需要两次握手)\n给面试官上一课：HTTPS是先进行TCP三次握手，再进行TLS四次握手 - 知乎 (zhihu.com) HTTPS的握手 TLS 主要的两种握手方式，分别为：RSA 握手、DH 握手。再以 DH 握手 为基础继续演进优化，推出更安全、性能更佳的 TLS1.3 版本握手方式\nRSA握手 (TLS1.1/1.2) 具体流程如下：\n浏览器向服务器发送随机数 client_random，TLS 版本和供筛选的加密套件列表。 服务器接收到，立即返回 server_random，确认好双方都支持的加密套件 以及数字证书 (证书中附带公钥 Public key certificate)。 浏览器接收，先验证数字证书。若通过，接着使用加密套件的密钥协商算法 RSA 算法生成另一个随机数 pre_random，并且用证书里的公钥加密，传给服务器。 服务器用私钥解密这个被加密后的 pre_random 现在浏览器和服务器都拥有三样相同的凭证：client_random、server_random 和 pre_random。两者都用筛好的加密套件中的加密方法混合这三个随机数，生成最终的密钥。最后，浏览器和服务器使用相同的密钥进行通信，即使用 对称加密。\nDH 握手(TLS1.2) 具体流程如下:\n浏览器向服务器发送随机数 client_random，TLS 版本和供筛选的加密套件列表。 服务器接收到后，确认好双方都支持的加密套件以及数字证书 (证书中附带公钥)。同时服务器利用私钥将 client_random，server_random，server_params 签名，生成服务器签名。然后将签名和 server_params 以及 server_random发送给客户端。 这里的 server_params 为 DH 算法所需参数。 浏览器接收，先验证数字证书和 签名。若通过，将 client_params 传递给服务器。这里的 client_params 为 DH 算法所需参数。 现在客户端和服务器都有 client_params、server_params 两个参数，因 ECDHE 计算基于 “椭圆曲线离散对数”，通过这两个 DH 参数就能计算出 pre_random。 得益于算法机制, 第三个随机数不需要通过网络传输, 安全性更高\nDH 密钥交换协议\nDH 密钥交换协议，Diffile-Hellman key Exchange，简称 DH 或 DHE 。它可以让双方在完全没有对方任何预先信息的条件下通过一个不安全的信道创建一个密钥。 k这个秘钥值可以通过不同的参数求证而得\n其安全性是和RSA是一样的，其安全性依赖于大数因数分解，所以提高安全性只能靠增加位数来保证，这样就涉及大量的乘法运算。性能比较低下。\n为了解决上述DH的问题，引入了ECC椭圆曲线，进而进化为 ECDHE 算法\nTLS1.3 握手 TLS1.3 废除了原有的部分不安全的加密算法，其中甚至包括 RSA 算法。基于ECC(椭圆曲线算法)\nRSA 算法的废除不仅因为已经有大能将其破解，同时还缺少 前向安全性。\n流程梳理：\n浏览器向服务器发送 client_params，client_random，TLS 版本和供筛选的加密套件列表。 服务器返回：server_random、server_params、TLS 版本、确定的加密套件方法以及证书。浏览器接收，先验证数字证书和签名。现在双方都有 client_params、server_params，可以根据 ECDHE 计算出 pre_random 了。 最后，集齐三个参数，生成最终秘钥。\n如你所见，TLS1.3 客户端和服务器之间只需要一次往返就完成 (TLS1.2 需要两次往返来完成握手)，即 1-RTT 握手。\nRTT : Round-Trip Time – 往返延时, 表示从发送端发送数据开始，到发送端收到来自接收端的确认\n—RTT（Round-Trip Time）_越来越胖的GuanRunwei的博客-CSDN博客 前向安全性: 指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。前向安全能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁\nRSA 没有向前安全性，也就是需要每次的对称加密密钥的传递都是基于 公钥加密，服务端私钥解密。如果服务端的私钥丢失了，那几年前的通信数据都有可能被解密。所以这是极度不安全的，私钥的地位太重了，如果每次的加解密都是临时生成的密码来解决安全性，才不会对私钥的安全性有如此强的依赖。\nTLS过程（DH 非对称加密） - 简书 (jianshu.com) TLS 详解握手流程 - 掘金 (juejin.cn) 证书链 在Chrome上随便打开一个https的网站 https://fmall.gree.com/distributionh5 ，我们会发现在地址栏的左侧有个绿色的小锁，点击这个小锁，然后就可以查看这个网站的证书信息。查看证书信息如下：\n除了HTTPS使用的 gree.com 证书，向上还有两级证书，证书有3类：\nend-user ：gree.com 包含用来加密传输数据的公钥的证书，是HTTPS中使用的证书 intermediates：CA用来认证公钥持有者身份的证书，即确认HTTPS使用的end-user证书是属于gree.com的证书。这类intermediates证书甚至可以有很多级。 root：用来认证intermediates证书是合法证书的证书。 简单来说，end-user证书上面几级证书都是为了保证end-user证书未被篡改，保证是CA签发的合法证书，进而保证end-user证书中的公钥未被篡改。\nCA组织 除了end-user之外，证书被分为root Certificates和intermediates Certificates。相应地，CA也分了两种类型：root CAs 和 intermediates CAs。首先，CA的组织结构是一个树结构，一个root CAs下面包含多个intermediates CAs，而intermediates又可以包含多个intermediates CAs。root CAs 和 intermediates CAs都可以颁发证书给用户，颁发的证书分别是root Certificates和intermediates Certificates，最终用户用来认证公钥的证书则被称为end-user Certificates。\n因为证书有 root 和 intermediates两种, 所以CA组织也有两种, 而且intermediates间也可以颁发\ncertificates(证书) 我们使用end-user certificates来确保加密传输数据的公钥(public key)不被篡改，而又如何确保end-user certificates的合法性呢？这个认证过程跟公钥的认证过程类似，首先获取颁布end-user certificates的CA的证书，然后验证end-user certificates的signature。\n就是套娃一样, 用end-user要保证数据安全, 用intermediate是来保证end-user的安全, 用root来保证intermediates的安全, 这样就形成了证书链\n一般来说，root CAs不会直接颁布end-user certificates的，而是授权给多个二级CA，而二级CA又可以授权给多个三级CA，这些中间的CA就是intermediates CAs，它们才会颁布end-user certificates。\n为什么需要证书链这么麻烦的流程？\nRoot CA为什么不直接版本证书，而是要搞那么多中间层级呢？找了一下，godaddy官方给了一个答案，为了确保root certificates的绝对安全性，https://sg.godaddy.com/en/help/what-is-an-intermediate-certificate-868 ，将根证书隔离地越严格越好。有点像设计模式中的最少知道原则\n了解了这个证书体系之后，才明白为什么百度/google这种公司也需要向第三方购买签名证书了，自签root证书推广起来非常困难，这也导致目前的证书市场基本上被 Symantec(VeriSign/GeoTrust) / Comodo / GoDaddy 垄断。百度使用的是Versign，google使用的是GeoTrust。目前HTTPS的推广已经不可避免，也已经有一些公益组织开始提供免费、自动化、开放的证书签发服务，例如：Let’s Encrypt 。详细使用可以参考 入门指南 - Let’s Encrypt - 免费的SSL/TLS证书 (letsencrypt.org) 总结 Q\u0026A 中间人攻击是什么 CA颁发证书就是解决了中间人攻击.\n假设没有CA证书, 客户端和服务端直接连接交互,流程如下:\n服务器为每个客户端生成一个公钥，将公钥发送给客户端； 客户端选择一个加密算法，然后用公钥加密以后发送给服务器； 服务器收到这个公钥加密后的算法以后拿自己的私钥解密，然后就知道这个加密算法是哪个了。今后就一直用这个算法通信； 但如果有人, 在客户端和服务端做个拦截, 所有的交互都经过中间人, 从第一步开始就冒充了服务端, 把中间人的公钥给客户端, 这样中间人就可以代替服务端与客户端交互, 或者篡改数据后转发给服务端, 这就是中间人攻击\n为什么数据传输是用对称加密？ 首先：非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。\n用了 HTTPS 会被抓包吗？ HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，无法直接查看。\n但是，正如前文所说，浏览器只会提示安全风险，如果用户授权仍然可以继续访问网站，完成请求。因此，只要客户端是我们自己的终端，我们授权的情况下，便可以组建中间人网络，而抓包工具便是作为中间人的代理。通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。\n既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？\nHTTPS 可以防止用户在不知情的情况下通信链路被监听，对于主动授信的抓包操作是不提供防护的，因为这个场景用户是已经对风险知情。要防止被抓包，需要采用应用级的安全防护，例如采用私有的对称加密，同时做好移动端的防反编译加固，防止本地算法被破解。\nHTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？ 这也是我当时的困惑之一，显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？靠“session”。\n服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！\nHTTPS协议原理和流程分析 - 腾讯云开发者社区-腾讯云 (tencent.com) 你知道，HTTPS用的是对称加密还是非对称加密？ - 知乎 (zhihu.com) HTTPS用的是对称加密还是非对称加密？ - Rogn - 博客园 (cnblogs.com) 数字签名是什么？ - 阮一峰的网络日志 (ruanyifeng.com) 证书链-Digital Certificates - 简书 (jianshu.com) Java调用https服务报错unable to find valid certification path to requested target的解决方法_wolf的技术博客_51CTO博客 HTTPS加密（握手）过程 - 简书 (jianshu.com) 给面试官上一课：HTTPS是先进行TCP三次握手，再进行TLS四次握手 - 知乎 (zhihu.com) TLS1.3系列文章（2）：TLS1.3协议 - 掘金 (juejin.cn) 一个请求两种握手-TLS握手与TCP握手 - 掘金 (juejin.cn) ","wordCount":"7153","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-09-04T05:50:23.833348945Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/HTTPS.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88.html>综合</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86.html>个人小知识</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C.html>网络</a> <span>></span></ul></nav><h1 class=post-title>HTTPS</h1><div class=post-description></div><div class=post-meta>创建:&nbsp;<span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;更新:&nbsp;2023-09-04&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/%E7%BB%BC%E5%90%88.html>综合</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv>1</span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%bb%8b%e7%bb%8d aria-label=介绍>介绍</a></li><li><a href=#%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86 aria-label=基础知识>基础知识</a><ul><li><a href=#%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86 aria-label=非对称加密>非对称加密</a></li><li><a href=#%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86 aria-label=对称加密>对称加密</a></li><li><a href=#%e8%af%81%e4%b9%a6 aria-label=证书>证书</a></li><li><a href=#ca aria-label=CA>CA</a></li><li><a href=#%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d aria-label=数字签名>数字签名</a></li></ul></li><li><a href=#https%e7%9a%84%e5%8d%8f%e8%ae%ae%e6%a0%88%e5%b1%82%e7%ba%a7 aria-label=HTTPS的协议栈层级>HTTPS的协议栈层级</a></li><li><a href=#https%e4%ba%a4%e4%ba%92%e6%b6%88%e6%81%af aria-label=HTTPS交互消息>HTTPS交互消息</a></li><li><a href=#https%e7%9a%84%e6%8f%a1%e6%89%8b aria-label=HTTPS的握手>HTTPS的握手</a><ul><li><a href=#rsa%e6%8f%a1%e6%89%8b-tls1112 aria-label="RSA握手 (TLS1.1/1.2)">RSA握手 (TLS1.1/1.2)</a></li><li><a href=#dh-%e6%8f%a1%e6%89%8btls12 aria-label="DH 握手(TLS1.2)">DH 握手(TLS1.2)</a></li><li><a href=#tls13-%e6%8f%a1%e6%89%8b aria-label="TLS1.3 握手">TLS1.3 握手</a></li></ul></li><li><a href=#%e8%af%81%e4%b9%a6%e9%93%be aria-label=证书链>证书链</a><ul><li><a href=#ca%e7%bb%84%e7%bb%87 aria-label=CA组织>CA组织</a></li><li><a href=#certificates%e8%af%81%e4%b9%a6 aria-label=certificates(证书)>certificates(证书)</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#qa aria-label=Q&amp;amp;A>Q&amp;A</a><ul><li><a href=#%e4%b8%ad%e9%97%b4%e4%ba%ba%e6%94%bb%e5%87%bb%e6%98%af%e4%bb%80%e4%b9%88 aria-label=中间人攻击是什么>中间人攻击是什么</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93%e6%98%af%e7%94%a8%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86 aria-label=为什么数据传输是用对称加密？>为什么数据传输是用对称加密？</a></li><li><a href=#%e7%94%a8%e4%ba%86-https-%e4%bc%9a%e8%a2%ab%e6%8a%93%e5%8c%85%e5%90%97 aria-label="用了 HTTPS 会被抓包吗？">用了 HTTPS 会被抓包吗？</a></li><li><a href=#https%e5%bf%85%e9%a1%bb%e5%9c%a8%e6%af%8f%e6%ac%a1%e8%af%b7%e6%b1%82%e4%b8%ad%e9%83%bd%e8%a6%81%e5%85%88%e5%9c%a8ssltls%e5%b1%82%e8%bf%9b%e8%a1%8c%e6%8f%a1%e6%89%8b%e4%bc%a0%e8%be%93%e5%af%86%e9%92%a5%e5%90%97 aria-label=HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？>HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h1><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同<a href=https://baike.baidu.com/item/http target=_blank rel=noopener>http</a>
:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。</p><h1 id=基础知识>基础知识<a hidden class=anchor aria-hidden=true href=#基础知识>#</a></h1><h2 id=非对称加密>非对称加密<a hidden class=anchor aria-hidden=true href=#非对称加密>#</a></h2><p>加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 例如：RSA、DSA、ECDSA、 DH、ECDHE。</p><blockquote><p><strong>既可以用公钥加密私钥解密（传输敏感信息场景），也可以用私钥加密公钥解密（用户认证场景）</strong></p></blockquote><p><strong>例如</strong></p><p>非对称加密利用成对的两个秘钥：K1 和 K2。小红用其中一个加密文本，小明可 以用另一个解密文本。比如，小红用 K1 加密，小明用 K2 解密：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>小红 <span style=color:#ff7b72;font-weight:700>:</span> C <span style=color:#ff7b72;font-weight:700>=</span> E(M, K1)
</span></span><span style=display:flex><span>小明 <span style=color:#ff7b72;font-weight:700>:</span> M <span style=color:#ff7b72;font-weight:700>=</span> D(C, K2)
</span></span></code></pre></div><p>这样一来，双方中的一方（比如小红）可以生成 K1和K2，然后把其中一个秘钥 （比如K1）私藏，称为私钥；另一个（比如K2）公开，称为公钥。另一 方（比如小明）得到公钥之后，双方就可以通信。</p><blockquote><p>因为加密和解密的 秘钥值不一样, 所以是不可逆吧</p><p>RSA 算法：该算法的命名以三位科学家的姓氏缩写组合得来，在计算机网络世界，一直是最广为使用的 “非对称加密算法”。</p><p>ECC 是非对称加密里的 “后起之秀”，它基于 “椭圆曲线离散对数” 的数学难题，使用特定的曲线方程和基点生成公钥和私钥，子算法 ECDHE 用于密钥交换，ECDSA 用于数字签名。</p></blockquote><h2 id=对称加密>对称加密<a hidden class=anchor aria-hidden=true href=#对称加密>#</a></h2><p>有流式、分组两种，加密和解密都是使用的同一个密钥。 例如：DES、AES-GCM、ChaCha20-Poly1305等。</p><blockquote><p>因为加密和解密的 秘钥值是一样的, 所以也是可逆</p></blockquote><h2 id=证书>证书<a hidden class=anchor aria-hidden=true href=#证书>#</a></h2><p>证书是用来认证公钥持有者的身份的电子文档，防止第三方进行冒充。一个证书中包含了公钥、持有者信息、证明证书内容有效的签名以及证书有效期，还有一些其他额外信息。操作系统、浏览器本身会预装一些它们信任的根证书，如果其中有该CA机构的根证书，那就可以拿到它对应的可信公钥了。</p><p>实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做<code>信任链</code>或<code>数字证书链</code>，也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。</p><h2 id=ca>CA<a hidden class=anchor aria-hidden=true href=#ca>#</a></h2><p>CA就是签发电子证书的实体。</p><h2 id=数字签名>数字签名<a hidden class=anchor aria-hidden=true href=#数字签名>#</a></h2><p>数字签名技术是将摘要信息用发送者的私钥加密 (CA的私钥)，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。 数字签名是个加密的过程，数字签名验证是个解密的过程。 普通数字签名算法有RSA、ElGamal、Fiat-Shamir、Guillou- Quisquarter、Schnorr、Ong-Schnorr-Shamir数字签名算法、Des/DSA,椭圆曲线数字签名算法和有限自动机数字签名算法等。</p><p>HTTPS使用CA证书的传输方式就是使用了数字签名，非对称加密，对称加密等混合加密技术。</p><blockquote><p>所以上面用私钥加密, 就是用的CA证书的私钥</p></blockquote><p><img loading=lazy src=HTTPS.assets/bg2011080911.png alt=img></p><blockquote><p>CA数字签名的做法:</p><ol><li>小红把自己的公钥和ID（身份证号码，或者域名）合为身份证申请（certificate signing request，CSR），小红把CSR发给一个信任的人小亮。（被称为 certificate authority，CA）</li><li>小亮用自己的私钥加密小红的 CSR，得到的密文被称为数字签名（digital signature）。</li><li>小亮把 signature 和 CSR 的明文合在一起称为 CA签署的身份证（CA signed certificate，CRT），发给小红。</li></ol><p>每当其他人（比如小明）找小红聊天（建立HTTPS连接）的时候，小红出示自己的小亮签署的身份证。 拿到这个身份证的人，只要小明是相信小亮的——在自己机器上安装了小亮的身份证，就可以从小亮的身份证中的CSR里提取小亮的公钥；</p><p>然后用小亮的公钥解密小红的身份证中小亮的signature，得到一个小红的CSR； 如果这个CSR&rsquo;和小红身份证中的CSR明文一致，则说明“这个小红的身份证是小亮确认过并且签名的”。</p></blockquote><h1 id=https的协议栈层级>HTTPS的协议栈层级<a hidden class=anchor aria-hidden=true href=#https的协议栈层级>#</a></h1><p>SSL/TLS协议严格的说位于OSI-7层模型传输层(TCP, UDP)协议之上、应用层之下的会话层。</p><p><img loading=lazy src=HTTPS.assets/56fd6b7030824b62ace82d0cf87866f2tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp alt=20210911103119.png></p><p>如上图所示 HTTPS 相比 HTTP 多了一层 SSL/TLS</p><p>SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><p>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p><blockquote><p>现在不会直接使用SSL协议了, 只是TLS的前身是SSL,且大家习惯了, 所以才会说https的协议是SSL</p></blockquote><p>TLS协议是一个分层协议，本身可以分为上下两层：</p><ul><li>下层为TLS记录层协议（record layer protocal)</li><li>上层为TLS握手层协议（handshake layer protocal)</li></ul><p>TLS协议的组成如下：</p><p><img loading=lazy src=HTTPS.assets/a9f36ba40e9045f980a37fb80c38bd76tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp alt=20210911103135.png></p><h1 id=https交互消息>HTTPS交互消息<a hidden class=anchor aria-hidden=true href=#https交互消息>#</a></h1><p><img loading=lazy src=HTTPS.assets/1620-16681377871045.png alt=img></p><p><strong>说明(四次挥手)：</strong></p><ol><li>浏览器向服务器发送随机数 client_random，TLS 版本和供筛选的加密套件列表。</li><li>服务器接收到，立即返回 服务端随机数server_random，以及双方都支持的加密套件 以及数字证书 (证书中附带公钥 Public key certificate)。</li><li>浏览器接收，先验证数字证书。若通过，接着使用加密套件的密钥协商算法 RSA 算法生成另一个随机数 pre_random，并且用证书里的公钥加密，传给服务器。</li><li>服务器用私钥解密这个被加密后的 pre_random</li></ol><p>现在浏览器和服务器都拥有三样相同的凭证：client_random、server_random 和 pre_random。两者都用筛好的加密套件中的加密方法<strong>混合这三个随机数，生成数据传输的密钥。</strong></p><blockquote><p>所以: <strong>HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段</strong>。</p><p><strong>HTTPS是先进行TCP三次握手，再进行TLS四次握手</strong> , 但如果是TLS1.3版本,可以TCP和TLS握手同时进行, 因为TCP的第三次握手时已经安全,可以携带数据了 (如果是TLS1.3 只需要两次握手)</p><p><a href=https://zhuanlan.zhihu.com/p/399105434 target=_blank rel=noopener>给面试官上一课：HTTPS是先进行TCP三次握手，再进行TLS四次握手 - 知乎 (zhihu.com)</a></p></blockquote><h1 id=https的握手>HTTPS的握手<a hidden class=anchor aria-hidden=true href=#https的握手>#</a></h1><p>TLS 主要的两种握手方式，分别为：RSA 握手、DH 握手。再以 DH 握手 为基础继续演进优化，推出更安全、性能更佳的 TLS1.3 版本握手方式</p><h2 id=rsa握手-tls1112>RSA握手 (TLS1.1/1.2)<a hidden class=anchor aria-hidden=true href=#rsa握手-tls1112>#</a></h2><p><img loading=lazy src=HTTPS.assets/a28591c41cd64dfe8ceac856a9d40fa3tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp alt=img></p><p><strong>具体流程如下：</strong></p><ol><li>浏览器向服务器发送随机数 client_random，TLS 版本和供筛选的加密套件列表。</li><li>服务器接收到，立即返回 server_random，确认好双方都支持的加密套件 以及数字证书 (证书中附带公钥 Public key certificate)。</li><li>浏览器接收，先验证数字证书。若通过，接着使用加密套件的密钥协商算法 RSA 算法生成另一个随机数 pre_random，并且用证书里的公钥加密，传给服务器。</li><li>服务器用私钥解密这个被加密后的 pre_random</li></ol><p>现在浏览器和服务器都拥有三样相同的凭证：client_random、server_random 和 pre_random。两者都用筛好的加密套件中的加密方法混合这三个随机数，生成最终的密钥。最后，浏览器和服务器使用相同的密钥进行通信，即使用 对称加密。</p><h2 id=dh-握手tls12>DH 握手(TLS1.2)<a hidden class=anchor aria-hidden=true href=#dh-握手tls12>#</a></h2><p><img loading=lazy src=HTTPS.assets/5a6eee0152d64fa693667e9e40d96d0btplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp alt=img></p><p><strong>具体流程如下:</strong></p><ol><li>浏览器向服务器发送随机数 client_random，TLS 版本和供筛选的加密套件列表。</li><li>服务器接收到后，确认好双方都支持的加密套件以及数字证书 (证书中附带公钥)。同时服务器利用私钥将 client_random，server_random，server_params 签名，生成服务器签名。然后将签名和 server_params 以及 server_random发送给客户端。 这里的 server_params 为 DH 算法所需参数。</li><li>浏览器接收，先验证数字证书和 <em>签名</em>。若通过，将 client_params 传递给服务器。这里的 client_params 为 DH 算法所需参数。</li><li>现在客户端和服务器都有 client_params、server_params 两个参数，因 <strong>ECDHE 计算基于 “椭圆曲线离散对数”</strong>，通过这两个 DH 参数就能<strong>计算出 pre_random</strong>。</li></ol><blockquote><p>得益于算法机制, 第三个随机数不需要通过网络传输, 安全性更高</p></blockquote><p><strong>DH 密钥交换协议</strong></p><p>DH 密钥交换协议，Diffile-Hellman key Exchange，简称 DH 或 DHE 。它可以让双方在完全没有对方任何预先信息的条件下通过一个不安全的信道创建一个密钥。 k这个秘钥值可以通过不同的参数求证而得</p><p><img loading=lazy src=HTTPS.assets/webp.webp alt=img></p><blockquote><p>其安全性是和RSA是一样的，其安全性依赖于大数因数分解，所以提高安全性只能靠增加位数来保证，这样就涉及大量的乘法运算。性能比较低下。</p><p>为了解决上述DH的问题，引入了ECC椭圆曲线，进而进化为 ECDHE 算法</p></blockquote><h2 id=tls13-握手>TLS1.3 握手<a hidden class=anchor aria-hidden=true href=#tls13-握手>#</a></h2><p>TLS1.3 废除了原有的部分不安全的加密算法，其中甚至包括 RSA 算法。基于ECC(椭圆曲线算法)</p><p>RSA 算法的废除不仅因为已经有大能将其破解，同时还缺少 前向安全性。</p><p><img loading=lazy src=HTTPS.assets/da49387029c240cb8b92e0fbc10e819btplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp alt=img></p><p><strong>流程梳理：</strong></p><ol><li>浏览器向服务器发送 client_params，client_random，TLS 版本和供筛选的加密套件列表。</li><li>服务器返回：server_random、server_params、TLS 版本、确定的加密套件方法以及证书。浏览器接收，先验证数字证书和签名。现在双方都有 client_params、server_params，可以根据 ECDHE 计算出 pre_random 了。</li></ol><p>最后，集齐三个参数，生成最终秘钥。</p><p>如你所见，TLS1.3 客户端和服务器之间只需要一次往返就完成 (TLS1.2 需要两次往返来完成握手)，即 1-RTT 握手。</p><blockquote><p>RTT : Round-Trip Time &ndash; 往返延时, 表示从发送端发送数据开始，到发送端收到来自接收端的确认</p><p><a href=https://blog.csdn.net/qq_38890412/article/details/106663674 target=_blank rel=noopener>—RTT（Round-Trip Time）_越来越胖的GuanRunwei的博客-CSDN博客</a></p></blockquote><blockquote><p>前向安全性: 指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。前向安全能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁</p><p>RSA 没有向前安全性，也就是需要每次的对称加密密钥的传递都是基于 公钥加密，服务端私钥解密。如果服务端的私钥丢失了，那几年前的通信数据都有可能被解密。所以这是极度不安全的，私钥的地位太重了，如果每次的加解密都是临时生成的密码来解决安全性，才不会对私钥的安全性有如此强的依赖。</p></blockquote><p><a href=https://www.jianshu.com/p/39cd9d1ac5ee target=_blank rel=noopener>TLS过程（DH 非对称加密） - 简书 (jianshu.com)</a></p><p><a href=https://juejin.cn/post/6895624327896432654#heading-8 target=_blank rel=noopener>TLS 详解握手流程 - 掘金 (juejin.cn)</a></p><h1 id=证书链>证书链<a hidden class=anchor aria-hidden=true href=#证书链>#</a></h1><p>在Chrome上随便打开一个https的网站 <a href=https://fmall.gree.com/distributionh5 target=_blank rel=noopener>https://fmall.gree.com/distributionh5</a>
，我们会发现在地址栏的左侧有个绿色的小锁，点击这个小锁，然后就可以查看这个网站的证书信息。查看证书信息如下：</p><p><img loading=lazy src=HTTPS.assets/image-20221111141934301.png alt=image-20221111141934301></p><p>除了HTTPS使用的 gree.com 证书，向上还有两级证书，证书有3类：</p><ol><li>end-user ：gree.com 包含用来加密传输数据的公钥的证书，是HTTPS中使用的证书</li><li>intermediates：CA用来认证公钥持有者身份的证书，即确认HTTPS使用的end-user证书是属于gree.com的证书。这类intermediates证书甚至可以有很多级。</li><li>root：用来认证intermediates证书是合法证书的证书。</li></ol><p>简单来说，end-user证书上面几级证书都是为了保证end-user证书未被篡改，保证是CA签发的合法证书，进而保证end-user证书中的公钥未被篡改。</p><h2 id=ca组织>CA组织<a hidden class=anchor aria-hidden=true href=#ca组织>#</a></h2><p>除了end-user之外，证书被分为root Certificates和intermediates Certificates。相应地，CA也分了两种类型：root CAs 和 intermediates CAs。首先，CA的组织结构是一个树结构，一个root CAs下面包含多个intermediates CAs，而intermediates又可以包含多个intermediates CAs。root CAs 和 intermediates CAs都可以颁发证书给用户，颁发的证书分别是root Certificates和intermediates Certificates，最终用户用来认证公钥的证书则被称为end-user Certificates。</p><p><img loading=lazy src=HTTPS.assets/webp.webp alt=img></p><blockquote><p>因为证书有 root 和 intermediates两种, 所以CA组织也有两种, 而且intermediates间也可以颁发</p></blockquote><h2 id=certificates证书>certificates(证书)<a hidden class=anchor aria-hidden=true href=#certificates证书>#</a></h2><p>我们使用end-user certificates来确保加密传输数据的公钥(public key)不被篡改，而又如何确保end-user certificates的合法性呢？这个认证过程跟公钥的认证过程类似，首先获取颁布end-user certificates的CA的证书，然后验证end-user certificates的signature。</p><p>就是套娃一样, 用end-user要保证数据安全, 用intermediate是来保证end-user的安全, 用root来保证intermediates的安全, 这样就<strong>形成了证书链</strong></p><p>一般来说，root CAs不会直接颁布end-user certificates的，而是授权给多个二级CA，而二级CA又可以授权给多个三级CA，这些中间的CA就是intermediates CAs，它们才会颁布end-user certificates。</p><blockquote><p>为什么需要证书链这么麻烦的流程？</p><p>Root CA为什么不直接版本证书，而是要搞那么多中间层级呢？找了一下，godaddy官方给了一个答案，为了确保root certificates的绝对安全性，https://sg.godaddy.com/en/help/what-is-an-intermediate-certificate-868 ，将根证书隔离地越严格越好。有点像设计模式中的最少知道原则</p></blockquote><p>了解了这个证书体系之后，才明白为什么百度/google这种公司也需要向第三方购买签名证书了，自签root证书推广起来非常困难，这也导致目前的证书市场基本上被 <strong>Symantec(VeriSign/GeoTrust) / Comodo / GoDaddy</strong> 垄断。百度使用的是Versign，google使用的是GeoTrust。目前HTTPS的推广已经不可避免，也已经有一些公益组织开始提供免费、自动化、开放的证书签发服务，例如：Let&rsquo;s Encrypt 。详细使用可以参考 <a href=https://letsencrypt.org/zh-cn/getting-started/ target=_blank rel=noopener>入门指南 - Let&rsquo;s Encrypt - 免费的SSL/TLS证书 (letsencrypt.org)</a></p><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><p><img loading=lazy src=HTTPS.assets/image-20221111105036796.png alt=image-20221111105036796></p><h1 id=qa>Q&amp;A<a hidden class=anchor aria-hidden=true href=#qa>#</a></h1><h2 id=中间人攻击是什么>中间人攻击是什么<a hidden class=anchor aria-hidden=true href=#中间人攻击是什么>#</a></h2><p>CA颁发证书就是解决了中间人攻击.</p><p>假设没有CA证书, 客户端和服务端直接连接交互,流程如下:</p><ol><li>服务器为每个客户端生成一个公钥，将公钥发送给客户端；</li><li>客户端选择一个加密算法，然后用公钥加密以后发送给服务器；</li><li>服务器收到这个公钥加密后的算法以后拿自己的私钥解密，然后就知道这个加密算法是哪个了。今后就一直用这个算法通信；</li></ol><p>但如果有人, 在客户端和服务端做个拦截, 所有的交互都经过中间人, 从第一步开始就冒充了服务端, 把中间人的公钥给客户端, 这样中间人就可以代替服务端与客户端交互, 或者篡改数据后转发给服务端, 这就是中间人攻击</p><p><img loading=lazy src=HTTPS.assets/1620-16681467201458.png alt=img></p><h2 id=为什么数据传输是用对称加密>为什么数据传输是用对称加密？<a hidden class=anchor aria-hidden=true href=#为什么数据传输是用对称加密>#</a></h2><p>首先：非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。</p><h2 id=用了-https-会被抓包吗>用了 HTTPS 会被抓包吗？<a hidden class=anchor aria-hidden=true href=#用了-https-会被抓包吗>#</a></h2><p>HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，<strong>无法直接查看</strong>。</p><p>但是，正如前文所说，浏览器只会提示安全风险，如果用户授权仍然可以继续访问网站，完成请求。因此，只要客户端是我们自己的终端，我们<strong>授权的情况下，便可以组建中间人网络</strong>，而抓包工具便是作为中间人的代理。通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。</p><p>既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？</p><p>HTTPS 可以防止用户在不知情的情况下通信链路被监听，对于主动授信的抓包操作是不提供防护的，因为这个场景用户是已经对风险知情。要防止被抓包，需要采用应用级的安全防护，例如采用私有的对称加密，同时做好移动端的防反编译加固，防止本地算法被破解。</p><h2 id=https必须在每次请求中都要先在ssltls层进行握手传输密钥吗>HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？<a hidden class=anchor aria-hidden=true href=#https必须在每次请求中都要先在ssltls层进行握手传输密钥吗>#</a></h2><p>这也是我当时的困惑之一，显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？靠“<strong>session</strong>”。</p><p>服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！</p><p><a href=https://cloud.tencent.com/developer/article/1425339 target=_blank rel=noopener>HTTPS协议原理和流程分析 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href=https://zhuanlan.zhihu.com/p/96494976 target=_blank rel=noopener>你知道，HTTPS用的是对称加密还是非对称加密？ - 知乎 (zhihu.com)</a></p><p><a href=https://www.cnblogs.com/lfri/p/12593232.html target=_blank rel=noopener>HTTPS用的是对称加密还是非对称加密？ - Rogn - 博客园 (cnblogs.com)</a></p><p><a href=http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html target=_blank rel=noopener>数字签名是什么？ - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p><a href=https://www.jianshu.com/p/46e48bc517d0 target=_blank rel=noopener>证书链-Digital Certificates - 简书 (jianshu.com)</a></p><p><a href=https://blog.51cto.com/huangwq/1859536 target=_blank rel=noopener>Java调用https服务报错unable to find valid certification path to requested target的解决方法_wolf的技术博客_51CTO博客</a></p><p><a href=https://www.jianshu.com/p/e30a8c4fa329 target=_blank rel=noopener>HTTPS加密（握手）过程 - 简书 (jianshu.com)</a></p><p><a href=https://zhuanlan.zhihu.com/p/399105434 target=_blank rel=noopener>给面试官上一课：HTTPS是先进行TCP三次握手，再进行TLS四次握手 - 知乎 (zhihu.com)</a></p><p><a href=https://juejin.cn/post/7127674744408653838 target=_blank rel=noopener>TLS1.3系列文章（2）：TLS1.3协议 - 掘金 (juejin.cn)</a></p><p><a href=https://juejin.cn/post/7089594675111133192#heading-6 target=_blank rel=noopener>一个请求两种握手-TLS握手与TCP握手 - 掘金 (juejin.cn)</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/%E7%BD%91%E7%BB%9C.html>网络</a></li><li><a href=https://xiaokunji.com/zh/tags/%E7%BB%BC%E5%90%88.html>综合</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/http.html><span class=title>« 上一页</span><br><span>http</span></a>
<a class=next href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E6%9D%82%E9%A1%B9/IaaSPaaSSaaSCaaS.html><span class=title>下一页 »</span><br><span>IaaS，PaaS，SaaS，CaaS</span></a></nav></footer></article></main><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>