<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>http | 米二</title><meta name=keywords content=" http 2.0 新特性, HTTP协议的Keep-Alive , 强缓存和协商缓存, HTTP Cache, 强缓存, expires, cache-control, pragma, 协商缓存, last-modified, ETag (EntityTags), 案例分析, http3, 预检请求"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/http.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/http.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="http"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/http.html"><meta property="article:section" content="综合"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-29T15:14:09+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="http"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"http","item":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/http.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"http","name":"http","description":"     ","keywords":[" http 2.0 新特性"," HTTP协议的Keep-Alive "," 强缓存和协商缓存"," HTTP Cache"," 强缓存"," expires"," cache-control"," pragma"," 协商缓存"," last-modified"," ETag (EntityTags)"," 案例分析"," http3"," 预检请求"],"articleBody":"[toc]\nhttp 2.0 新特性 二进制分帧\n在应用层(HTTP2.0)和传输层(TCP、UDP)新增的二进制分帧层。在这层中,数据会被分割成更小的消息和帧,然后可以无序发,最后组装就行\nhead压缩\n多路复用\n做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。\n因为请求都在同一个tcp连接上完成\n服务器推送\n服务器可以对一个客户端请求发送多个响应,之前是一个请求一个响应\n实现原理大致: 客户端发送一次请求,服务端的请求并不会关闭,发完第一次,接着发第二次\n目前NGINX的V1.13.9和tomcat已经支持,后端也能实现\n关键字是link\n服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。\n一种解决办法是，只对第一次访问的用户开启服务器推送。\n来源: 服务器推送实现 http2.0新特性 http各版本之间的区别 HTTP协议的Keep-Alive 可以看到里面的请求头部和响应头部都有一个key-valueConnection: Keep-Alive，这个键值对的作用是让HTTP保持连接状态(就是俗称的长链接)，因为HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP 协议为无连接的协议）；当使用 Keep-Alive 模式时，Keep-Alive 功能使客户端到服务器端的连接持续有效。\n在HTTP 1.1版本后，默认都开启Keep-Alive模式，只有加入加入 Connection: close才关闭连接，当然也可以设置Keep-Alive模式的属性，例如 Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。\nKeep-Alive模式下如何知道某一次数据传输结束\n如果不是Keep-Alive模式，HTTP协议中客户端发送一个请求，服务器响应其请求，返回数据。服务器通常在发送回所请求的数据之后就关闭连接。这样客户端读数据时会返回EOF（-1），就知道数据已经接收完全了。 但是如果开启了 Keep-Alive模式，那么客户端如何知道某一次的响应结束了呢？\n以下有两个方法\n如果是静态的响应数据，可以通过判断响应头部中的Content-Length 字段，判断数据达到这个大小就知道数据传输结束了。 但是返回的数据是动态变化的，服务器不能第一时间知道数据长度，这样就没有 Content-Length 关键字了。这种情况下，服务器是分块传输数据的，Transfer-Encoding：chunk，这时候就要根据传输的数据块chunk来判断，数据传输结束的时候，最后的一个数据块chunk的长度是0。 使用HTTP建立长连接\n当需要建立 HTTP 长连接时，HTTP 请求头将包含如下内容：\nConnection: Keep-Alive\n如果服务端同意建立长连接，HTTP 响应头也将包含如下内容：\nConnection: Keep-Alive\n当需要关闭连接时，HTTP 头中会包含如下内容：\nConnection: Close\n慢速攻击：Http协议中规定，HttpRequest以\n结尾来表示客户端发送结束。攻击者打开一个Http 1.1的连接，将Connection设置为Keep-Alive， 保持和服务器的TCP长连接。然后始终不发送\n， 每隔几分钟写入一些无意义的数据流， 拖死机器。\ncc攻击 来源地址 强缓存和协商缓存 这里的服务器值是 资源服务器, 例如 NG\n当我们向服务器请求资源后，会根据情况将资源 copy 一份副本存在本地，以方便下次读取。它与本地存储 localStorage 、cookie 等不同，本地存储更多是数据记录，存储量较小，为了本地操作方便。而缓存更多是为了减少资源请求，多用于存储文件，存储量相对较大。\n就浏览器而言，一般缓存我们分为四类，按浏览器读取优先级顺序依次为：Memory Cache、Service Worker Cache、HTTP Cache、Push Cache。而本篇文章主要讲的就是 HTTP Cache HTTP Cache HTTP Cache 是我们开发中接触最多的缓存，它分为强缓存和协商缓存。优先级: 强缓存 \u003e 协商缓存\n强缓存：直接从本地副本比对读取，不去请求服务器，返回的状态码是 200。\n协商缓存：会去服务器比对，若没改变才直接读取本地缓存，返回的状态码是 304。\n因为需要问 服务器 看资源是否过期, 所以叫协商缓存\n强缓存 强缓存主要包括 expires 和 cache-control。\nexpires expires 是 HTTP1.0 中定义的缓存字段。当我们请求一个资源，服务器返回时，可以在 Response Headers 中增加 expires 字段表示资源的过期时间。它是一个时间戳（准确点应该叫格林尼治时间），当客户端再次请求该资源的时候，会把客户端时间与该时间戳进行对比，如果大于该时间戳则已过期，否则直接使用该缓存资源。\n例如: expires: Thu, 03 Jan 2019 11:43:04 GMT\n但是，发送请求时是使用的客户端时间去对比。所以存在以下两个问题\n客户端和服务端时间可能快慢不一致 客户端的时间是可以自行修改的（比如浏览器是跟随系统时间的，修改系统时间会影响到），所以不一定满足预期。 cache-control 正由于上面说的可能存在的问题，HTTP1.1 新增了 cache-control 字段来解决该问题，所以当 cache-control 和 expires 都存在时，cache-control 优先级更高。该字段是一个时间长度，单位秒，表示该资源过了多少秒后失效。当客户端请求资源的时候，发现该资源还在有效时间内则使用该缓存，它不依赖客户端时间。\ncache-control 主要有 max-age 和 s-maxage、public 和 private、no-cache 和 no-store 等值。例如: cache-control: public, max-age=3600, s-maxage=3600\n属性值 值 备注 max-age 3600 例如值为3600，表示（当前时间+3600秒）内不与服务器请求新的数据资源, s-maxage 和max-age一样且优先级更高，在代理服务器中仍生效 private 内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存) public 所有内容都将被缓存(客户端和代理服务器都可缓存) no-store 不缓存任何数据, 直接向服务器请求最新 no-cache 表示的是不直接询问浏览器缓存情况，而是去向服务器验证当前资源是否更新（即走协商缓存） pragma 既然讲到了 no-cache 和 no-store，就顺便把 pragma 也讲了。他的值有 no-cache 和 no-store，表示意思同 cache-control，优先级高于 cache-control 和 expires，即三者同时出现时，先看 pragma -\u003e cache-control -\u003e expires。\npragma: no-cache\n那时候Cache-control（http1.1）还没出\n协商缓存 上面的 expires 和 cache-control 都会访问本地缓存直接验证看是否过期，如果没过期直接使用本地缓存，并返回 200。但如果设置了 no-cache 和 no-store 则本地缓存会被忽略，会去请求服务器验证资源是否更新，如果没更新才继续使用本地缓存，此时返回的是 304，这就是协商缓存。协商缓存主要包括last-modified和 etag。\n客户端携带上一次的 last-modified和 etag 值到服务端, 服务端进行比较这个两个值是否发生变化, 如果不携带,则默认为要获取新值\nif-modified-since 存上次访问返回的 last-modified 值\nif-none-match 存上次访问返回的 etag 值\nNGINX 默认是开启Etag和 last-modified 的, 所以es中自定义分词列表的热更新能力就是通过这两个字段实现的\nlast-modified last-modified 记录资源最后修改的时间。启用后，请求资源之后的响应头会增加一个 last-modified 字段，如下：\n例如: last-modified: Thu, 20 Dec 2018 11:36:00 GMT\n当再次请求该资源时，请求头中会带有 if-modified-since字段，值是之前返回的 last-modified 的值，如：if-modified-since:Thu, 20 Dec 2018 11:36:00 GMT。服务端会对比该字段和资源的最后修改时间，若一致则证明没有被修改，告知浏览器可直接使用缓存并返回 304；若不一致则直接返回修改后的资源，并修改 last-modified 为新的值。\n但 last-modified 有以下两个问题：\n只要编辑了，不管内容是否真的有改变，都会以这最后修改的时间作为判断依据，当成新资源返回，从而导致了没必要的请求响应 时间的精确度只能到秒，如果在一秒内的修改是检测不到更新的，仍会告知浏览器使用旧的缓存。 ETag (EntityTags) 为了解决last-modified 上述问题，有了 etag。 etag 会基于资源的内容编码生成一串唯一的标识字符串，只要内容不同，就会生成不同的 etag。启用 etag 之后，请求资源后的响应返回会增加一个 etag 字段，如下： etag: \"FllOiaIvA1f-ftHGziLgMIMVkVw_\"\n当再次请求该资源时，请求头会带有 if-none-match 字段，值是之前返回的 etag 值，如：if-none-match:\"FllOiaIvA1f-ftHGziLgMIMVkVw_\"。服务端会根据该资源当前的内容生成对应的标识字符串和该字段进行对比，若一致则代表未改变可直接使用本地缓存并返回 304；若不一致则返回新的资源（状态码200）并修改返回的 etag 字段为新的值。\n可以看出 etag 比 last-modified 更加精准地感知了变化，所以 etag 优先级也更高。不过从上面也可以看出 etag 存在的问题，就是每次生成标识字符串会增加服务器的开销。\n弱etag\nETag: W/\"630c1e6c-3485\" 在商城中看到的是带了W/的, 这表示弱校验 , 全称是 weak, 强校验是字节级别的, 弱校验是语义级别的\n在Apache服务器中 Apache默认通过FileEtag中FileEtag | Node Mtime Size的配置自动生成ETag (节点/修改时间/文件大小 三个因素), 如果文件在一秒内频繁修改,并不改内容, 且etag的生成规则改为 Mtime, 则etag在这一秒内的都是一样的, 此种情况下可以通过 弱etag 来减少刷新缓存 (毕竟强etag是全局唯一的)\netag 的生成规则 http并没有定义 , 因此具体的etag生成逻辑由服务端实现\n一文讲透HTTP缓存之ETag - 掘金 (juejin.cn) HTTP 条件请求 - HTTP |MDN (mozilla.org) 案例分析 假设当前有这么一个 index 页面，返回的响应信息如下：\ncache-control: max-age=72000 expires: Tue, 20 Nov 2018 20:41:14 GMT last-modified: Tue, 20 Nov 2018 00:41:14 GMT 标签进入、输入url回车进入\n这种情况下会根据实际设计的缓存策略去判断。\n由于该例没有设置 no-cache 和 no-store，所以默认先走强缓存路线。根据 cache-control （expires 优先级低）判断缓存是否过期，若没有过期则此时返回 200(from cache)。 若本地缓存已经过期再走协商缓存路线，根据之前的 last-modified 值去与服务器比对，若这个时间之后没有改过则去读取本地缓存，返回 304(not modified)。 否则返回新的资源，状态码 200(ok)，并更新返回响应的 last-modified 值。 按刷新按钮、F5 刷新、网页右键“重新加载”\n不使用强缓存,直接使用 协商缓存\nctrl + F5 强制刷新\n强缓存和协商缓存都不走, 直接获取最新资源\nHTTP中的强缓存与协商缓存 - 漫思 - 博客园 (cnblogs.com) 强缓存和协商缓存 - 简书 (jianshu.com) http3 HTTP3基于UDP协议重新定义了连接，在QUIC层实现了无序、并发字节流的传输，解决了队头阻塞问题（包括基于QPACK解决了动态表的队头阻塞）； HTTP3重新定义了TLS协议加密QUIC(Quick UDP Internet Connection)头部的方式，既提高了网络攻击成本，又降低了建立连接的速度（仅需1个RTT就可以同时完成建链与密钥协商）； HTTP3 将Packet、QUIC Frame、HTTP3 Frame分离，实现了连接迁移功能，降低了5G环境下高速移动设备的连接维护成本。 基于TCP实现的HTTP2遗留下3个问题：\n有序字节流引出的队头阻塞（Head-of-line blocking），使得HTTP2的多路复用能力大打折扣； TCP与TLS叠加了握手时延，建链时长还有1倍的下降空间； 基于TCP四元组确定一个连接，这种诞生于有线网络的设计，并不适合移动状态下的无线网络，这意味着IP地址的频繁变动会导致TCP连接、TLS会话反复握手，成本高昂。 预检请求 发生跨域请求时, 浏览器不知道当前请求是否被服务端允许, 所以需要发送一个请求去验证一下, 此为预检请求.(浏览器自动发起)\n预检请求长什么样?\n可以看到有两个一样的请求, post请求是我们正常的业务请求, 而options就是预检请求, 但预检请求是不带body,也不会修改服务器的资源,也不会返回响应体.\n什么时候会发生预检请求?\n发生了跨域请求\n协议 + 域名 + 端口 组成源, 当 起始源和目标源 不同时认为是跨域请求\n该请求是非简单请求\n浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n只要同时满足以下两大条件，就属于简单请求。\n请求方法是以下三种方法之一： HEAD GET POST HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 也就\n我们常用的业务接口, 一般是json格式传参, 或者加了自定义的请求头参数, 也就是说这些接口都是非简单请求\n预检缓存过期或者禁止了缓存 (浏览器控制台上可以禁用缓存)\n详解\n非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。预请求实际上是对服务端的一种权限请求\n请求头\n“预检\"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，\n关键字段是Origin，表示请求来自哪个源。\nAccess-Control-Request-Method: 用来列出浏览器的CORS请求会用到哪些HTTP方法\nAccess-Control-Request-Headers: 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，例如X-Custom-Header,authorization,saas-auth\n响应头\nAccess-Control-Allow-Origin: 表示允许的来源, * 表示允许任意来源\nAccess-Control-Allow-Methods: 它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法(这样可以避免多次\"预检\"请求。)\nAccess-Control-Allow-Headers: 它是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段\nAccess-Control-Max-Age: 该字段可选，用来指定本次预检请求的有效期，单位为秒。\n预检请求 OPTIONS - 知乎 (zhihu.com) http CORS options请求（预检请求）详解 - 知乎 (zhihu.com) 5分钟看懂HTTP3_文化 \u0026 方法_Mehdi Zed_InfoQ精选文章 http3.0初体验 - 掘金 (juejin.cn) HTTP协议-HTTP3 - 简书 (jianshu.com) 深入剖析HTTP3协议 - 知乎 (zhihu.com) HTTP3.0和QUIC协议那些事 - 思创斯聊编程 (ispacesoft.com) ","wordCount":"5620","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-08-29T15:14:09.422413011Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/http.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search.html title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88.html>综合</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86.html>个人小知识</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C.html>网络</a> <span>></span></ul></nav><h1 class=post-title>http</h1><div class=post-description></div><div class=post-meta><span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;12 分钟&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/%E7%BB%BC%E5%90%88.html>综合</a></ul><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#http-20-%e6%96%b0%e7%89%b9%e6%80%a7 aria-label="http 2.0 新特性">http 2.0 新特性</a></li><li><a href=#http%e5%8d%8f%e8%ae%ae%e7%9a%84keep-alive aria-label=HTTP协议的Keep-Alive>HTTP协议的Keep-Alive</a></li><li><a href=#%e5%bc%ba%e7%bc%93%e5%ad%98%e5%92%8c%e5%8d%8f%e5%95%86%e7%bc%93%e5%ad%98 aria-label=强缓存和协商缓存>强缓存和协商缓存</a><ul><li><a href=#http-cache aria-label="HTTP Cache">HTTP Cache</a><ul><li><a href=#%e5%bc%ba%e7%bc%93%e5%ad%98 aria-label=强缓存>强缓存</a><ul><li><a href=#expires aria-label=expires>expires</a></li><li><a href=#cache-control aria-label=cache-control>cache-control</a></li><li><a href=#pragma aria-label=pragma>pragma</a></li></ul></li><li><a href=#%e5%8d%8f%e5%95%86%e7%bc%93%e5%ad%98 aria-label=协商缓存>协商缓存</a><ul><li><a href=#last-modified aria-label=last-modified>last-modified</a></li><li><a href=#etag-entitytags aria-label="ETag (EntityTags)">ETag (EntityTags)</a></li></ul></li></ul></li><li><a href=#%e6%a1%88%e4%be%8b%e5%88%86%e6%9e%90 aria-label=案例分析>案例分析</a></li></ul></li><li><a href=#http3 aria-label=http3>http3</a></li><li><a href=#%e9%a2%84%e6%a3%80%e8%af%b7%e6%b1%82 aria-label=预检请求>预检请求</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=http-20-新特性>http 2.0 新特性<a hidden class=anchor aria-hidden=true href=#http-20-新特性>#</a></h1><ol><li><p>二进制分帧</p><blockquote><p>在应用层(HTTP2.0)和传输层(TCP、UDP)新增的二进制分帧层。在这层中,数据会被分割成更小的消息和帧,然后可以无序发,最后组装就行</p></blockquote></li><li><p>head压缩</p></li><li><p>多路复用</p><blockquote><p>做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p><p>因为请求都在同一个tcp连接上完成</p></blockquote></li><li><p>服务器推送</p><blockquote><p>服务器可以对一个客户端请求发送多个响应,之前是一个请求一个响应</p><p><strong>实现原理大致</strong>: 客户端发送一次请求,服务端的请求并不会关闭,发完第一次,接着发第二次</p><p><u>目前NGINX的V1.13.9和tomcat已经支持,后端也能实现</u></p><p>关键字是<code>link</code></p><p>服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。</p><p>一种解决办法是，只对第一次访问的用户开启服务器推送。</p></blockquote></li></ol><blockquote><p>来源: <a href=https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html target=_blank rel=noopener>服务器推送实现</a></p><p><a href=https://www.jianshu.com/p/c90e458a26b2 target=_blank rel=noopener>http2.0新特性</a></p><p><a href=https://blog.csdn.net/weixin_48502062/article/details/108330192 target=_blank rel=noopener>http各版本之间的区别</a></p></blockquote><h1 id=http协议的keep-alive>HTTP协议的Keep-Alive<a hidden class=anchor aria-hidden=true href=#http协议的keep-alive>#</a></h1><p>可以看到里面的请求头部和响应头部都有一个key-value<code>Connection: Keep-Alive</code>，<strong>这个键值对的作用是让HTTP保持连接状态(就是俗称的长链接)</strong>，因为HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP 协议为无连接的协议）；当使用 Keep-Alive 模式时，Keep-Alive 功能使客户端到服务器端的连接持续有效。</p><p>在HTTP 1.1版本后，默认都开启Keep-Alive模式，只有加入加入 <code>Connection: close</code>才关闭连接，当然也可以设置Keep-Alive模式的属性，例如 <code>Keep-Alive: timeout=5, max=100</code>，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。</p><p><strong>Keep-Alive模式下如何知道某一次数据传输结束</strong></p><p>如果不是Keep-Alive模式，HTTP协议中客户端发送一个请求，服务器响应其请求，返回数据。服务器通常在发送回所请求的数据之后就关闭连接。这样客户端读数据时会返回EOF（-1），就知道数据已经接收完全了。
但是如果开启了 Keep-Alive模式，那么客户端如何知道某一次的响应结束了呢？</p><p><strong>以下有两个方法</strong></p><ul><li>如果是静态的响应数据，可以通过判断响应头部中的Content-Length 字段，判断数据达到这个大小就知道数据传输结束了。</li><li>但是返回的数据是动态变化的，服务器不能第一时间知道数据长度，这样就没有 Content-Length 关键字了。这种情况下，服务器是分块传输数据的，<code>Transfer-Encoding：chunk</code>，这时候就要根据传输的数据块chunk来判断，数据传输结束的时候，最后的一个数据块chunk的长度是0。</li></ul><p><strong>使用HTTP建立长连接</strong></p><p>当需要建立 HTTP 长连接时，HTTP 请求头将包含如下内容：</p><p><code>Connection: Keep-Alive</code></p><p>如果服务端同意建立长连接，HTTP 响应头也将包含如下内容：</p><p><code>Connection: Keep-Alive</code></p><p>当需要关闭连接时，HTTP 头中会包含如下内容：</p><p><code>Connection: Close</code></p><blockquote><p><strong>慢速攻击</strong>：Http协议中规定，HttpRequest以</p></blockquote><p>结尾来表示客户端发送结束。攻击者打开一个Http 1.1的连接，将Connection设置为Keep-Alive， 保持和服务器的TCP长连接。然后始终不发送</p><p>， 每隔几分钟写入一些无意义的数据流， 拖死机器。</p><blockquote><p><a href="https://www.cnblogs.com/sochishun/p/7081739.html#:~:text=CC%E6%94%BB%E5%87%BB%EF%BC%88Challenge,Collapsar%EF%BC%89%E6%98%AFDDOS%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%EF%BC%89%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%8C%E5%89%8D%E8%BA%AB%E5%90%8D%E4%B8%BAFatboy%E6%94%BB%E5%87%BB%EF%BC%8C%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%AB%99%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E3%80%82" target=_blank rel=noopener>cc攻击</a></p></blockquote><p><a href=https://www.jianshu.com/p/49551bda6619 target=_blank rel=noopener>来源地址</a></p><h1 id=强缓存和协商缓存>强缓存和协商缓存<a hidden class=anchor aria-hidden=true href=#强缓存和协商缓存>#</a></h1><blockquote><p>这里的服务器值是 资源服务器, 例如 NG</p></blockquote><p>当我们向服务器请求资源后，会根据情况将资源 copy 一份副本存在本地，以方便下次读取。它与本地存储 localStorage 、cookie 等不同，本地存储更多是数据记录，存储量较小，为了本地操作方便。而缓存更多是为了减少资源请求，多用于存储文件，存储量相对较大。</p><p>就浏览器而言，一般缓存我们分为四类，按浏览器读取优先级顺序依次为：<code>Memory Cache</code>、<code>Service Worker Cache</code>、<code>HTTP Cache</code>、<code>Push Cache</code>。而本篇文章主要讲的就是 <code>HTTP Cache</code></p><h2 id=http-cache>HTTP Cache<a hidden class=anchor aria-hidden=true href=#http-cache>#</a></h2><p>HTTP Cache 是我们开发中接触最多的缓存，它分为强缓存和协商缓存。<strong>优先级: 强缓存 > 协商缓存</strong></p><ul><li><p>强缓存：直接从本地副本比对读取，不去请求服务器，返回的状态码是 200。</p></li><li><p>协商缓存：<strong>会去服务器比对</strong>，若没改变才直接读取本地缓存，返回的状态码是 304。</p><blockquote><p>因为需要问 服务器 看资源是否过期, 所以叫协商缓存</p></blockquote></li></ul><h3 id=强缓存>强缓存<a hidden class=anchor aria-hidden=true href=#强缓存>#</a></h3><p>强缓存主要包括 <code>expires</code> 和 <code>cache-control</code>。</p><h4 id=expires>expires<a hidden class=anchor aria-hidden=true href=#expires>#</a></h4><p>expires 是 HTTP1.0 中定义的缓存字段。当我们请求一个资源，服务器返回时，可以在 Response Headers 中增加 expires 字段表示资源的过期时间。它是一个时间戳（准确点应该叫格林尼治时间），当客户端再次请求该资源的时候，会把客户端时间与该时间戳进行对比，如果大于该时间戳则已过期，否则直接使用该缓存资源。</p><p>例如: <code>expires: Thu, 03 Jan 2019 11:43:04 GMT</code></p><p>但是，发送请求时是使用的客户端时间去对比。所以存在以下两个问题</p><ol><li>客户端和服务端时间可能快慢不一致</li><li>客户端的时间是可以自行修改的（比如浏览器是跟随系统时间的，修改系统时间会影响到），所以不一定满足预期。</li></ol><h4 id=cache-control>cache-control<a hidden class=anchor aria-hidden=true href=#cache-control>#</a></h4><p>正由于上面说的可能存在的问题，HTTP1.1 新增了 <code>cache-control</code> 字段来解决该问题，所以当 cache-control 和 expires 都存在时，<strong>cache-control 优先级更高</strong>。该字段是一个时间长度，单位秒，<strong>表示该资源过了多少秒后失效</strong>。当客户端请求资源的时候，发现该资源还在有效时间内则使用该缓存，它<strong>不依赖客户端时间</strong>。</p><p>cache-control 主要有 max-age 和 s-maxage、public 和 private、no-cache 和 no-store 等值。例如: <code>cache-control: public, max-age=3600, s-maxage=3600</code></p><table><thead><tr><th>属性值</th><th>值</th><th>备注</th></tr></thead><tbody><tr><td>max-age</td><td>3600</td><td>例如值为3600，表示（当前时间+3600秒）内不与服务器请求新的数据资源,</td></tr><tr><td>s-maxage</td><td></td><td>和max-age一样且优先级更高，在代理服务器中仍生效</td></tr><tr><td>private</td><td></td><td>内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)</td></tr><tr><td>public</td><td></td><td>所有内容都将被缓存(客户端和代理服务器都可缓存)</td></tr><tr><td>no-store</td><td></td><td>不缓存任何数据, 直接向服务器请求最新</td></tr><tr><td>no-cache</td><td></td><td>表示的是不直接询问浏览器缓存情况，而是去向服务器验证当前资源是否更新（即走协商缓存）</td></tr></tbody></table><h4 id=pragma>pragma<a hidden class=anchor aria-hidden=true href=#pragma>#</a></h4><p>既然讲到了 no-cache 和 no-store，就顺便把 pragma 也讲了。他的值有 no-cache 和 no-store，表示意思同 cache-control，优先级高于 cache-control 和 expires，即三者同时出现时，先看 <code>pragma -> cache-control -> expires</code>。</p><p><code>pragma: no-cache</code></p><blockquote><p>那时候<code>Cache-control</code>（http1.1）还没出</p></blockquote><h3 id=协商缓存>协商缓存<a hidden class=anchor aria-hidden=true href=#协商缓存>#</a></h3><p>上面的 expires 和 cache-control 都会访问本地缓存直接验证看是否过期，如果没过期直接使用本地缓存，并返回 200。但如果设置了 no-cache 和 no-store 则本地缓存会被忽略，会去请求服务器验证资源是否更新，如果没更新才继续使用本地缓存，此时返回的是 304，这就是协商缓存。协商缓存主要包括<code>last-modified</code>和 <code>etag</code>。</p><blockquote><p>客户端携带上一次的 <code>last-modified</code>和 <code>etag</code> 值到服务端, 服务端进行比较这个两个值是否发生变化, 如果不携带,则默认为要获取新值</p><p><code>if-modified-since</code> 存上次访问返回的<code> last-modified</code> 值</p><p><code>if-none-match</code> 存上次访问返回的 <code>etag</code> 值</p></blockquote><blockquote><p>NGINX 默认是开启<code>Etag</code>和 <code>last-modified</code> 的, 所以es中自定义分词列表的热更新能力就是通过这两个字段实现的</p></blockquote><h4 id=last-modified>last-modified<a hidden class=anchor aria-hidden=true href=#last-modified>#</a></h4><p>last-modified 记录资源最后修改的时间。启用后，请求资源之后的响应头会增加一个 last-modified 字段，如下：</p><p>例如: <code>last-modified: Thu, 20 Dec 2018 11:36:00 GMT</code></p><p>当再次请求该资源时，请求头中会带有<code> if-modified-since</code>字段，值是之前返回的<code> last-modified</code> 的值，如：<code>if-modified-since:Thu, 20 Dec 2018 11:36:00 GMT</code>。服务端会对比该字段和资源的最后修改时间，若一致则证明没有被修改，告知浏览器可直接使用缓存并返回 304；若不一致则直接返回修改后的资源，并修改 <code>last-modified</code> 为新的值。</p><p>但 <code>last-modified</code> 有以下两个问题：</p><ol><li>只要编辑了，不管内容是否真的有改变，都会以这最后修改的时间作为判断依据，当成新资源返回，从而导致了没必要的请求响应</li><li>时间的精确度只能到秒，如果在一秒内的修改是检测不到更新的，仍会告知浏览器使用旧的缓存。</li></ol><h4 id=etag-entitytags>ETag (EntityTags)<a hidden class=anchor aria-hidden=true href=#etag-entitytags>#</a></h4><p>为了解决<code>last-modified</code> 上述问题，有了 <code>etag</code>。 <code>etag </code>会基于资源的内容编码生成一串唯一的标识字符串，只要内容不同，就会生成不同的 <code>etag</code>。启用 etag 之后，请求资源后的响应返回会增加一个 etag 字段，如下： <code>etag: "FllOiaIvA1f-ftHGziLgMIMVkVw_"</code></p><p>当再次请求该资源时，请求头会带有 <code>if-none-match</code> 字段，值是之前返回的 etag 值，如：<code>if-none-match:"FllOiaIvA1f-ftHGziLgMIMVkVw_"</code>。服务端会根据该资源当前的内容生成对应的标识字符串和该字段进行对比，若一致则代表未改变可直接使用本地缓存并返回 304；若不一致则返回新的资源（状态码200）并修改返回的 etag 字段为新的值。</p><p>可以看出 etag 比 last-modified 更加精准地感知了变化，所以 <strong>etag 优先级也更高</strong>。不过从上面也可以看出 etag 存在的问题，就是<u>每次生成标识字符串会增加服务器的开销</u>。</p><p><strong>弱etag</strong></p><p><code>ETag: W/"630c1e6c-3485"</code> 在商城中看到的是带了<code>W/</code>的, 这表示弱校验 , 全称是 <code>weak</code>, 强校验是字节级别的, 弱校验是语义级别的</p><p>在Apache服务器中 Apache默认通过FileEtag中<code>FileEtag | Node Mtime Size</code>的配置自动生成ETag (节点/修改时间/文件大小 三个因素), 如果文件在一秒内频繁修改,并不改内容, 且etag的生成规则改为 <code>Mtime</code>, 则etag在这一秒内的都是一样的, 此种情况下可以通过 弱etag 来减少刷新缓存 (毕竟强etag是全局唯一的)</p><blockquote><p>etag 的生成规则 http并没有定义 , 因此具体的etag生成逻辑由服务端实现</p></blockquote><p><a href=https://juejin.cn/post/7078272638203723789 target=_blank rel=noopener>一文讲透HTTP缓存之ETag - 掘金 (juejin.cn)</a></p><p><a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests#validators target=_blank rel=noopener>HTTP 条件请求 - HTTP |MDN (mozilla.org)</a></p><h2 id=案例分析>案例分析<a hidden class=anchor aria-hidden=true href=#案例分析>#</a></h2><p>假设当前有这么一个 index 页面，返回的响应信息如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>cache-control: max-age=72000
</span></span><span style=display:flex><span>expires: Tue, 20 Nov 2018 20:41:14 GMT
</span></span><span style=display:flex><span>last-modified: Tue, 20 Nov 2018 00:41:14 GMT
</span></span></code></pre></div><p><strong>标签进入、输入url回车进入</strong></p><p>这种情况下会根据实际设计的缓存策略去判断。</p><ol><li>由于该例没有设置 no-cache 和 no-store，所以默认先走强缓存路线。根据 <code>cache-control</code> （<code>expires</code> 优先级低）判断缓存是否过期，若没有过期则此时返回 200(from cache)。</li><li>若本地缓存已经过期再走协商缓存路线，根据之前的 last-modified 值去与服务器比对，若这个时间之后没有改过则去读取本地缓存，返回 304(not modified)。</li><li>否则返回新的资源，状态码 200(ok)，并更新返回响应的 last-modified 值。</li></ol><p><strong>按刷新按钮、F5 刷新、网页右键“重新加载”</strong></p><p>不使用强缓存,直接使用 协商缓存</p><p><strong>ctrl + F5 强制刷新</strong></p><p>强缓存和协商缓存都不走, 直接获取最新资源</p><p><a href=https://www.cnblogs.com/sexintercourse/p/16602415.html target=_blank rel=noopener>HTTP中的强缓存与协商缓存 - 漫思 - 博客园 (cnblogs.com)</a></p><p><a href=https://www.jianshu.com/p/fb59c770160c target=_blank rel=noopener>强缓存和协商缓存 - 简书 (jianshu.com)</a></p><h1 id=http3>http3<a hidden class=anchor aria-hidden=true href=#http3>#</a></h1><p><img loading=lazy src=http.assets/webp.webp alt=img></p><ol><li>HTTP3<strong>基于UDP协议</strong>重新定义了连接，在<strong>QUIC</strong>层实现了无序、并发字节流的传输，解决了队头阻塞问题（包括基于QPACK解决了动态表的队头阻塞）；</li><li>HTTP3<strong>重新定义了TLS协议加密QUIC(Quick UDP Internet Connection)头部</strong>的方式，既提高了网络攻击成本，又降低了建立连接的速度（仅需1个RTT就可以同时完成建链与密钥协商）；</li><li>HTTP3 将Packet、QUIC Frame、HTTP3 Frame分离，实现了连接迁移功能，降低了5G环境下高速移动设备的连接维护成本。</li></ol><blockquote><p><strong>基于TCP实现的HTTP2遗留下3个问题：</strong></p><ol><li>有序字节流引出的<strong>队头阻塞</strong>（Head-of-line blocking），使得HTTP2的多路复用能力大打折扣；</li><li><strong>TCP与TLS叠加了握手时延</strong>，建链时长还有1倍的下降空间；</li><li>基于TCP四元组确定一个连接，这种诞生于有线网络的设计，并不适合移动状态下的无线网络，这意味着<strong>IP地址的频繁变动会导致TCP连接、TLS会话反复握手，成本高昂</strong>。</li></ol></blockquote><h1 id=预检请求>预检请求<a hidden class=anchor aria-hidden=true href=#预检请求>#</a></h1><p>发生跨域请求时, 浏览器不知道当前请求是否被服务端允许, 所以需要发送一个请求去验证一下, 此为预检请求.(浏览器自动发起)</p><p><strong>预检请求长什么样?</strong></p><p><img loading=lazy src=.%5chttp.assets%5cimage-20230719135510056.png alt=image-20230719135510056></p><p>可以看到有两个一样的请求, post请求是我们正常的业务请求, 而options就是预检请求, 但预检请求是不带body,也不会修改服务器的资源,也不会返回响应体.</p><p><strong>什么时候会发生预检请求?</strong></p><ol><li><p>发生了跨域请求</p><blockquote><p>协议 + 域名 + 端口 组成源, 当 起始源和目标源 不同时认为是跨域请求</p></blockquote></li><li><p>该请求是非简单请求</p><blockquote><p>浏览器将CORS请求分成两类：<code>简单请求（simple request）</code>和<code>非简单请求（not-so-simple request</code>）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><ol><li>请求方法是以下三种方法之一：
HEAD
GET
POST</li><li>HTTP的头信息不超出以下几种字段：
Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ol><p>也就</p><p>我们常用的业务接口, 一般是json格式传参, 或者加了自定义的请求头参数, 也就是说这些接口都是<code>非简单请求</code></p></blockquote></li><li><p>预检缓存过期或者禁止了缓存 (浏览器控制台上可以禁用缓存)</p></li></ol><p><strong>详解</strong></p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。<strong>预请求实际上是对服务端的一种权限请求</strong></p><p><strong>请求头</strong></p><p>&ldquo;预检"请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，</p><p>关键字段是<code>Origin</code>，表示请求来自哪个源。</p><p><code>Access-Control-Request-Method</code>: 用来列出浏览器的CORS请求会用到哪些HTTP方法</p><p><code>Access-Control-Request-Headers</code>: 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，例如<code>X-Custom-Header,authorization,saas-auth</code></p><p><strong>响应头</strong></p><p><code>Access-Control-Allow-Origin</code>: 表示允许的来源, * 表示允许任意来源</p><p><code>Access-Control-Allow-Methods</code>: 它的值是逗号分隔的一个字符串，表明服务器支持的<strong>所有</strong>跨域请求的方法(这样可以避免多次"预检"请求。)</p><p><code>Access-Control-Allow-Headers</code>: 它是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段</p><p><code>Access-Control-Max-Age</code>: 该字段可选，用来指定本次预检请求的有效期，单位为秒。</p><p><a href=https://zhuanlan.zhihu.com/p/46405073 target=_blank rel=noopener>预检请求 OPTIONS - 知乎 (zhihu.com)</a></p><p><a href=https://zhuanlan.zhihu.com/p/528620968 target=_blank rel=noopener>http CORS options请求（预检请求）详解 - 知乎 (zhihu.com)</a></p><p><a href=https://www.infoq.cn/article/WhCObxfbgtphY7ijv1kp target=_blank rel=noopener>5分钟看懂HTTP3_文化 & 方法_Mehdi Zed_InfoQ精选文章</a></p><p><a href=https://juejin.cn/post/7072545788785590303 target=_blank rel=noopener>http3.0初体验 - 掘金 (juejin.cn)</a></p><p><a href=https://www.jianshu.com/p/dd9719c4c2c1 target=_blank rel=noopener>HTTP协议-HTTP3 - 简书 (jianshu.com)</a></p><p><a href=https://zhuanlan.zhihu.com/p/431672713 target=_blank rel=noopener>深入剖析HTTP3协议 - 知乎 (zhihu.com)</a></p><p><a href=https://ispacesoft.com/58707.html target=_blank rel=noopener>HTTP3.0和QUIC协议那些事 - 思创斯聊编程 (ispacesoft.com)</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/%E7%BD%91%E7%BB%9C.html>网络</a></li><li><a href=https://xiaokunji.com/zh/tags/%E7%BB%BC%E5%90%88.html>综合</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%A4%A7%E6%95%B0%E6%8D%AE/hive.html><span class=title>« 上一页</span><br><span>hive</span></a>
<a class=next href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C/https.html><span class=title>下一页 »</span><br><span>HTTPS</span></a></nav></footer></article></main><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>