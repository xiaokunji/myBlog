<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>java基础 | 米二</title><meta name=keywords content=" **1.java是值传递还是引用传递**, **2.尾递归**, **3. java中的CAS和AQS**, 4. jvm中的记忆集(Remembered Set)是什么?, 5. 运行时常量池和字符串常量池, 运行时常量池, 字符串常量池, 两个池的存放位置, 6. java 虚拟线程"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java/java%E5%9F%BA%E7%A1%80.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java/java%E5%9F%BA%E7%A1%80.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="java基础"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java/java%E5%9F%BA%E7%A1%80.html"><meta property="article:section" content="综合"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-04T05:46:31+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="java基础"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"java基础","item":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java/java%E5%9F%BA%E7%A1%80.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"java基础","name":"java基础","description":"     ","keywords":[" **1.java是值传递还是引用传递**"," **2.尾递归**"," **3. java中的CAS和AQS**"," 4. jvm中的记忆集(Remembered Set)是什么?"," 5. 运行时常量池和字符串常量池"," 运行时常量池"," 字符串常量池"," 两个池的存放位置"," 6. java 虚拟线程"],"articleBody":"1.java是值传递还是引用传递 ​ 答: 全部均为值传递!!!!\n以前我认为基本类型是值传递,而对象是引用传递,这是错误的!!!!\n有时候我会觉得传对象时里面的属性值变化了,\n(瞎猜:)其实是属性值的地址变化了,值也就改变了,而原来的值还在,指向原来的地址,只是没人用而已(等待被回收)\n来自* \u003chttps://blog.csdn.net/bjweimengshu/article/details/79799485 \u003e\n2.尾递归 有一种特殊的递归方式叫尾递归。如果函数中的递归调用都是尾调用，则该函数是尾递归函数。尾递归的特性使得递归调用不需要额外的空间 . 不能有任何操作, 如果有f(n)+1这类的操作,都不算尾递归(因为还是保存了函数的返回值)\n来自:https://www.ibm.com/developerworks/cn/java/j-understanding-functional-programming-2/index.html?ca=drs-#icomments\nhttps://www.cnblogs.com/bellkosmos/p/5280619.html // 实现斐波那契数列 // 普通递归 int FibonacciRecursive(int n) { if( n \u003c 2) return n; return FibonacciRecursive(n-1)+FibonacciRecursive(n-2); } // 尾递归 int FibonacciTailRecursive(int n,int ret1,int ret2) { if(n==0) return ret1; return FibonacciTailRecursive(n-1,ret2,ret1+ret2); } 来自: https://blog.csdn.net/mengxiangjia_linxi/article/details/78158819 尾递归效率高的原理:\n尾递归就是从最后开始计算, 每递归一次就算出相应的结果, 也就是说, 函数调用出现在调用者函数的尾部, 因为是尾部, 所以根本没有必要去保存任何局部变量. 直接让被调用的函数返回时越过调用者, 返回到调用者的调用者去。精髓：尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数 , 也不用开辟新的栈空间,直接用上一个栈\n尾递归优化得益于编译器的支持,恰巧java不支持尾递归优化,但是上面那种省栈省开销还是有的(应该吧).一般函数式语言都是支持的,比如scala\n但是可以利用lambda的懒加载来实现尾递归优化,\n详情: https://www.cnblogs.com/invoker-/p/7723420.html#autoid-3-0-0 3. java中的CAS和AQS CAS : Conmpare And Swap (比较和交换) 是用于实现多线程同步的原子指令。 它将内存位置的内容与给(期望)定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 这是作为单个原子操作完成的。\nAQS: 抽象队列同步器(AbstractQueuedSynchronizer) , 是用来构建锁或者其他同步组件的基础框架，它使用一个int成员表示同步状态，通过内部的FIFO队列来完成资源获取线程的排序工作。ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的，\nhttps://blog.csdn.net/yanghan1222/article/details/80247844 https://www.jianshu.com/p/0f876ead2846 https://www.cnblogs.com/fsmly/p/11274572.html 4. jvm中的记忆集(Remembered Set)是什么? jvm的堆内存分为了 年轻代和老年代, 分别使用各自的垃圾回收器回收\n如果年轻代中的对象引用了老年代的对象, 当youngGC时就不能只扫描年轻代, 还得扫描老年代看对象是否有引用, 这种情况下, 就会变成扫描整个堆 —– 称为 跨代引用假说\n所以jvm在年轻代中存了一个全局的数据结构, 称为记忆集. 这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描\n5. 运行时常量池和字符串常量池 运行时常量池 类文件中除了包含类的版本、字段、方法、接口等描述信息, 这些最开始都是保存在常量池中，他们都是静态信息,\n当程序运行时被加载到内存后，这些符号才有对应的内存地址信息。这些常量一旦被转入内存就会变成运行时常量池。运行时常量池在方法区中。\n比如 math.compute() , 在代码中写的是字符串, 那具体怎么调用的呢?\ncompute()这个符号引用在运行时就会被转变为compute()方法具体代码在内存中的地址，主要通过对象头里的类型指针去转换直接引用。\ncompute()方法被加载到内存以后，就有了自己的地址，原来调用computer()方法的符号引用，现在就变成对compute()地址的直接引用，这个直接引用是存在对象头里的，通过指针来指向直接引用\n所以 运行时常量池 存的类和方法等一些描述信息, 用于程序调用执行, 存在方法区中, jdk8后放入元空间了\n字符串常量池 字符串常量池存的是字符串信息 , 存在于堆中 , 因为字符串用的多, 所以用个池单独存起来, 并实现值的复用\n比如:\nString c = \"abcdefg\" String d = \"abcdefg\" c和d 都指向字符串常量池, 且为同一个内存地址,\njdk8后 静态成员变量也放在堆中了\n两个池的存放位置 深刻理解运行时常量池、字符串常量池 - 掘金 (juejin.cn) java的字符串存储在堆中还是常量池中_编码大神经的博客-CSDN博客 6. java 虚拟线程 虚拟线程（Virtual Thread-）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。\n近几十年来，我们一直依靠上述多线程模型来解决 Java 中的并发编程问题。为了提高系统的吞吐量，我们必须不断增加线程的数量，但是机器的线程很昂贵，可用线程的数量是有限的。尽管我们使用各种线程池来最大限度地提高线程的成本效益，但在 CPU、网络或内存资源被耗尽之前，线程往往成为我们应用程序性能的瓶颈，无法释放硬件应具有的最大性能。\n我们常见的Java线程与系统内核线程是一一对应的，系统内核线程调度器负责调度Java线程。\nJava19 引入了虚拟线程。在 Java19 中，我们以前使用的线程称为平台线程，仍然与系统内核线程一一对应。大量 (M个) 的虚拟线程，运行在少量 (N个) 的平台线程上（与 OS 线程一一对应）（M:N 调度）。JVM调度多个虚拟线程在特定平台线程上执行，并且在平台线程上一次只执行一个虚拟线程。\n直接用虚拟线程池代替线程池。如果您的项目使用CompletableFuture，您也可以直接将执行异步任务的线程池替换为Executors.newVirtualThreadPerTaskExecutor(). 消除池化机制。虚拟线程非常轻量级，不需要池化。 synchronized更改为ReentrantLock减少固定到平台线程的虚拟线程。 Java19 虚拟线程原理介绍及实现_lew-yu的博客-CSDN博客 Java 19 新特性概览 | JavaGuide ","wordCount":"2403","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-09-04T05:46:31.201184496Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java/java%E5%9F%BA%E7%A1%80.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88.html>综合</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86.html>个人小知识</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java.html>java</a> <span>></span></ul></nav><h1 class=post-title>java基础</h1><div class=post-description></div><div class=post-meta>创建:&nbsp;<span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;更新:&nbsp;2023-09-04&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/%E7%BB%BC%E5%90%88.html>综合</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv>1</span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#1java%e6%98%af%e5%80%bc%e4%bc%a0%e9%80%92%e8%bf%98%e6%98%af%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92 aria-label=1.java是值传递还是引用传递><strong>1.java是值传递还是引用传递</strong></a></li><li><a href=#2%e5%b0%be%e9%80%92%e5%bd%92 aria-label=2.尾递归><strong>2.尾递归</strong></a></li><li><a href=#3-java%e4%b8%ad%e7%9a%84cas%e5%92%8caqs aria-label="3. java中的CAS和AQS"><strong>3. java中的CAS和AQS</strong></a></li><li><a href=#4-jvm%e4%b8%ad%e7%9a%84%e8%ae%b0%e5%bf%86%e9%9b%86remembered-set%e6%98%af%e4%bb%80%e4%b9%88 aria-label="4. jvm中的记忆集(Remembered Set)是什么?">4. jvm中的记忆集(Remembered Set)是什么?</a></li><li><a href=#5-%e8%bf%90%e8%a1%8c%e6%97%b6%e5%b8%b8%e9%87%8f%e6%b1%a0%e5%92%8c%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%b8%b8%e9%87%8f%e6%b1%a0 aria-label="5. 运行时常量池和字符串常量池">5. 运行时常量池和字符串常量池</a><ul><li><a href=#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%b8%b8%e9%87%8f%e6%b1%a0 aria-label=运行时常量池>运行时常量池</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%b8%b8%e9%87%8f%e6%b1%a0 aria-label=字符串常量池>字符串常量池</a></li><li><a href=#%e4%b8%a4%e4%b8%aa%e6%b1%a0%e7%9a%84%e5%ad%98%e6%94%be%e4%bd%8d%e7%bd%ae aria-label=两个池的存放位置>两个池的存放位置</a></li></ul></li><li><a href=#6-java-%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b aria-label="6. java 虚拟线程">6. java 虚拟线程</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=1java是值传递还是引用传递><strong>1.java是值传递还是引用传递</strong><a hidden class=anchor aria-hidden=true href=#1java是值传递还是引用传递>#</a></h1><p>​ 答: <strong>全部均为值传递!!!!</strong></p><p>以前我认为基本类型是值传递,而对象是引用传递,这是错误的!!!!</p><p>有时候我会觉得传对象时里面的属性值变化了,</p><p>(瞎猜:)其实是属性值的地址变化了,值也就改变了,而原来的值还在,指向原来的地址,只是没人用而已(等待被回收)</p><blockquote><p>来自* <em>&lt;</em><a href=https://blog.csdn.net/bjweimengshu/article/details/79799485 target=_blank rel=noopener><em>https://blog.csdn.net/bjweimengshu/article/details/79799485</em></a>
<em>></em></p></blockquote><h1 id=2尾递归><strong>2.尾递归</strong><a hidden class=anchor aria-hidden=true href=#2尾递归>#</a></h1><p>有一种特殊的递归方式叫尾递归。如果函数中的递归调用都是尾调用，则该函数是尾递归函数。尾递归的特性使得递归调用不需要额外的空间 . 不能有任何操作, 如果有f(n)+1这类的操作,都不算尾递归(因为还是保存了函数的返回值)</p><blockquote><p>来自:https://www.ibm.com/developerworks/cn/java/j-understanding-functional-programming-2/index.html?ca=drs-#icomments</p><p><a href=https://www.cnblogs.com/bellkosmos/p/5280619.html target=_blank rel=noopener>https://www.cnblogs.com/bellkosmos/p/5280619.html</a></p></blockquote><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 实现斐波那契数列
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 普通递归
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span> <span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>FibonacciRecursive</span><span style=color:#ff7b72;font-weight:700>(</span><span style=color:#ff7b72>int</span> n<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>     <span style=color:#ff7b72>if</span><span style=color:#ff7b72;font-weight:700>(</span> n <span style=color:#ff7b72;font-weight:700>&lt;</span> 2<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>         <span style=color:#ff7b72>return</span> n<span style=color:#ff7b72;font-weight:700>;</span>
</span></span><span style=display:flex><span>     <span style=color:#ff7b72>return</span> FibonacciRecursive<span style=color:#ff7b72;font-weight:700>(</span>n<span style=color:#ff7b72;font-weight:700>-</span>1<span style=color:#ff7b72;font-weight:700>)+</span>FibonacciRecursive<span style=color:#ff7b72;font-weight:700>(</span>n<span style=color:#ff7b72;font-weight:700>-</span>2<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span> <span style=color:#ff7b72;font-weight:700>}</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> <span style=color:#8b949e;font-style:italic>// 尾递归
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#ff7b72>int</span> <span style=color:#d2a8ff;font-weight:700>FibonacciTailRecursive</span><span style=color:#ff7b72;font-weight:700>(</span><span style=color:#ff7b72>int</span> n<span style=color:#ff7b72;font-weight:700>,</span><span style=color:#ff7b72>int</span> ret1<span style=color:#ff7b72;font-weight:700>,</span><span style=color:#ff7b72>int</span> ret2<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#ff7b72;font-weight:700>{</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>if</span><span style=color:#ff7b72;font-weight:700>(</span>n<span style=color:#ff7b72;font-weight:700>==</span>0<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>       <span style=color:#ff7b72>return</span> ret1<span style=color:#ff7b72;font-weight:700>;</span> 
</span></span><span style=display:flex><span>     <span style=color:#ff7b72>return</span> FibonacciTailRecursive<span style=color:#ff7b72;font-weight:700>(</span>n<span style=color:#ff7b72;font-weight:700>-</span>1<span style=color:#ff7b72;font-weight:700>,</span>ret2<span style=color:#ff7b72;font-weight:700>,</span>ret1<span style=color:#ff7b72;font-weight:700>+</span>ret2<span style=color:#ff7b72;font-weight:700>);</span>
</span></span><span style=display:flex><span> <span style=color:#ff7b72;font-weight:700>}</span>
</span></span></code></pre></div><blockquote><p>来自: <a href=https://blog.csdn.net/mengxiangjia_linxi/article/details/78158819 target=_blank rel=noopener>https://blog.csdn.net/mengxiangjia_linxi/article/details/78158819</a></p></blockquote><p>尾递归效率高的原理:</p><p>尾递归就是从最后开始计算, 每递归一次就算出相应的结果, 也就是说, 函数调用出现在调用者函数的尾部, 因为是尾部, 所以根本没有必要去保存任何局部变量. 直接让被调用的函数返回时越过调用者, 返回到调用者的调用者去。<strong>精髓：尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数 , 也不用开辟新的栈空间,直接用上一个栈</strong></p><p>尾递归优化得益于编译器的支持,恰巧<strong>java不支持尾递归优化</strong>,但是上面那种省栈省开销还是有的(应该吧).一般函数式语言都是支持的,比如scala</p><p>但是可以利用lambda的懒加载来实现尾递归优化,</p><blockquote><p>详情: <a href=https://www.cnblogs.com/invoker-/p/7723420.html#autoid-3-0-0 target=_blank rel=noopener>https://www.cnblogs.com/invoker-/p/7723420.html#autoid-3-0-0</a></p></blockquote><h1 id=3-java中的cas和aqs><strong>3. java中的CAS和AQS</strong><a hidden class=anchor aria-hidden=true href=#3-java中的cas和aqs>#</a></h1><p>CAS : Conmpare And Swap (比较和交换) 是用于实现<strong>多线程同步的原子指令</strong>。 它将内存位置的内容与给(期望)定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 这是作为单个原子操作完成的。</p><p>AQS: 抽象队列同步器(AbstractQueuedSynchronizer) , 是用来<strong>构建锁或者其他同步组件的基础框架</strong>，它使用一个int成员表示同步状态，通过内部的FIFO队列来完成资源获取线程的排序工作。ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的，</p><blockquote><p><a href=https://blog.csdn.net/yanghan1222/article/details/80247844 target=_blank rel=noopener>https://blog.csdn.net/yanghan1222/article/details/80247844</a></p><p><a href=https://www.jianshu.com/p/0f876ead2846 target=_blank rel=noopener>https://www.jianshu.com/p/0f876ead2846</a></p><p><a href=https://www.cnblogs.com/fsmly/p/11274572.html target=_blank rel=noopener>https://www.cnblogs.com/fsmly/p/11274572.html</a></p></blockquote><h1 id=4-jvm中的记忆集remembered-set是什么>4. jvm中的记忆集(Remembered Set)是什么?<a hidden class=anchor aria-hidden=true href=#4-jvm中的记忆集remembered-set是什么>#</a></h1><p>jvm的堆内存分为了 年轻代和老年代, 分别使用各自的垃圾回收器回收</p><p>如果年轻代中的对象引用了老年代的对象, 当youngGC时就不能只扫描年轻代, 还得扫描老年代看对象是否有引用, 这种情况下, 就会变成扫描整个堆 &mdash;&ndash; 称为 <strong>跨代引用假说</strong></p><p>所以jvm在年轻代中存了一个<strong>全局的数据结构, 称为记忆集</strong>. 这个结构把老年代划分成若干小块，<strong>标识出老年代的哪一块内存会存在跨代引用</strong>。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描</p><h1 id=5-运行时常量池和字符串常量池>5. 运行时常量池和字符串常量池<a hidden class=anchor aria-hidden=true href=#5-运行时常量池和字符串常量池>#</a></h1><h2 id=运行时常量池>运行时常量池<a hidden class=anchor aria-hidden=true href=#运行时常量池>#</a></h2><p>类文件中除了包含<strong>类的版本、字段、方法、接口</strong>等描述信息, 这些最开始都是保存在常量池中，他们都是静态信息,</p><p>当程序运行时被加载到内存后，这些符号才有对应的内存地址信息。这些常量一旦被转入内存就会变成<strong>运行时常量池</strong>。运行时常量池在方法区中。</p><blockquote><p>比如 <code>math.compute()</code> , 在代码中写的是字符串, 那具体怎么调用的呢?</p><p>compute()这个符号引用在运行时就会被转变为compute()方法具体代码在内存中的地址，主要通过对象头里的类型指针去转换直接引用。</p><p>compute()方法被加载到内存以后，就有了自己的地址，原来调用computer()方法的符号引用，现在就变成对compute()地址的直接引用，这个直接引用是存在对象头里的，通过指针来指向直接引用</p></blockquote><p>所以 <strong>运行时常量池 存的类和方法等一些描述信息, 用于程序调用执行</strong>, <strong>存在方法区中,</strong> jdk8后放入元空间了</p><h2 id=字符串常量池>字符串常量池<a hidden class=anchor aria-hidden=true href=#字符串常量池>#</a></h2><p><strong>字符串常量池存的是字符串信息</strong> , 存在于堆中 , 因为字符串用的多, 所以用个池单独存起来, 并实现值的复用</p><blockquote><p>比如:</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String c <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>&#34;abcdefg&#34;</span>
</span></span><span style=display:flex><span>String d <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>&#34;abcdefg&#34;</span>
</span></span></code></pre></div><p>c和d 都指向字符串常量池, 且为同一个内存地址,</p></blockquote><blockquote><p>jdk8后 静态成员变量也放在堆中了</p></blockquote><h2 id=两个池的存放位置>两个池的存放位置<a hidden class=anchor aria-hidden=true href=#两个池的存放位置>#</a></h2><p><img loading=lazy src=java%E5%9F%BA%E7%A1%80.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXlvbmcxOTky,size_16,color_FFFFFF,t_70.png alt=img></p><p><a href=https://juejin.cn/post/7058375922235211790#heading-0 target=_blank rel=noopener>深刻理解运行时常量池、字符串常量池 - 掘金 (juejin.cn)</a></p><p><a href=https://blog.csdn.net/liuyong1992/article/details/113835447 target=_blank rel=noopener>java的字符串存储在堆中还是常量池中_编码大神经的博客-CSDN博客</a></p><h1 id=6-java-虚拟线程>6. java 虚拟线程<a hidden class=anchor aria-hidden=true href=#6-java-虚拟线程>#</a></h1><p>虚拟线程（Virtual Thread-）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p><p>近几十年来，我们一直依靠上述多线程模型来解决 Java 中的并发编程问题。为了提高系统的吞吐量，我们必须不断增加线程的数量，但是机器的线程很昂贵，可用线程的数量是有限的。尽管我们使用各种线程池来最大限度地提高线程的成本效益，但在 CPU、网络或内存资源被耗尽之前，线程往往成为我们应用程序性能的瓶颈，无法释放硬件应具有的最大性能。</p><p>我们常见的Java线程与系统内核线程是一一对应的，系统内核线程调度器负责调度Java线程。</p><p><img loading=lazy src=java%E5%9F%BA%E7%A1%80.assets/2b71c4b71dbd4045bfa0ed24ae89d710.png alt=img></p><p>Java19 引入了虚拟线程。在 Java19 中，我们以前使用的线程称为平台线程，仍然与系统内核线程一一对应。大量 (M个) 的虚拟线程，运行在少量 (N个) 的平台线程上（与 OS 线程一一对应）（M:N 调度）。JVM调度多个虚拟线程在特定平台线程上执行，并且在平台线程上一次只执行一个虚拟线程。</p><p><img loading=lazy src=java%E5%9F%BA%E7%A1%80.assets/824e418235d049d0b6bd7c7ed437dc2e.png alt=img></p><blockquote><ol><li>直接用虚拟线程池代替线程池。如果您的项目使用<code>CompletableFuture</code>，您也可以直接将执行异步任务的线程池替换为<code>Executors.newVirtualThreadPerTaskExecutor()</code>.</li><li>消除池化机制。虚拟线程非常轻量级，不需要池化。</li><li>synchronized更改为ReentrantLock减少固定到平台线程的虚拟线程。</li></ol></blockquote><p><a href=https://blog.csdn.net/lewyu521/article/details/127649776 target=_blank rel=noopener>Java19 虚拟线程原理介绍及实现_lew-yu的博客-CSDN博客</a></p><p><a href=https://javaguide.cn/java/new-features/java19.html#jep-424-%e5%a4%96%e9%83%a8%e5%87%bd%e6%95%b0%e5%92%8c%e5%86%85%e5%ad%98-api-%e9%a2%84%e8%a7%88 target=_blank rel=noopener>Java 19 新特性概览 | JavaGuide</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/java.html>java</a></li><li><a href=https://xiaokunji.com/zh/tags/%E7%BB%BC%E5%90%88.html>综合</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95.html><span class=title>« 上一页</span><br><span>java常见面试题</span></a>
<a class=next href=https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/springBoot/jpa.html><span class=title>下一页 »</span><br><span>jpa</span></a></nav></footer></article></main><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>