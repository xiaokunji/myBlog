<!DOCTYPE html>
<html dir="auto" lang="zh"><head><meta charset="utf-8"/><meta content="IE=edge" http-equiv="x-ua-compatible"/><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name="viewport"/><meta content="index, follow" name="robots"/><title>java基础 | 米二</title><meta content=" **1.java是值传递还是引用传递**, **2.尾递归**, **3. java中的CAS和AQS**, 4. jvm中的记忆集(Remembered Set)是什么?, 5. 运行时常量池和字符串常量池, 运行时常量池, 字符串常量池, 两个池的存放位置, 6. java 虚拟线程" name="keywords"/><meta content="     " name="description"/><meta content="xkj" name="author"/><link href="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java/java%E5%9F%BA%E7%A1%80.html" rel="canonical"/><link as="style" crossorigin="anonymous" href="/assets/css/stylesheet.dc6bd2c841ee388e899e13872ae986c0e847e8b957d6714ad6ddc628ef2d17ff.css" integrity="sha256-3GvSyEHuOI6JnhOHKumGwOhH6LlX1nFK1t3GKO8tF/8=" rel="preload stylesheet"/><script crossorigin="anonymous" defer="" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload="hljs.initHighlightingOnLoad()" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js"></script>
<link href="https://xiaokunji.com/img/Q.svg" rel="icon"/><link href="https://xiaokunji.com/img/Q.svg" rel="icon" sizes="16x16" type="image/png"/><link href="https://xiaokunji.com/img/Q.svg" rel="icon" sizes="32x32" type="image/png"/><link href="https://xiaokunji.com/Q.svg" rel="apple-touch-icon"/><link href="https://xiaokunji.com/Q.svg" rel="mask-icon"/><meta content="#2e2e33" name="theme-color"/><meta content="#2e2e33" name="msapplication-TileColor"/><link href="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java/java%E5%9F%BA%E7%A1%80.html" hreflang="zh" rel="alternate"/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta content="java基础" property="og:title"/><meta content="     " property="og:description"/><meta content="article" property="og:type"/><meta content="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java/java%E5%9F%BA%E7%A1%80.html" property="og:url"/><meta content="综合" property="article:section"/><meta content="2023-08-22T00:00:00+00:00" property="article:published_time"/><meta content="2024-10-19T23:16:48+08:00" property="article:modified_time"/><meta content="summary" name="twitter:card"/><meta content="java基础" name="twitter:title"/><meta content="     " name="twitter:description"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":5,"name":"java基础","item":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java/java%E5%9F%BA%E7%A1%80.html"}]}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"java基础","name":"java基础","description":"     ","keywords":[" **1.java是值传递还是引用传递**"," **2.尾递归**"," **3. java中的CAS和AQS**"," 4. jvm中的记忆集(Remembered Set)是什么?"," 5. 运行时常量池和字符串常量池"," 运行时常量池"," 字符串常量池"," 两个池的存放位置"," 6. java 虚拟线程"],"articleBody":"1.java是值传递还是引用传递 ​ 答: 全部均为值传递!!!!\n以前我认为基本类型是值传递,而对象是引用传递,这是错误的!!!!\n有时候我会觉得传对象时里面的属性值变化了,\n(瞎猜:)其实是属性值的地址变化了,值也就改变了,而原来的值还在,指向原来的地址,只是没人用而已(等待被回收)\n来自* \u003chttps://blog.csdn.net/bjweimengshu/article/details/79799485 \u003e\n2.尾递归 有一种特殊的递归方式叫尾递归。如果函数中的递归调用都是尾调用，则该函数是尾递归函数。尾递归的特性使得递归调用不需要额外的空间 . 不能有任何操作, 如果有f(n)+1这类的操作,都不算尾递归(因为还是保存了函数的返回值)\n来自:https://www.ibm.com/developerworks/cn/java/j-understanding-functional-programming-2/index.html?ca=drs-#icomments\nhttps://www.cnblogs.com/bellkosmos/p/5280619.html // 实现斐波那契数列 // 普通递归 int FibonacciRecursive(int n) { if( n \u003c 2) return n; return FibonacciRecursive(n-1)+FibonacciRecursive(n-2); } // 尾递归 int FibonacciTailRecursive(int n,int ret1,int ret2) { if(n==0) return ret1; return FibonacciTailRecursive(n-1,ret2,ret1+ret2); } 来自: https://blog.csdn.net/mengxiangjia_linxi/article/details/78158819 尾递归效率高的原理:\n尾递归就是从最后开始计算, 每递归一次就算出相应的结果, 也就是说, 函数调用出现在调用者函数的尾部, 因为是尾部, 所以根本没有必要去保存任何局部变量. 直接让被调用的函数返回时越过调用者, 返回到调用者的调用者去。精髓：尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数 , 也不用开辟新的栈空间,直接用上一个栈\n尾递归优化得益于编译器的支持,恰巧java不支持尾递归优化,但是上面那种省栈省开销还是有的(应该吧).一般函数式语言都是支持的,比如scala\n但是可以利用lambda的懒加载来实现尾递归优化,\n详情: https://www.cnblogs.com/invoker-/p/7723420.html#autoid-3-0-0 3. java中的CAS和AQS CAS : Conmpare And Swap (比较和交换) 是用于实现多线程同步的原子指令。 它将内存位置的内容与给(期望)定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 这是作为单个原子操作完成的。\nAQS: 抽象队列同步器(AbstractQueuedSynchronizer) , 是用来构建锁或者其他同步组件的基础框架，它使用一个int成员表示同步状态，通过内部的FIFO队列来完成资源获取线程的排序工作。ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的，\nhttps://blog.csdn.net/yanghan1222/article/details/80247844 https://www.jianshu.com/p/0f876ead2846 https://www.cnblogs.com/fsmly/p/11274572.html 3.1 CAS 的三大问题 尽管 CAS 提供了一种有效的同步手段，但也存在一些问题，主要有以下三个：ABA 问题、长时间自旋、多个共享变量的原子操作。\n1. ABA 问题\n所谓的 ABA 问题，就是一个值原来是 A，变成了 B，又变回了 A。这个时候使用 CAS 是检查不出变化的，但实际上却被更新了两次。\nABA 问题的解决思路是在变量前面追加上版本号或者时间戳。从 JDK 1.5 开始，JDK 的 atomic 包里提供了一个类AtomicStampedReference类来解决 ABA 问题。\n2. 长时间自旋 CAS 多与自旋结合。如果自旋 CAS 长时间不成功，会占用大量的 CPU 资源。\n解决思路是让 JVM 支持处理器提供的pause 指令。\npause 指令能让自旋失败时 cpu 睡眠一小段时间再继续自旋，从而使得读操作的频率降低很多，为解决内存顺序冲突而导致的 CPU 流水线重排的代价也会小很多。\n3. 多个共享变量的原子操作\n当对一个共享变量执行操作时，CAS 能够保证该变量的原子性。但是对于多个共享变量，CAS 就无法保证操作的原子性，\n这时通常有两种做法：\n使用AtomicReference类保证对象之间的原子性，把多个变量放到一个对象里面进行 CAS 操作； 使用锁。锁内的临界区代码可以保证只有当前线程能操作。 一文彻底搞清楚Java实现CAS的原理 | 二哥的Java进阶之路 (javabetter.cn) 4. jvm中的记忆集(Remembered Set)是什么? jvm的堆内存分为了 年轻代和老年代, 分别使用各自的垃圾回收器回收\n如果年轻代中的对象引用了老年代的对象, 当youngGC时就不能只扫描年轻代, 还得扫描老年代看对象是否有引用, 这种情况下, 就会变成扫描整个堆 —– 称为 跨代引用假说\n所以jvm在年轻代中存了一个全局的数据结构, 称为记忆集. 这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描\n5. 运行时常量池和字符串常量池 运行时常量池 类文件中除了包含类的版本、字段、方法、接口等描述信息, 这些最开始都是保存在常量池中，他们都是静态信息,\n当程序运行时被加载到内存后，这些符号才有对应的内存地址信息。这些常量一旦被转入内存就会变成运行时常量池。运行时常量池在方法区中。\n比如 math.compute() , 在代码中写的是字符串, 那具体怎么调用的呢?\ncompute()这个符号引用在运行时就会被转变为compute()方法具体代码在内存中的地址，主要通过对象头里的类型指针去转换直接引用。\ncompute()方法被加载到内存以后，就有了自己的地址，原来调用computer()方法的符号引用，现在就变成对compute()地址的直接引用，这个直接引用是存在对象头里的，通过指针来指向直接引用\n所以 运行时常量池 存的类和方法等一些描述信息, 用于程序调用执行, 存在方法区中, jdk8后放入元空间了\n字符串常量池 字符串常量池存的是字符串信息 , 存在于堆中 , 因为字符串用的多, 所以用个池单独存起来, 并实现值的复用\n比如:\nString c = \"abcdefg\" String d = \"abcdefg\" c和d 都指向字符串常量池, 且为同一个内存地址,\njdk8后 静态成员变量也放在堆中了\n两个池的存放位置 深刻理解运行时常量池、字符串常量池 - 掘金 (juejin.cn) java的字符串存储在堆中还是常量池中_编码大神经的博客-CSDN博客 6. java 虚拟线程 虚拟线程（Virtual Thread-）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。\n近几十年来，我们一直依靠上述多线程模型来解决 Java 中的并发编程问题。为了提高系统的吞吐量，我们必须不断增加线程的数量，但是机器的线程很昂贵，可用线程的数量是有限的。尽管我们使用各种线程池来最大限度地提高线程的成本效益，但在 CPU、网络或内存资源被耗尽之前，线程往往成为我们应用程序性能的瓶颈，无法释放硬件应具有的最大性能。\n我们常见的Java线程与系统内核线程是一一对应的，系统内核线程调度器负责调度Java线程。\nJava19 引入了虚拟线程。在 Java19 中，我们以前使用的线程称为平台线程，仍然与系统内核线程一一对应。大量 (M个) 的虚拟线程，运行在少量 (N个) 的平台线程上（与 OS 线程一一对应）（M:N 调度）。JVM调度多个虚拟线程在特定平台线程上执行，并且在平台线程上一次只执行一个虚拟线程。\n直接用虚拟线程池代替线程池。如果您的项目使用CompletableFuture，您也可以直接将执行异步任务的线程池替换为Executors.newVirtualThreadPerTaskExecutor(). 消除池化机制。虚拟线程非常轻量级，不需要池化。 synchronized更改为ReentrantLock减少固定到平台线程的虚拟线程。 Java19 虚拟线程原理介绍及实现_lew-yu的博客-CSDN博客 Java 19 新特性概览 | JavaGuide ","wordCount":"2911","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2024-10-19T23:16:48+08:00","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java/java%E5%9F%BA%E7%A1%80.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class="dark" id="top"><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class="header"><nav class="nav"><div class="logo"><a accesskey="h" href="https://xiaokunji.com/zh/" title="米二 (Alt + H)"><img alt="" aria-label="logo" height="35" src="https://xiaokunji.com/img/Q.svg"/>米二</a><div class="logo-switches"><button accesskey="t" id="theme-toggle" title="(Alt + T)"><svg fill="none" height="18" id="moon" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg><svg fill="none" height="18" id="sun" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="5"></circle><line x1="12" x2="12" y1="1" y2="3"></line><line x1="12" x2="12" y1="21" y2="23"></line><line x1="4.22" x2="5.64" y1="4.22" y2="5.64"></line><line x1="18.36" x2="19.78" y1="18.36" y2="19.78"></line><line x1="1" x2="3" y1="12" y2="12"></line><line x1="21" x2="23" y1="12" y2="12"></line><line x1="4.22" x2="5.64" y1="19.78" y2="18.36"></line><line x1="18.36" x2="19.78" y1="5.64" y2="4.22"></line></svg></button><ul class="lang-switch"><li>|</li><li><a aria-label="English" href="https://xiaokunji.com/en/" title="English">English</a></li></ul></div></div><ul id="menu"><li><a href="https://xiaokunji.com/zh/" title="🏠主页"><span>🏠主页</span></a></li><li><a accesskey="/" href="https://xiaokunji.com/zh/search" title="🔍搜索 (Alt + /)"><span>🔍搜索</span></a></li><li><a href="https://xiaokunji.com/zh/post.html" title="📚文章"><span>📚文章</span></a></li><li><a href="https://xiaokunji.com/zh/archives.html" title="⏱时间轴"><span>⏱时间轴</span></a></li><li><a href="https://xiaokunji.com/zh/tags.html" title="🔖标签"><span>🔖标签</span></a></li><li><a href="https://xiaokunji.com/zh/categories.html" title="📖分类"><span>📖分类</span></a></li><li><a href="https://xiaokunji.com/zh/links.html" title="🤝友链"><span>🤝友链</span></a></li></ul></nav></header><main class="main"><article class="post-single"><header class="post-header"><nav aria-label="breadcrumb"><ul><a href="https://xiaokunji.com/zh/">🏠</a> <span>&gt;</span>
<a href="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88.html">综合</a> <span>&gt;</span>
<a href="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86.html">个人小知识</a> <span>&gt;</span>
<a href="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java.html">java</a> <span>&gt;</span></ul></nav><h1 class="post-title">java基础</h1><div class="post-description"></div><div class="post-meta">创建: <span title="2023-08-22 00:00:00 +0000 UTC">2023-08-22</span> · 更新: 2024-10-19 · xkj
 | 分类:  <ul class="post-categories-meta" style="display:inline"><a href="https://xiaokunji.com/zh/categories/%E7%BB%BC%E5%90%88.html">综合</a></ul><span id="busuanzi_container_page_pv"> | 访问: <span id="busuanzi_value_page_pv">1</span></span></div></header><aside class="toc-container wide" id="toc-container"><div class="toc"><details open=""><summary accesskey="c" title="(Alt + C)"><span class="details">目录</span></summary><div class="inner"><ul><li><a aria-label="1.java是值传递还是引用传递" href="#1java%e6%98%af%e5%80%bc%e4%bc%a0%e9%80%92%e8%bf%98%e6%98%af%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92">1.java是值传递还是引用传递</a></li><li><a aria-label="2.尾递归" href="#2%e5%b0%be%e9%80%92%e5%bd%92">2.尾递归</a></li><li><a aria-label="3. java中的CAS和AQS" href="#3-java%e4%b8%ad%e7%9a%84cas%e5%92%8caqs">3. java中的CAS和AQS</a><ul><li><a aria-label="3.1 CAS 的三大问题" href="#31-cas-%e7%9a%84%e4%b8%89%e5%a4%a7%e9%97%ae%e9%a2%98">3.1 CAS 的三大问题</a></li></ul></li><li><a aria-label="4. jvm中的记忆集(Remembered Set)是什么?" href="#4-jvm%e4%b8%ad%e7%9a%84%e8%ae%b0%e5%bf%86%e9%9b%86remembered-set%e6%98%af%e4%bb%80%e4%b9%88">4. jvm中的记忆集(Remembered Set)是什么?</a></li><li><a aria-label="5. 运行时常量池和字符串常量池" href="#5-%e8%bf%90%e8%a1%8c%e6%97%b6%e5%b8%b8%e9%87%8f%e6%b1%a0%e5%92%8c%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%b8%b8%e9%87%8f%e6%b1%a0">5. 运行时常量池和字符串常量池</a><ul><li><a aria-label="运行时常量池" href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%b8%b8%e9%87%8f%e6%b1%a0">运行时常量池</a></li><li><a aria-label="字符串常量池" href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%b8%b8%e9%87%8f%e6%b1%a0">字符串常量池</a></li><li><a aria-label="两个池的存放位置" href="#%e4%b8%a4%e4%b8%aa%e6%b1%a0%e7%9a%84%e5%ad%98%e6%94%be%e4%bd%8d%e7%bd%ae">两个池的存放位置</a></li></ul></li><li><a aria-label="6. java 虚拟线程" href="#6-java-%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b">6. java 虚拟线程</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class="post-content"><h1 id="1java是值传递还是引用传递">1.java是值传递还是引用传递<a aria-hidden="true" class="anchor" hidden="" href="#1java是值传递还是引用传递">#</a></h1><p>​ 答: <strong>全部均为值传递!!!!</strong></p><p>以前我认为基本类型是值传递,而对象是引用传递,这是错误的!!!!</p><p>有时候我会觉得传对象时里面的属性值变化了,</p><p>(瞎猜:)其实是属性值的地址变化了,值也就改变了,而原来的值还在,指向原来的地址,只是没人用而已(等待被回收)</p><blockquote><p>来自* <em>&lt;</em><a href="https://blog.csdn.net/bjweimengshu/article/details/79799485" rel="noopener" target="_blank"><em>https://blog.csdn.net/bjweimengshu/article/details/79799485</em></a>
<em>&gt;</em></p></blockquote><h1 id="2尾递归">2.尾递归<a aria-hidden="true" class="anchor" hidden="" href="#2尾递归">#</a></h1><p>有一种特殊的递归方式叫尾递归。如果函数中的递归调用都是尾调用，则该函数是尾递归函数。尾递归的特性使得递归调用不需要额外的空间 . 不能有任何操作, 如果有f(n)+1这类的操作,都不算尾递归(因为还是保存了函数的返回值)</p><blockquote><p>来自:https://www.ibm.com/developerworks/cn/java/j-understanding-functional-programming-2/index.html?ca=drs-#icomments</p><p><a href="https://www.cnblogs.com/bellkosmos/p/5280619.html" rel="noopener" target="_blank">https://www.cnblogs.com/bellkosmos/p/5280619.html</a></p></blockquote><div class="highlight"><pre style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-java" data-lang="java"><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">// 实现斐波那契数列
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">// 普通递归
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span> <span style="color:#ff7b72">int</span> <span style="color:#d2a8ff;font-weight:700">FibonacciRecursive</span><span style="color:#ff7b72;font-weight:700">(</span><span style="color:#ff7b72">int</span> n<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>     <span style="color:#ff7b72">if</span><span style="color:#ff7b72;font-weight:700">(</span> n <span style="color:#ff7b72;font-weight:700">&lt;</span> <span style="color:#a5d6ff">2</span><span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>         <span style="color:#ff7b72">return</span> n<span style="color:#ff7b72;font-weight:700">;</span>
</span></span><span style="display:flex"><span>     <span style="color:#ff7b72">return</span> FibonacciRecursive<span style="color:#ff7b72;font-weight:700">(</span>n<span style="color:#ff7b72;font-weight:700">-</span><span style="color:#a5d6ff">1</span><span style="color:#ff7b72;font-weight:700">)+</span>FibonacciRecursive<span style="color:#ff7b72;font-weight:700">(</span>n<span style="color:#ff7b72;font-weight:700">-</span><span style="color:#a5d6ff">2</span><span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span> <span style="color:#ff7b72;font-weight:700">}</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span> <span style="color:#8b949e;font-style:italic">// 尾递归
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#ff7b72">int</span> <span style="color:#d2a8ff;font-weight:700">FibonacciTailRecursive</span><span style="color:#ff7b72;font-weight:700">(</span><span style="color:#ff7b72">int</span> n<span style="color:#ff7b72;font-weight:700">,</span><span style="color:#ff7b72">int</span> ret1<span style="color:#ff7b72;font-weight:700">,</span><span style="color:#ff7b72">int</span> ret2<span style="color:#ff7b72;font-weight:700">)</span> <span style="color:#ff7b72;font-weight:700">{</span>
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">if</span><span style="color:#ff7b72;font-weight:700">(</span>n<span style="color:#ff7b72;font-weight:700">==</span><span style="color:#a5d6ff">0</span><span style="color:#ff7b72;font-weight:700">)</span>
</span></span><span style="display:flex"><span>       <span style="color:#ff7b72">return</span> ret1<span style="color:#ff7b72;font-weight:700">;</span> 
</span></span><span style="display:flex"><span>     <span style="color:#ff7b72">return</span> FibonacciTailRecursive<span style="color:#ff7b72;font-weight:700">(</span>n<span style="color:#ff7b72;font-weight:700">-</span><span style="color:#a5d6ff">1</span><span style="color:#ff7b72;font-weight:700">,</span>ret2<span style="color:#ff7b72;font-weight:700">,</span>ret1<span style="color:#ff7b72;font-weight:700">+</span>ret2<span style="color:#ff7b72;font-weight:700">);</span>
</span></span><span style="display:flex"><span> <span style="color:#ff7b72;font-weight:700">}</span>
</span></span></code></pre></div><blockquote><p>来自: <a href="https://blog.csdn.net/mengxiangjia_linxi/article/details/78158819" rel="noopener" target="_blank">https://blog.csdn.net/mengxiangjia_linxi/article/details/78158819</a></p></blockquote><p>尾递归效率高的原理:</p><p>尾递归就是从最后开始计算, 每递归一次就算出相应的结果, 也就是说, 函数调用出现在调用者函数的尾部, 因为是尾部, 所以根本没有必要去保存任何局部变量. 直接让被调用的函数返回时越过调用者, 返回到调用者的调用者去。<strong>精髓：尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数 , 也不用开辟新的栈空间,直接用上一个栈</strong></p><p>尾递归优化得益于编译器的支持,恰巧<strong>java不支持尾递归优化</strong>,但是上面那种省栈省开销还是有的(应该吧).一般函数式语言都是支持的,比如scala</p><p>但是可以利用lambda的懒加载来实现尾递归优化,</p><blockquote><p>详情: <a href="https://www.cnblogs.com/invoker-/p/7723420.html#autoid-3-0-0" rel="noopener" target="_blank">https://www.cnblogs.com/invoker-/p/7723420.html#autoid-3-0-0</a></p></blockquote><h1 id="3-java中的cas和aqs">3. java中的CAS和AQS<a aria-hidden="true" class="anchor" hidden="" href="#3-java中的cas和aqs">#</a></h1><p>CAS : Conmpare And Swap (比较和交换) 是用于实现<strong>多线程同步的原子指令</strong>。 它将内存位置的内容与给(期望)定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 这是作为单个原子操作完成的。</p><p>AQS: 抽象队列同步器(AbstractQueuedSynchronizer) , 是用来<strong>构建锁或者其他同步组件的基础框架</strong>，它使用一个int成员表示同步状态，通过内部的FIFO队列来完成资源获取线程的排序工作。ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的，</p><blockquote><p><a href="https://blog.csdn.net/yanghan1222/article/details/80247844" rel="noopener" target="_blank">https://blog.csdn.net/yanghan1222/article/details/80247844</a></p><p><a href="https://www.jianshu.com/p/0f876ead2846" rel="noopener" target="_blank">https://www.jianshu.com/p/0f876ead2846</a></p><p><a href="https://www.cnblogs.com/fsmly/p/11274572.html" rel="noopener" target="_blank">https://www.cnblogs.com/fsmly/p/11274572.html</a></p></blockquote><h2 id="31-cas-的三大问题">3.1 CAS 的三大问题<a aria-hidden="true" class="anchor" hidden="" href="#31-cas-的三大问题">#</a></h2><p>尽管 CAS 提供了一种有效的同步手段，但也存在一些问题，主要有以下三个：ABA 问题、长时间自旋、多个共享变量的原子操作。</p><p><strong>1. ABA 问题</strong></p><p>所谓的 ABA 问题，就是一个值原来是 A，变成了 B，又变回了 A。这个时候使用 CAS 是检查不出变化的，但实际上却被更新了两次。</p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。从 JDK 1.5 开始，JDK 的 atomic 包里提供了一个类<code>AtomicStampedReference</code>类来解决 ABA 问题。</p><p><strong>2. 长时间自旋</strong>
CAS 多与自旋结合。如果自旋 CAS 长时间不成功，会占用大量的 CPU 资源。</p><p>解决思路是让 JVM 支持处理器提供的pause 指令。</p><p>pause 指令能让自旋失败时 cpu 睡眠一小段时间再继续自旋，从而使得读操作的频率降低很多，为解决内存顺序冲突而导致的 CPU 流水线重排的代价也会小很多。</p><p><strong>3. 多个共享变量的原子操作</strong></p><p>当对一个共享变量执行操作时，CAS 能够保证该变量的原子性。但是对于多个共享变量，CAS 就无法保证操作的原子性，</p><p>这时通常有两种做法：</p><ol><li>使用<code>AtomicReference</code>类保证对象之间的原子性，把多个变量放到一个对象里面进行 CAS 操作；</li><li>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</li></ol><p><a href="https://javabetter.cn/thread/cas.html#aba-%E9%97%AE%E9%A2%98" rel="noopener" target="_blank">一文彻底搞清楚Java实现CAS的原理 | 二哥的Java进阶之路 (javabetter.cn)</a></p><h1 id="4-jvm中的记忆集remembered-set是什么">4. jvm中的记忆集(Remembered Set)是什么?<a aria-hidden="true" class="anchor" hidden="" href="#4-jvm中的记忆集remembered-set是什么">#</a></h1><p>jvm的堆内存分为了 年轻代和老年代, 分别使用各自的垃圾回收器回收</p><p>如果年轻代中的对象引用了老年代的对象, 当youngGC时就不能只扫描年轻代, 还得扫描老年代看对象是否有引用, 这种情况下, 就会变成扫描整个堆 —– 称为 <strong>跨代引用假说</strong></p><p>所以jvm在年轻代中存了一个<strong>全局的数据结构, 称为记忆集</strong>. 这个结构把老年代划分成若干小块，<strong>标识出老年代的哪一块内存会存在跨代引用</strong>。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描</p><h1 id="5-运行时常量池和字符串常量池">5. 运行时常量池和字符串常量池<a aria-hidden="true" class="anchor" hidden="" href="#5-运行时常量池和字符串常量池">#</a></h1><h2 id="运行时常量池">运行时常量池<a aria-hidden="true" class="anchor" hidden="" href="#运行时常量池">#</a></h2><p>类文件中除了包含<strong>类的版本、字段、方法、接口</strong>等描述信息, 这些最开始都是保存在常量池中，他们都是静态信息,</p><p>当程序运行时被加载到内存后，这些符号才有对应的内存地址信息。这些常量一旦被转入内存就会变成<strong>运行时常量池</strong>。运行时常量池在方法区中。</p><blockquote><p>比如 <code>math.compute()</code> , 在代码中写的是字符串, 那具体怎么调用的呢?</p><p>compute()这个符号引用在运行时就会被转变为compute()方法具体代码在内存中的地址，主要通过对象头里的类型指针去转换直接引用。</p><p>compute()方法被加载到内存以后，就有了自己的地址，原来调用computer()方法的符号引用，现在就变成对compute()地址的直接引用，这个直接引用是存在对象头里的，通过指针来指向直接引用</p></blockquote><p>所以 <strong>运行时常量池 存的类和方法等一些描述信息, 用于程序调用执行</strong>, <strong>存在方法区中,</strong> jdk8后放入元空间了</p><h2 id="字符串常量池">字符串常量池<a aria-hidden="true" class="anchor" hidden="" href="#字符串常量池">#</a></h2><p><strong>字符串常量池存的是字符串信息</strong> , 存在于堆中 , 因为字符串用的多, 所以用个池单独存起来, 并实现值的复用</p><blockquote><p>比如:</p><div class="highlight"><pre style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-java" data-lang="java"><span style="display:flex"><span>String c <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">"abcdefg"</span>
</span></span><span style="display:flex"><span>String d <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">"abcdefg"</span>
</span></span></code></pre></div><p>c和d 都指向字符串常量池, 且为同一个内存地址,</p></blockquote><blockquote><p>jdk8后 静态成员变量也放在堆中了</p></blockquote><h2 id="两个池的存放位置">两个池的存放位置<a aria-hidden="true" class="anchor" hidden="" href="#两个池的存放位置">#</a></h2><p><img alt="img" loading="lazy" src="java%E5%9F%BA%E7%A1%80.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXlvbmcxOTky,size_16,color_FFFFFF,t_70.png"/></p><p><a href="https://juejin.cn/post/7058375922235211790#heading-0" rel="noopener" target="_blank">深刻理解运行时常量池、字符串常量池 - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/liuyong1992/article/details/113835447" rel="noopener" target="_blank">java的字符串存储在堆中还是常量池中_编码大神经的博客-CSDN博客</a></p><h1 id="6-java-虚拟线程">6. java 虚拟线程<a aria-hidden="true" class="anchor" hidden="" href="#6-java-虚拟线程">#</a></h1><p>虚拟线程（Virtual Thread-）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p><p>近几十年来，我们一直依靠上述多线程模型来解决 Java 中的并发编程问题。为了提高系统的吞吐量，我们必须不断增加线程的数量，但是机器的线程很昂贵，可用线程的数量是有限的。尽管我们使用各种线程池来最大限度地提高线程的成本效益，但在 CPU、网络或内存资源被耗尽之前，线程往往成为我们应用程序性能的瓶颈，无法释放硬件应具有的最大性能。</p><p>我们常见的Java线程与系统内核线程是一一对应的，系统内核线程调度器负责调度Java线程。</p><p><img alt="img" loading="lazy" src="java%E5%9F%BA%E7%A1%80.assets/2b71c4b71dbd4045bfa0ed24ae89d710.png"/></p><p>Java19 引入了虚拟线程。在 Java19 中，我们以前使用的线程称为平台线程，仍然与系统内核线程一一对应。大量 (M个) 的虚拟线程，运行在少量 (N个) 的平台线程上（与 OS 线程一一对应）（M:N 调度）。JVM调度多个虚拟线程在特定平台线程上执行，并且在平台线程上一次只执行一个虚拟线程。</p><p><img alt="img" loading="lazy" src="java%E5%9F%BA%E7%A1%80.assets/824e418235d049d0b6bd7c7ed437dc2e.png"/></p><blockquote><ol><li>直接用虚拟线程池代替线程池。如果您的项目使用<code>CompletableFuture</code>，您也可以直接将执行异步任务的线程池替换为<code>Executors.newVirtualThreadPerTaskExecutor()</code>.</li><li>消除池化机制。虚拟线程非常轻量级，不需要池化。</li><li>synchronized更改为ReentrantLock减少固定到平台线程的虚拟线程。</li></ol></blockquote><p><a href="https://blog.csdn.net/lewyu521/article/details/127649776" rel="noopener" target="_blank">Java19 虚拟线程原理介绍及实现_lew-yu的博客-CSDN博客</a></p><p><a href="https://javaguide.cn/java/new-features/java19.html#jep-424-%e5%a4%96%e9%83%a8%e5%87%bd%e6%95%b0%e5%92%8c%e5%86%85%e5%ad%98-api-%e9%a2%84%e8%a7%88" rel="noopener" target="_blank">Java 19 新特性概览 | JavaGuide</a></p></div><footer class="post-footer"><ul class="post-tags"><li><a href="https://xiaokunji.com/zh/tags/java.html">java</a></li><li><a href="https://xiaokunji.com/zh/tags/%E7%BB%BC%E5%90%88.html">综合</a></li></ul><nav class="paginav"><a class="prev" href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95.html"><span class="title">« 上一页</span><br/><span>java常见面试题</span></a>
<a class="next" href="https://xiaokunji.com/zh/java%E5%8F%8A%E5%85%B6%E6%A1%86%E6%9E%B6/springBoot/jpa.html"><span class="title">下一页 »</span><br/><span>jpa</span></a></nav></footer></article></main><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><footer class="footer"><span>Copyright
©
-2024
<a href="https://xiaokunji.com/zh/" style="color:#939393">米二</a>
All Rights Reserved</span>
<span id="busuanzi_container"><span class="fa fa-user">用户数:</span><span id="busuanzi_value_site_uv"></span>
<span class="fa fa-eye">访问数:</span><span id="busuanzi_value_site_pv"></span></span></footer><a accesskey="g" aria-label="go to top" class="top-link" href="#top" id="top-link" title="Go to Top (Alt + G)"><svg fill="currentcolor" viewbox="0 0 12 6" xmlns="http://www.w3.org/2000/svg"><path d="M12 6H0l6-6z"></path></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>