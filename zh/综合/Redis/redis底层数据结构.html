<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>redis底层数据结构 | 米二</title><meta name=keywords content=" 前言, 1. redis的底层数据结构, 1.1 SDS（Simple Dynamic String）简单字符串, 1.2 链表 (list), 1.3 跳跃表（skiplist）, 1.4 压缩列表（ziplist）, 1.5 字典(dict), 哈希表, 哈希冲突, 扩容与缩容, 渐进式 hash, 原理, 小应用, 2. Redis五种基本数据类型, redisObject对象, 2.1 String类型, 2.2 List类型, 2.3 Set类型, 2.4 ZSet类型, 2.5 Hash类型"><meta name=description content="redis底层数据结构介绍及原理"><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html><link crossorigin=anonymous href=/assets/css/stylesheet.b3faf608c544858ba700943ffe182cb647f38432d29a07d73234965beacb26f6.css integrity="sha256-s/r2CMVEhYunAJQ//hgstkfzhDLSmgfXMjSWW+rLJvY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.com/img/Q.svg><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.com/img/Q.svg><link rel=apple-touch-icon href=https://xiaokunji.com/Q.svg><link rel=mask-icon href=https://xiaokunji.com/Q.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="redis底层数据结构"><meta property="og:description" content="redis底层数据结构介绍及原理"><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><meta property="article:section" content="综合"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-04T06:04:26+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="redis底层数据结构"><meta name=twitter:description content="redis底层数据结构介绍及原理"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"redis底层数据结构","item":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"redis底层数据结构","name":"redis底层数据结构","description":"redis底层数据结构介绍及原理","keywords":[" 前言"," 1. redis的底层数据结构"," 1.1 SDS（Simple Dynamic String）简单字符串"," 1.2 链表 (list)"," 1.3 跳跃表（skiplist）"," 1.4 压缩列表（ziplist）"," 1.5 字典(dict)"," 哈希表"," 哈希冲突"," 扩容与缩容"," 渐进式 hash"," 原理"," 小应用"," 2. Redis五种基本数据类型"," redisObject对象"," 2.1 String类型"," 2.2 List类型"," 2.3 Set类型"," 2.4 ZSet类型"," 2.5 Hash类型"],"articleBody":"[toc]\n前言 Redis目前基本的数据类型有String、List、Set、ZSet、Hash五种，首先Redis是C语言开发的，所以底层就是用C语言封装数据结构或者C语言本身提供的数据结构来存储。\nredis内部的主要数据结构主要有简单字符串（SDS）、双端链表、字典、压缩列表、跳跃表、整数集合。\nRedis内部并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统-redisObject，这个对象系统包含了我们所熟知的五种基本类型数据，也就是字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象。redisObject 是 Redis 类型系统的核心, 数据库中的每个键、值, 以及 Redis 本身处理的参数, 都表示为这种数据类型。\n而它们每一种对象都使用到了至少一种前面所介绍的数据结构。下面介绍一下redis内部的主要几个数据结构简单字符串（SDS）、双端链表、压缩列表、跳跃表的定义。然后再介绍一下redis基本的五种数据类型，也就是五种类型的对象用到了上面的哪些数据结构。\nRedis相关知识—-对象机制_小舟~的博客-CSDN博客 1. redis的底层数据结构 1.1 SDS（Simple Dynamic String）简单字符串 1、redis定义：\n//定义了一个char 指针 typedef char *sds; /* Note: sdshdr5 is never used, we just access the flags byte directly. *\tsdshdr5 已经不用了, 在处理时会自动转为 sdshdr8 * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 前 3 位保存类型，后 5 位保存字符串长度 */ char buf[]; }; //lsb 代表有效位的意思， //__attribute__ ((__packed__)) 代表structure 采用手动对齐的方式。 struct __attribute__ ((__packed__)) sdshdr8 { //buf 已经使用的长度 uint8_t len; /* used */ //buf 分配的长度，等于buf[]的总长度-1，因为buf有包括一个/0的结束符 uint8_t alloc; /* excluding the header and null terminator */ //只有3位有效位，因为类型的表示就是0到4，所有这个8位的flags 有5位没有被用到 unsigned char flags; /* 3 lsb of type, 5 unused bits */ //实际的字符串存在这里 char buf[]; }; // 还定义了其他长度的类型, 与上面的变化只有len和alloc， 就是长度不同而已 struct __attribute__ ((__packed__)) sdshdr16 { }; struct __attribute__ ((__packed__)) sdshdr32 { }; struct __attribute__ ((__packed__)) sdshdr64 { }; 这么多类型, 是为了针对不同的数据大小, 因为统一用int的话, 就占太多空间了(int 是 4字节)\nflags字段用来表示 是sdshdr8类型还是其他类型, 因为总共定义了5种类型, 所以需要8bit , ( 2^2 \u003c 5 \u003c 2^3 )\n2、使用范围：在redis里面，C本身的字符串只会作为字符串字面量（String literal）只用在一些不必对字符串值修改的地方，比如打印日志。 而redis需要使用字符串存储并且会修改的地方，都使用了SDS来存储。例如Key/vaule值。\n**3、优点：**使用SDS来存储字符串的优点：\nSDS的len属性直接记录了长度，获取字符串长度的复杂度为O(1)。\nC字符串本身不记录长度容易产生缓存区溢出，而SDS杜绝了缓冲区的溢出。\nC字符串本身不记录长度，每次修改都要重新分配内存，SDS减少了重新分配内存次数。\n因为有alloc字段, 可以预先分配内存\n优化了字符串缩短操作。并且可以保存任意格式的二进制数据，而C字符串必须含有编码。\nc语言中, 字符串是用 表示文本结尾的, 而二进制压缩后是会出现的 , SDS是利用len字段来表示真实的数据有多长, 按长度取值\nredis sds - 知乎 (zhihu.com) 读书笔记：Redis设计之动态字符串SDS - Jefferywang的烂笔头 (wangjunfeng.com) redis 系列，要懂redis，首先得看懂sds c++基础之uint8_t_时光机ﾟ的博客-CSDN博客_uint8_t Redis 源码解析 3：字符串 SDS - 小新是也 - 博客园 (cnblogs.com) 1.2 链表 (list) **1、链表：**listNode结构来保存，多个listNode可以形成双向链表，redis定义了list表示头节点来持有链表，下图分别是节点listNode和链表list的定义。\n2、redis定义：\n节点listNode 链表list **3、使用范围：**链表在redis中用作了列表键、发布与订阅、慢查询、监视器等\n1.3 跳跃表（skiplist） 1、跳跃表： 是一种有序得数据结构，通过在每个节点上维持多个指向其他节点的指针，从而达到快速访问的目的，可以理解为改进版的双端链表，改进的手段是通过空间换取了时间。\n在 Redis 中跳表是有序集合（zset）的底层实现之一。\n功能一：zset支持快速插入和删除\n对应的解决思路：针对快速插入和删除，有没有想到什么？首选肯定是链表，所以，底层基础得有一个value和score组成的node连接起来的链表。\n功能二：zset有序且支持范围查询\n对应的解决思路：有序这个条件，我们可以先让链表按照顺序排列，但查找来说，链表的查询时间复杂度为O(n)，并不高效，还要满足范围查找，如何解决这个问题？那么这时候就想到，能不能给链表做一个索引，提高它的查找效率的同时，让它也能支持范围查找，构建索引的话，是为了提高效率，如果只构建一层索引，数据量小的时候无所谓，但数据量大的时候呢？好像无法起到根本上提升效率的作用，所以应该给链表添加多级索引，简单示意图如下所示（引用自极客时间王争）：\n跳表结构:\n数据结构之Redis-跳表 - 简书 (jianshu.com) Redis 学习笔记（篇三）：跳表 - 风中抚雪 - 博客园 (cnblogs.com) 2、复杂度： 跳跃表支持平均O(logN)、最坏O(N)的查找复杂度，大部分条件下，跳跃表的效率可以和平衡树媲美，并且实现比平衡树简单。\n跳跃表节点zskiplistNode 跳跃表zskiplist 3、跳跃表结构图： 仔细观察上图跳跃表的结构后，发现如果节点的层数越高，那么这个节点访问其他节点的速度就越快。换言之，level越高，代表了这个跳跃表的查找效率可能会比较高。当然并不是绝对的，因为redis每次创建跳跃表节点时，程序是根据幂次定律(越大的数出现概率越小)， 生成层数高度。同时，节点的顺序是根据每个节点的分值排序的，如果分值相同，那么根据对象的大小排序。\n1.4 压缩列表（ziplist） 1、压缩列表： 是redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表的可以包含多个节点，每个节点可以保存一个字节数组或者一个整数值。\n2、压缩列表结构图： 3、压缩列表特点：\n是一种为节省内存开发的顺序性数据结构 可以包含多个节点，每个节点保存一个字节数组或者整数值 添加新节点到压缩列表，或者从压缩列表删除节点，可能会引发连锁更新操作，但是机率不高 1.5 字典(dict) dict（字典） 是 Redis 中哈希键和有序集合键的底层实现之一。\n可以看到图中，当我给一个 哈希结构中放了两个短的值，此时 哈希的编码方式是 ziplist, 而当我插入一个比较长的值，哈希的编码方式成为了 hashtable.\ntypedef struct dict{ // 类型特定函数 dictType *type; // 私有数据 void *private; // 哈希表 dictht ht[2]; // rehash 索引，当当前的字典不在 rehash 时，值为-1 int trehashidx; } type 和 private\n这两个属性是为了实现字典多态而设置的，当字典中存放着不同类型的值，对应的一些复制，比较函数也不一样，这两个属性配合起来可以实现多态的方法调用。\nht[2] 这是一个长度为 2 的 dictht结构的数组，dictht就是哈希表。\ntrehashidx 这是一个辅助变量，用于记录 rehash 过程的进度，以及是否正在进行 rehash 等信息。\n看完字段介绍，我们发现，字典这个数据结构，本质上是对 hashtable的一个简单封装，因此字典的实现细节主要就来到了 哈希表上。\n哈希表 哈希表的定义如下：\ntypedef struct dictht{ // 哈希表的数组 dictEntry **table; // 哈希表的大小 unsigned long size; // 哈希表的大小的掩码，用于计算索引值，总是等于 size-1 unsigned long sizemasky; // 哈希表中已有的节点数量 unsigned long used; } 其中哈希表中的节点的定义如下：\ntypedef struct dictEntry{ // 键 void *key; // 值 union { void *val; uint64_tu64; int64_ts64; }v; // 指向下一个节点的指针 struct dictEntry *next; } dictEntry; 上图是一个没有处在 rehash 状态下的字典。可以看到，字典持有两张哈希表，其中一个的值为 null, 另外一个哈希表的 size=4, 其中两个位置上已经存放了具体的键值对，而且没有发生 hash 冲突。\n哈希冲突 Redis 的哈希表处理 Hash 冲突的方式和 Java 中的 HashMap 一样，选择了分桶的方式，也就是常说的链地址法。Hash 表有两维，第一维度是个数组，第二维度是个链表，当发生了 Hash 冲突的时候，将冲突的节点使用链表连接起来，放在同一个桶内。\n由于第二维度是链表，我们都知道链表的查找效率相比于数组的查找效率是比较差的。那么如果 hash 冲突比较严重，导致单个链表过长，那么此时 hash 表的查询效率就会急速下降。\n因为有冲突所以需要扩容\n扩容与缩容 当哈希表过于拥挤，查找效率就会下降，当 hash 表过于稀疏，对内存就有点太浪费了，此时就需要进行相应的扩容与缩容操作。\n想要进行扩容缩容，那么就需要描述当前 hasd 表的一个填充程度，总不能靠感觉。这就有了 负载因子 这个概念。\n负载因子是用来描述哈希表当前被填充的程度。计算公式是：负载因子=哈希表以保存节点数量 / 哈希表的大小.\n在 Redis 的实现里，扩容缩容有三条规则：\n当 Redis 没有进行 BGSAVE 相关操作，且 负载因子\u003e1的时候进行扩容。\n负载因子\u003e5的时候，强行进行扩容。\n当负载因子\u003c0.1的时候，进行缩容。\n根据程序当前是否在进行 BGSAVE 相关操作，扩容需要的负载因子条件不相同。\n这是因为在进行 BGSAVE 操作时，存在子进程，操作系统会使用 写时复制 (Copy On Write) 来优化子进程的效率。Redis 尽量避免在存在子进程的时候进行扩容，尽量的节省内存。\n熟悉 hash 表的读者们应该知道，扩容期间涉及到到 rehash 的问题。\n因为需要将当前的所有节点挪到一个大小不一致的哈希表中，且需要尽量保持均匀，因此需要将当前哈希表中的所有节点，重新进行一次 hash. 也就是 rehash.\n渐进式 hash 原理 在 Java 的 HashMap 中，实现方式是 新建一个哈希表，一次性的将当前所有节点 rehash 完成，之后释放掉原有的 hash 表，而持有新的表。\n而 Redis 不是，Redis 使用了一种名为渐进式 hash 的方式来满足自己的性能需求。对于单线程的 Redis 来说，表示很难接受这样的延时，因此 Redis 选择使用 一点一点搬的策略。\nRedis 实现了渐进式 hash. 过程如下：\n假如当前数据在 ht[0] 中，那么首先为 ht[1] 分配足够的空间。 在字典中维护一个变量，rehashindex = 0. 用来指示当前 rehash 的进度。 在 rehash 期间，每次对 字典进行 增删改查操作，在完成实际操作之后，都会进行 一次 rehash 操作，将 ht[0] 在rehashindex 位置上的值 rehash 到 ht[1] 上。将 rehashindex 递增一位。 随着不断的执行，原来的 ht[0] 上的数值总会全部 rehash 完成，此时结束 rehash 过程。 将 rehashindex 置为-1. 在上面的过程中有两个问题没有提到：\n假如这个服务器很空余呢？中间几小时都没有请求进来，那么同时保持两个 table, 岂不是很浪费内存？ 解决办法是：在 redis 的定时函数里，也加入帮助 rehash 的操作，这样子如果服务器空闲，就会比较快的完成 rehash.\n迁移时不是一个一个的移动, 而是按hash桶的维度, 一次一百个的移动\n在保持两个 table 期间，该哈希表怎么对外提供服务呢？ 解决办法：对于添加操作，直接添加到 ht[1] 上，因此这样才能保证 ht[0] 的数量只会减少不会增加，才能保证 rehash 过程可以完结。而删除，修改，查询等操作会在 ht[0] 上进行，如果得不到结果，会去 ht[1] 再执行一遍。\n与此同时，渐进式 hash 也带来了一个问题，那就是 在 rehash 的时间内，需要保存两个 hash 表，对内存的占用稍大，而且如果在 redis 服务器本来内存满了的时候，突然进行 rehash 会造成大量的 key 被抛弃。\n小应用 假设有两张表，一张工作量表，一张积分表，积分=工作量*系数。 系数是有可能改变的，当系数发生变化之后，需要重新计算所有过往工作量的对应新系数的积分情况。 而工作量表的数据量比较大，如果在系数发生变化的一瞬间开始重新计算，可以会导致系统卡死，或者系统负载上升，影响到在线服务。 怎么解决这个问题？\n我们只需要额外记录一个标志着正在进行重新计算过程中的变量即可。之后的思路就完全和 Redis 一致了。\n首先我们可以在某个用户请求自己的积分的时候，再帮他计算新的积分。来分散系统压力。 如果系统压力并不大，可以在系统定时任务里重算一小部分（一个 batch), 具体多少可以由数据量决定。 2. Redis五种基本数据类型 上面提到过，redis并没有使用上面的数据结构直接用来实现键值对数据库，也就是常说的五种基本数据类型，而是创建了一个对象系统，这个系统包含了字符串对象，列表对象、哈希对象、集合对象、和有序集合对象这五种基本数据类型。这样做有一个好处是，我们可以针对不同的场景，对相同的数据类型对象使用不同的数据结构，来优化提高效率\n也就是说每种基本类型都是使用好几种对象来实现的\nredisObject对象 1、对象： redis的键值对都是一个redisObject结构，该结构中有三个属性，type类型属性、encoding编码属性、ptr指向底层数据结构属性。\nredisObject对象定义 数据库的key值都是一个string字符串对象 2、编码常量： 2.1 String类型 字符串对象的编码是int、raw、embstr。参考上面的编码常量表，也就是说字符串类型的数据底层的数据结构使用的是整数、SDS、embstr编码的SDS。\n1、编码转换\n即上述几种编码会在何时转换，也就是redis底层决定用什么存储字符串数据？。\n当int类型的编码通过操作存储的是字符串值，那么字符串对象的编码将从int变为raw。\n2.2 List类型 列表对象的编码可以是zipList压缩列表和linkedlist双端链表。\n1、编码转换\n即上述两种编码会在何时转换，也就是redis底层什么时候会用压缩列表存储列表数据？什么时候会使用双端链表存储列表数据。 当列表同时满足以下两个条件时，列表对象会使用zipList编码，也就是压缩列表\n列表对象保存的所有字符串元素的长度都小于64字节 列表保存的元素少于512个， 2、配置\n上述两个条件是支持配置的，也就是说我们可以redis直接读取我们的配置，来决定列表list类型底层使用什么样的数据结构来存储数据\nlist-max-ziplist-value list-max-ziplist-entries 2.3 Set类型 集合对象使用的是intset整数集合(intset底层使用的是整数集合数据结构)或者hashtable哈希表（hashtable底层使用的是字典数据结构）\n1、编码转换\n当集合对象同时满足下面两个条件，会使用intset编码\n集合对象保存的所有对象都是整数值 集合对象保存的元素数量小于512个； 2、配置\n上述第二个条件是支持配置的。\nset-max-intset-entries 2.4 ZSet类型 有序集合的编码使用的是ziplist压缩列表和skiplist跳跃表。\n**注意：**上面介绍skiplist的时候我们可以从结构图中明显看到存储集合元素的时候，score在每个节点中式如何存储的。那么如果ZSet使用的式ziplist压缩列表，redis怎么存储score和value值呢？其实很简单，每个集合的元素都使用两个节点来存储，第一个节点保存的是成员（member），第二个元素保存的是元素的分值（score）\n1、编码转换\n当有序集合对象可以同时满足以下两个条件时，使用ziplist编码\n有序集合的所有元素长度都小于64字节 有序集合的元素数量小于128个； 2、配置\n上述两个条件是支持配置的。\nzset-max-ziplist-value zset-max-ziplist-entries 2.5 Hash类型 哈希对象使用的是ziplist压缩列表或hashtable哈希表。（hashtable底层使用的是字典数据结构，我们并没有在本文做详细介绍，有需要可以自己了解）\n1、编码转换\n当哈希对象同时满足下面两个条件，使用ziplist压缩列表\n哈希对象保存的所有键值对的键和值的字符串长度都小于64字节 哈希对象保存的键值对的数量小于512个； 2、配置\n上述两个条件是支持配置的。\nhash-max-ziplist-value hash-max-ziplist-entries Redis基本数据类型底层数据结构 - coffeebabe - 博客园 (cnblogs.com) ","wordCount":"6131","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-09-04T06:04:26.028168781Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.com/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.com/img/Q.svg alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.com/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.com/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.com/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.com/zh/post.html title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.com/zh/archives.html title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.com/zh/tags.html title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.com/zh/categories.html title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.com/zh/links.html title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.com/zh/>🏠</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88.html>综合</a> <span>></span>
<a href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis.html>Redis</a> <span>></span></ul></nav><h1 class=post-title>redis底层数据结构</h1><div class=post-description>redis底层数据结构介绍及原理</div><div class=post-meta>创建:&nbsp;<span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;更新:&nbsp;2023-09-04&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.com/zh/categories/%E7%BB%BC%E5%90%88.html>综合</a></ul><span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv>1</span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#1-redis%e7%9a%84%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="1. redis的底层数据结构">1. redis的底层数据结构</a><ul><li><a href=#11-sdssimple-dynamic-string%e7%ae%80%e5%8d%95%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label="1.1 SDS（Simple Dynamic String）简单字符串">1.1 SDS（Simple Dynamic String）简单字符串</a></li><li><a href=#12-%e9%93%be%e8%a1%a8-list aria-label="1.2 链表 (list)">1.2 链表 (list)</a></li><li><a href=#13-%e8%b7%b3%e8%b7%83%e8%a1%a8skiplist aria-label="1.3 跳跃表（skiplist）">1.3 跳跃表（skiplist）</a></li><li><a href=#14-%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8ziplist aria-label="1.4 压缩列表（ziplist）">1.4 压缩列表（ziplist）</a></li><li><a href=#15-%e5%ad%97%e5%85%b8dict aria-label="1.5 字典(dict)">1.5 字典(dict)</a><ul><li><a href=#%e5%93%88%e5%b8%8c%e8%a1%a8 aria-label=哈希表>哈希表</a></li><li><a href=#%e5%93%88%e5%b8%8c%e5%86%b2%e7%aa%81 aria-label=哈希冲突>哈希冲突</a></li><li><a href=#%e6%89%a9%e5%ae%b9%e4%b8%8e%e7%bc%a9%e5%ae%b9 aria-label=扩容与缩容>扩容与缩容</a></li><li><a href=#%e6%b8%90%e8%bf%9b%e5%bc%8f-hash aria-label="渐进式 hash">渐进式 hash</a><ul><li><a href=#%e5%8e%9f%e7%90%86 aria-label=原理>原理</a></li><li><a href=#%e5%b0%8f%e5%ba%94%e7%94%a8 aria-label=小应用>小应用</a></li></ul></li></ul></li></ul></li><li><a href=#2-redis%e4%ba%94%e7%a7%8d%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label="2. Redis五种基本数据类型">2. Redis五种基本数据类型</a><ul><ul><li><a href=#redisobject%e5%af%b9%e8%b1%a1 aria-label=redisObject对象>redisObject对象</a></li></ul><li><a href=#21-string%e7%b1%bb%e5%9e%8b aria-label="2.1 String类型">2.1 String类型</a></li><li><a href=#22-list%e7%b1%bb%e5%9e%8b aria-label="2.2 List类型">2.2 List类型</a></li><li><a href=#23-set%e7%b1%bb%e5%9e%8b aria-label="2.3 Set类型">2.3 Set类型</a></li><li><a href=#24-zset%e7%b1%bb%e5%9e%8b aria-label="2.4 ZSet类型">2.4 ZSet类型</a></li><li><a href=#25-hash%e7%b1%bb%e5%9e%8b aria-label="2.5 Hash类型">2.5 Hash类型</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h1><p>Redis目前基本的数据类型有String、List、Set、ZSet、Hash五种，首先Redis是C语言开发的，所以底层就是用C语言封装数据结构或者C语言本身提供的数据结构来存储。</p><p>redis内部的主要数据结构主要有<strong>简单字符串（SDS）、双端链表、字典、压缩列表、跳跃表、整数集合</strong>。</p><p>Redis内部<strong>并没有直接使用这些数据结构</strong>来实现键值对数据库，而是基于这些数据结构创建了一个对象系统-redisObject，这个<strong>对象系统</strong>包含了我们所熟知的五种基本类型数据，也就是<strong>字符串对象、列表对象、哈希对象、集合对象和有序集合对象</strong>这五种类型的对象。redisObject 是 Redis 类型系统的核心, 数据库中的每个键、值, 以及 Redis 本身处理的参数, 都表示为这种数据类型。</p><p>而它们每一种对象都使用到了至少一种前面所介绍的数据结构。下面介绍一下redis内部的主要几个数据结构<strong>简单字符串（SDS）、双端链表、压缩列表、跳跃表</strong>的定义。然后再介绍一下redis基本的五种数据类型，也就是五种类型的对象用到了上面的哪些数据结构。</p><p><img loading=lazy src=./redis%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84.assets/image-20220727113350889.png alt=image-20220727113350889></p><p><a href=https://blog.csdn.net/CarrotZsy/article/details/115964515 target=_blank rel=noopener>Redis相关知识&mdash;-对象机制_小舟~的博客-CSDN博客</a></p><h1 id=1-redis的底层数据结构>1. redis的底层数据结构<a hidden class=anchor aria-hidden=true href=#1-redis的底层数据结构>#</a></h1><h2 id=11-sdssimple-dynamic-string简单字符串>1.1 SDS（Simple Dynamic String）简单字符串<a hidden class=anchor aria-hidden=true href=#11-sdssimple-dynamic-string简单字符串>#</a></h2><p><strong>1、redis定义：</strong></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8b949e;font-style:italic>//定义了一个char 指针
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>typedef</span> <span style=color:#ff7b72>char</span> <span style=color:#ff7b72;font-weight:700>*</span>sds;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>/* Note: sdshdr5 is never used, we just access the flags byte directly.
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> *	sdshdr5 已经不用了, 在处理时会自动转为 sdshdr8
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic> * However is here to document the layout of type 5 SDS strings. */</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> <span style=color:#d2a8ff;font-weight:700>__attribute__</span> ((__packed__)) sdshdr5 {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>char</span> flags; <span style=color:#8b949e;font-style:italic>/* 前 3 位保存类型，后 5 位保存字符串长度 */</span>
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>char</span> buf[];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>//lsb 代表有效位的意思，
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>//__attribute__ ((__packed__)) 代表structure 采用手动对齐的方式。
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>struct</span> <span style=color:#d2a8ff;font-weight:700>__attribute__</span> ((__packed__)) sdshdr8 {
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>//buf 已经使用的长度
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>uint8_t</span> len; <span style=color:#8b949e;font-style:italic>/* used */</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>//buf 分配的长度，等于buf[]的总长度-1，因为buf有包括一个/0的结束符
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>uint8_t</span> alloc; <span style=color:#8b949e;font-style:italic>/* excluding the header and null terminator */</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>//只有3位有效位，因为类型的表示就是0到4，所有这个8位的flags 有5位没有被用到
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>char</span> flags; <span style=color:#8b949e;font-style:italic>/* 3 lsb of type, 5 unused bits */</span>
</span></span><span style=display:flex><span>    <span style=color:#8b949e;font-style:italic>//实际的字符串存在这里
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>    <span style=color:#ff7b72>char</span> buf[];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic>// 还定义了其他长度的类型, 与上面的变化只有len和alloc， 就是长度不同而已
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span><span style=color:#ff7b72>struct</span> <span style=color:#d2a8ff;font-weight:700>__attribute__</span> ((__packed__)) sdshdr16 {
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> <span style=color:#d2a8ff;font-weight:700>__attribute__</span> ((__packed__)) sdshdr32 {
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#ff7b72>struct</span> <span style=color:#d2a8ff;font-weight:700>__attribute__</span> ((__packed__)) sdshdr64 {
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><blockquote><p>这么多类型, 是为了针对不同的数据大小, 因为统一用int的话, 就占太多空间了(int 是 4字节)</p><p>flags字段用来表示 是sdshdr8类型还是其他类型, 因为总共定义了5种类型, 所以需要8bit , ( 2^2 &lt; 5 &lt; 2^3 )</p></blockquote><p><strong>2、使用范围：<strong>在redis里面，C本身的字符串只会作为字符串字面量（String literal）只用在一些不必对字符串值修改的地方，比如打印日志。
而redis需要</strong>使用字符串存储</strong>并且会修改的地方，都使用了SDS来存储。例如Key/vaule值。</p><p>**3、优点：**使用SDS来存储字符串的优点：</p><ul><li><p>SDS的len属性直接<strong>记录了长度</strong>，获取字符串长度的复杂度为O(1)。</p></li><li><p>C字符串本身不记录长度容易产生缓存区溢出，而SDS杜绝了缓冲区的溢出。</p></li><li><p>C字符串本身不记录长度，每次修改都要重新分配内存，SDS减少了重新分配内存次数。</p><blockquote><p>因为有alloc字段, 可以预先分配内存</p></blockquote></li><li><p>优化了字符串缩短操作。并且可以保存任意格式的二进制数据，而C字符串必须含有编码。</p><blockquote><p>c语言中, 字符串是用 <code>表示文本结尾的, 而二进制压缩后是会出现</code>的 , SDS是利用len字段来表示真实的数据有多长, 按长度取值</p></blockquote></li></ul><p><a href=https://zhuanlan.zhihu.com/p/51075839 target=_blank rel=noopener>redis sds - 知乎 (zhihu.com)</a></p><p><a href=https://blog.wangjunfeng.com/post/redis-sds/ target=_blank rel=noopener>读书笔记：Redis设计之动态字符串SDS - Jefferywang的烂笔头 (wangjunfeng.com)</a></p><p><a href=https://blog.csdn.net/qq_33361976/article/details/109014012 target=_blank rel=noopener>redis 系列，要懂redis，首先得看懂sds</a></p><p><a href=https://blog.csdn.net/qq_19784349/article/details/82927169 target=_blank rel=noopener>c++基础之uint8_t_时光机ﾟ的博客-CSDN博客_uint8_t</a></p><p><a href=https://www.cnblogs.com/chenchuxin/p/14189925.html target=_blank rel=noopener>Redis 源码解析 3：字符串 SDS - 小新是也 - 博客园 (cnblogs.com)</a></p><h2 id=12-链表-list>1.2 链表 (list)<a hidden class=anchor aria-hidden=true href=#12-链表-list>#</a></h2><p>**1、链表：**listNode结构来保存，多个listNode可以形成双向链表，redis定义了list表示头节点来持有链表，下图分别是节点listNode和链表list的定义。</p><p><strong>2、redis定义：</strong></p><ul><li>节点listNode
<img loading=lazy src=redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/1920418-20211129214051851-513048661.png alt=节点定义></li><li>链表list
<img loading=lazy src=redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/1920418-20211129214158701-1742155843.png alt=链表定义></li></ul><p>**3、使用范围：**链表在redis中用作了列表键、发布与订阅、慢查询、监视器等</p><h2 id=13-跳跃表skiplist>1.3 跳跃表（skiplist）<a hidden class=anchor aria-hidden=true href=#13-跳跃表skiplist>#</a></h2><p><strong>1、跳跃表：</strong> 是一种有序得数据结构，通过在每个节点上维持多个指向其他节点的指针，从而达到快速访问的目的，可以理解为改进版的双端链表，改进的手段是通过空间换取了时间。</p><p>在 Redis 中跳表是有序集合（zset）的底层实现之一。</p><p><strong>功能一</strong>：zset支持快速插入和删除</p><blockquote><p>对应的解决思路：针对快速插入和删除，有没有想到什么？首选肯定是链表，所以，底层基础得有一个value和score组成的node连接起来的链表。</p></blockquote><p><strong>功能二</strong>：zset有序且支持范围查询</p><blockquote><p>对应的解决思路：有序这个条件，我们可以先让链表按照顺序排列，但查找来说，链表的查询时间复杂度为O(n)，并不高效，还要满足范围查找，如何解决这个问题？那么这时候就想到，能不能给链表做一个索引，提高它的查找效率的同时，让它也能支持范围查找，构建索引的话，是为了提高效率，如果只构建一层索引，数据量小的时候无所谓，但数据量大的时候呢？好像无法起到根本上提升效率的作用，所以应该给链表添加多级索引，简单示意图如下所示（引用自极客时间王争）：</p></blockquote><p>跳表结构:</p><p><img loading=lazy src=redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/5868227-4e41548386d45484.webp alt=img></p><p><a href=https://www.jianshu.com/p/c706d050d2f8 target=_blank rel=noopener>数据结构之Redis-跳表 - 简书 (jianshu.com)</a></p><p><a href=https://www.cnblogs.com/wind-snow/p/11099505.html target=_blank rel=noopener>Redis 学习笔记（篇三）：跳表 - 风中抚雪 - 博客园 (cnblogs.com)</a></p><p><strong>2、复杂度：</strong> 跳跃表支持平均O(logN)、最坏O(N)的查找复杂度，大部分条件下，跳跃表的效率可以和平衡树媲美，并且实现比平衡树简单。</p><ul><li>跳跃表节点zskiplistNode
<img loading=lazy src=redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/1920418-20211201115851101-1231395542.png alt=跳跃表节点定义></li><li>跳跃表zskiplist
<img loading=lazy src=redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/1920418-20211201115937132-527198248.png alt=跳跃表定义></li></ul><p><strong>3、跳跃表结构图：</strong>
<img loading=lazy src=redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/1920418-20211201145329984-410463148.png alt=跳跃表结构图></p><p>仔细观察上图跳跃表的结构后，发现如果节点的层数越高，那么这个节点访问其他节点的速度就越快。换言之，level越高，代表了这个跳跃表的查找效率可能会比较高。当然并不是绝对的，因为redis每次创建跳跃表节点时，程序是根据幂次定律(越大的数出现概率越小)， 生成层数高度。同时，节点的顺序是根据每个节点的分值排序的，如果分值相同，那么根据对象的大小排序。</p><h2 id=14-压缩列表ziplist>1.4 压缩列表（ziplist）<a hidden class=anchor aria-hidden=true href=#14-压缩列表ziplist>#</a></h2><p><strong>1、压缩列表：</strong> 是redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表的可以包含多个节点，每个节点可以保存一个字节数组或者一个整数值。</p><p><strong>2、压缩列表结构图：</strong>
<img loading=lazy src=redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/1920418-20211201150430905-971662820.png alt=压缩列表结构图></p><p><strong>3、压缩列表特点：</strong></p><ul><li>是一种为节省内存开发的顺序性数据结构</li><li>可以包含多个节点，每个节点保存一个字节数组或者整数值</li><li>添加新节点到压缩列表，或者从压缩列表删除节点，可能会引发连锁更新操作，但是机率不高</li></ul><h2 id=15-字典dict>1.5 字典(dict)<a hidden class=anchor aria-hidden=true href=#15-字典dict>#</a></h2><p>dict（字典） 是 Redis 中哈希键和有序集合键的底层实现之一。</p><p>可以看到图中，当我给一个 哈希结构中放了两个短的值，此时 哈希的编码方式是 ziplist, 而当我插入一个比较长的值，哈希的编码方式成为了 hashtable.</p><p><img loading=lazy src=./redis%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84.assets/image-20220727145427750.png alt=image-20220727145427750></p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff7b72>typedef</span> <span style=color:#ff7b72>struct</span> dict{
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 类型特定函数
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  dictType <span style=color:#ff7b72;font-weight:700>*</span>type;
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 私有数据
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#ff7b72>void</span> <span style=color:#ff7b72;font-weight:700>*</span>private;
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 哈希表
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  dictht ht[<span style=color:#a5d6ff>2</span>];
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// rehash 索引，当当前的字典不在 rehash 时，值为-1
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#ff7b72>int</span> trehashidx;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>type 和 private</p><p>这两个属性是为了实现字典多态而设置的，当字典中存放着不同类型的值，对应的一些复制，比较函数也不一样，这两个属性配合起来可以实现多态的方法调用。</p></li><li><p>ht[2]
这是一个长度为 2 的 dictht结构的数组，dictht就是哈希表。</p></li><li><p>trehashidx
这是一个辅助变量，用于记录 rehash 过程的进度，以及是否正在进行 rehash 等信息。</p></li></ul><p>看完字段介绍，我们发现，字典这个数据结构，本质上是对 hashtable的一个简单封装，因此字典的实现细节主要就来到了 哈希表上。</p><h3 id=哈希表>哈希表<a hidden class=anchor aria-hidden=true href=#哈希表>#</a></h3><p>哈希表的定义如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff7b72>typedef</span> <span style=color:#ff7b72>struct</span> dictht{
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 哈希表的数组
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  dictEntry <span style=color:#ff7b72;font-weight:700>**</span>table;
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 哈希表的大小
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>long</span> size;
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 哈希表的大小的掩码，用于计算索引值，总是等于 size-1
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>long</span> sizemasky;
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 哈希表中已有的节点数量
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#ff7b72>unsigned</span> <span style=color:#ff7b72>long</span> used;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其中哈希表中的节点的定义如下：</p><div class=highlight><pre tabindex=0 style=color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff7b72>typedef</span> <span style=color:#ff7b72>struct</span> dictEntry{
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 键
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#ff7b72>void</span> <span style=color:#ff7b72;font-weight:700>*</span>key;
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 值
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#ff7b72>union</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff7b72>void</span> <span style=color:#ff7b72;font-weight:700>*</span>val;
</span></span><span style=display:flex><span>    uint64_tu64;
</span></span><span style=display:flex><span>    int64_ts64;
</span></span><span style=display:flex><span>  }v;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#8b949e;font-style:italic>// 指向下一个节点的指针
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic></span>  <span style=color:#ff7b72>struct</span> dictEntry <span style=color:#ff7b72;font-weight:700>*</span>next;
</span></span><span style=display:flex><span>} dictEntry;
</span></span></code></pre></div><p><img loading=lazy src=./redis%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84.assets/image-20220727145608599.png alt=image-20220727145608599></p><p>上图是一个没有处在 rehash 状态下的字典。可以看到，字典持有两张哈希表，其中一个的值为 null, 另外一个哈希表的 size=4, 其中两个位置上已经存放了具体的键值对，而且没有发生 hash 冲突。</p><h3 id=哈希冲突>哈希冲突<a hidden class=anchor aria-hidden=true href=#哈希冲突>#</a></h3><p>Redis 的哈希表处理 Hash 冲突的方式和 Java 中的 HashMap 一样，选择了分桶的方式，也就是常说的链地址法。Hash 表有两维，第一维度是个数组，第二维度是个链表，当发生了 Hash 冲突的时候，将冲突的节点使用链表连接起来，放在同一个桶内。</p><p>由于第二维度是链表，我们都知道链表的查找效率相比于数组的查找效率是比较差的。那么如果 hash 冲突比较严重，导致单个链表过长，那么此时 hash 表的查询效率就会急速下降。</p><p>因为有冲突所以需要扩容</p><h3 id=扩容与缩容>扩容与缩容<a hidden class=anchor aria-hidden=true href=#扩容与缩容>#</a></h3><p>当哈希表过于拥挤，查找效率就会下降，当 hash 表过于稀疏，对内存就有点太浪费了，此时就需要进行相应的扩容与缩容操作。</p><p>想要进行扩容缩容，那么就需要描述当前 hasd 表的一个填充程度，总不能靠感觉。这就有了 负载因子 这个概念。</p><p>负载因子是用来描述哈希表当前被填充的程度。计算公式是：<code>负载因子=哈希表以保存节点数量 / 哈希表的大小.</code></p><p>在 Redis 的实现里，扩容缩容有三条规则：</p><ul><li><p>当 Redis 没有进行 BGSAVE 相关操作，且 负载因子>1的时候进行扩容。</p></li><li><p>负载因子>5的时候，强行进行扩容。</p></li><li><p>当负载因子&lt;0.1的时候，进行缩容。</p><p>根据程序当前是否在进行 BGSAVE 相关操作，扩容需要的负载因子条件不相同。</p></li></ul><p>这是因为在进行 BGSAVE 操作时，存在子进程，操作系统会使用 写时复制 (Copy On Write) 来优化子进程的效率。Redis 尽量避免在存在子进程的时候进行扩容，尽量的节省内存。</p><p>熟悉 hash 表的读者们应该知道，扩容期间涉及到到 rehash 的问题。</p><p>因为需要将当前的所有节点挪到一个大小不一致的哈希表中，且需要尽量保持均匀，因此需要将当前哈希表中的所有节点，重新进行一次 hash. 也就是 rehash.</p><h3 id=渐进式-hash>渐进式 hash<a hidden class=anchor aria-hidden=true href=#渐进式-hash>#</a></h3><h4 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h4><p>在 Java 的 HashMap 中，实现方式是 新建一个哈希表，一次性的将当前所有节点 rehash 完成，之后释放掉原有的 hash 表，而持有新的表。</p><p>而 Redis 不是，Redis 使用了一种名为渐进式 hash 的方式来满足自己的性能需求。对于单线程的 Redis 来说，表示很难接受这样的延时，因此 Redis 选择使用 一点一点搬的策略。</p><p>Redis 实现了渐进式 hash. 过程如下：</p><ol><li>假如当前数据在 ht[0] 中，那么首先为 ht[1] 分配足够的空间。</li><li>在字典中维护一个变量，rehashindex = 0. 用来指示当前 rehash 的进度。</li><li>在 rehash 期间，每次对 字典进行 增删改查操作，在完成实际操作之后，都会进行 一次 rehash 操作，将 ht[0] 在rehashindex 位置上的值 rehash 到 ht[1] 上。将 rehashindex 递增一位。</li><li>随着不断的执行，原来的 ht[0] 上的数值总会全部 rehash 完成，此时结束 rehash 过程。 将 rehashindex 置为-1.</li></ol><p>在上面的过程中有两个问题没有提到：</p><ol><li><p>假如这个服务器很空余呢？中间几小时都没有请求进来，那么同时保持两个 table, 岂不是很浪费内存？
<strong>解决办法</strong>是：在 redis 的定时函数里，也加入帮助 rehash 的操作，这样子如果服务器空闲，就会比较快的完成 rehash.</p><blockquote><p>迁移时不是一个一个的移动, 而是按hash桶的维度, 一次一百个的移动</p></blockquote></li><li><p>在保持两个 table 期间，该哈希表怎么对外提供服务呢？
<strong>解决办法</strong>：对于添加操作，直接添加到 ht[1] 上，因此这样才能保证 ht[0] 的数量只会减少不会增加，才能保证 rehash 过程可以完结。而删除，修改，查询等操作会在 ht[0] 上进行，如果得不到结果，会去 ht[1] 再执行一遍。</p></li></ol><p>与此同时，渐进式 hash 也带来了一个问题，那就是 在 rehash 的时间内，需要保存两个 hash 表，对内存的占用稍大，而且如果在 redis 服务器本来内存满了的时候，突然进行 rehash 会造成大量的 key 被抛弃。</p><h4 id=小应用>小应用<a hidden class=anchor aria-hidden=true href=#小应用>#</a></h4><blockquote><p>假设有两张表，一张工作量表，一张积分表，积分=工作量*系数。
系数是有可能改变的，当系数发生变化之后，需要重新计算所有过往工作量的对应新系数的积分情况。
而工作量表的数据量比较大，如果在系数发生变化的一瞬间开始重新计算，可以会导致系统卡死，或者系统负载上升，影响到在线服务。
怎么解决这个问题？</p></blockquote><p>我们只需要额外记录一个标志着正在进行重新计算过程中的变量即可。之后的思路就完全和 Redis 一致了。</p><ol><li>首先我们可以在某个用户请求自己的积分的时候，再帮他计算新的积分。来分散系统压力。</li><li>如果系统压力并不大，可以在系统定时任务里重算一小部分（一个 batch), 具体多少可以由数据量决定。</li></ol><h1 id=2-redis五种基本数据类型>2. Redis五种基本数据类型<a hidden class=anchor aria-hidden=true href=#2-redis五种基本数据类型>#</a></h1><p>上面提到过，redis并没有使用上面的数据结构直接用来实现键值对数据库，也就是常说的五种基本数据类型，而是创建了一个对象系统，这个系统包含了字符串对象，列表对象、哈希对象、集合对象、和有序集合对象这五种基本数据类型。这样做有一个好处是，我们可以针对不同的场景，<u>对相同的数据类型对象使用不同的数据结构，来优化提高效率</u></p><blockquote><p>也就是说每种基本类型都是使用好几种对象来实现的</p></blockquote><h3 id=redisobject对象>redisObject对象<a hidden class=anchor aria-hidden=true href=#redisobject对象>#</a></h3><p><strong>1、对象：</strong> redis的键值对都是一个redisObject结构，该结构中有三个属性，type类型属性、encoding编码属性、ptr指向底层数据结构属性。</p><ul><li>redisObject对象定义</li></ul><p><img loading=lazy src=redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/1920418-20211201155615767-853819249.png alt=redisObject对象定义></p><p><img loading=lazy src=redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/1920418-20211201160239327-476423665.png alt=type属性></p><ul><li><strong>数据库的key值都是一个string字符串对象</strong></li></ul><p><strong>2、编码常量：</strong>
<img loading=lazy src=redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/1920418-20211201160854236-1536704434.png alt=image></p><h2 id=21-string类型>2.1 String类型<a hidden class=anchor aria-hidden=true href=#21-string类型>#</a></h2><p>字符串对象的编码是<strong>int、raw、embstr</strong>。参考上面的编码常量表，也就是说字符串类型的数据底层的数据结构使用的是<strong>整数、SDS、embstr编码</strong>的SDS。</p><p><strong>1、编码转换</strong></p><p>即上述几种编码会在何时转换，也就是redis底层决定用什么存储字符串数据？。</p><p>当int类型的编码通过操作存储的是字符串值，那么字符串对象的编码将从int变为raw。</p><h2 id=22-list类型>2.2 List类型<a hidden class=anchor aria-hidden=true href=#22-list类型>#</a></h2><p>列表对象的编码可以是<strong>zipList压缩列表</strong>和<strong>linkedlist双端链表</strong>。</p><p><strong>1、编码转换</strong></p><p>即上述两种编码会在何时转换，也就是redis底层什么时候会用压缩列表存储列表数据？什么时候会使用双端链表存储列表数据。
当列表同时满足以下两个条件时，列表对象会使用zipList编码，也就是压缩列表</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节</li><li>列表保存的元素少于512个，</li></ul><p><strong>2、配置</strong></p><p>上述两个条件是支持配置的，也就是说我们可以redis直接读取我们的配置，来决定列表list类型底层使用什么样的数据结构来存储数据</p><ul><li>list-max-ziplist-value</li><li>list-max-ziplist-entries</li></ul><h2 id=23-set类型>2.3 Set类型<a hidden class=anchor aria-hidden=true href=#23-set类型>#</a></h2><p>集合对象使用的是<strong>intset整数集合</strong>(intset底层使用的是整数集合数据结构)或者<strong>hashtable哈希表</strong>（hashtable底层使用的是字典数据结构）</p><p><strong>1、编码转换</strong></p><p>当集合对象同时满足下面两个条件，会使用intset编码</p><ul><li>集合对象保存的所有对象都是整数值</li><li>集合对象保存的元素数量小于512个；</li></ul><p><strong>2、配置</strong></p><p>上述第二个条件是支持配置的。</p><ul><li>set-max-intset-entries</li></ul><h2 id=24-zset类型>2.4 ZSet类型<a hidden class=anchor aria-hidden=true href=#24-zset类型>#</a></h2><p>有序集合的编码使用的是<strong>ziplist压缩列表</strong>和<strong>skiplist跳跃表</strong>。</p><p>**注意：**上面介绍skiplist的时候我们可以从结构图中明显看到存储集合元素的时候，score在每个节点中式如何存储的。那么如果ZSet使用的式ziplist压缩列表，redis怎么存储score和value值呢？其实很简单，每个集合的元素都使用两个节点来存储，第一个节点保存的是成员（member），第二个元素保存的是元素的分值（score）</p><p><strong>1、编码转换</strong></p><p>当有序集合对象可以同时满足以下两个条件时，使用ziplist编码</p><ul><li>有序集合的所有元素长度都小于64字节</li><li>有序集合的元素数量小于128个；</li></ul><p><strong>2、配置</strong></p><p>上述两个条件是支持配置的。</p><ul><li>zset-max-ziplist-value</li><li>zset-max-ziplist-entries</li></ul><h2 id=25-hash类型>2.5 Hash类型<a hidden class=anchor aria-hidden=true href=#25-hash类型>#</a></h2><p>哈希对象使用的是<strong>ziplist压缩列表</strong>或<strong>hashtable哈希表</strong>。（hashtable底层使用的是字典数据结构，我们并没有在本文做详细介绍，有需要可以自己了解）</p><p><strong>1、编码转换</strong></p><p>当哈希对象同时满足下面两个条件，使用ziplist压缩列表</p><ul><li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节</li><li>哈希对象保存的键值对的数量小于512个；</li></ul><p><strong>2、配置</strong></p><p>上述两个条件是支持配置的。</p><ul><li>hash-max-ziplist-value</li><li>hash-max-ziplist-entries</li></ul><p><a href=https://www.cnblogs.com/wa1l-E/p/15611261.html target=_blank rel=noopener>Redis基本数据类型底层数据结构 - coffeebabe - 博客园 (cnblogs.com)</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.com/zh/tags/Redis.html>Redis</a></li><li><a href=https://xiaokunji.com/zh/tags/%E7%BB%BC%E5%90%88.html>综合</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis/Redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5LRU%E4%B8%8ELFU.html><span class=title>« 上一页</span><br><span>Redis的淘汰策略LRU与LFU</span></a>
<a class=next href=https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/java/%E6%9E%B6%E6%9E%84/Saas%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9A%94%E7%A6%BB.html><span class=title>下一页 »</span><br><span>Saas的数据隔离</span></a></nav></footer></article></main><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.com/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>