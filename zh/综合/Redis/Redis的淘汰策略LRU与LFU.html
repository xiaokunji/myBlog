<!DOCTYPE html>
<html dir="auto" lang="zh"><head><meta charset="utf-8"/><meta content="IE=edge" http-equiv="x-ua-compatible"/><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name="viewport"/><meta content="index, follow" name="robots"/><title>Redis的淘汰策略LRU与LFU | 米二</title>
<meta content=" redis中的LRU实现,define LRU_BITS 24,define REDIS_LRU_BITS 24, redis中的LFU实现,  ldt(Last Decrement Time), logc(Logistic Counter), logc 算法调整, 扩展, 淘汰池的更新策略" name="keywords"/><meta content="     " name="description"/><meta content="xkj" name="author"/><link href="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis/Redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5LRU%E4%B8%8ELFU.html" rel="canonical"/><link as="style" crossorigin="anonymous" href="/assets/css/stylesheet.dc6bd2c841ee388e899e13872ae986c0e847e8b957d6714ad6ddc628ef2d17ff.css" integrity="sha256-3GvSyEHuOI6JnhOHKumGwOhH6LlX1nFK1t3GKO8tF/8=" rel="preload stylesheet"/><script crossorigin="anonymous" defer="" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload="hljs.initHighlightingOnLoad()" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js"></script><link href="https://xiaokunji.com/img/Q.svg" rel="icon"/><link href="https://xiaokunji.com/img/Q.svg" rel="icon" sizes="16x16" type="image/png"/><link href="https://xiaokunji.com/img/Q.svg" rel="icon" sizes="32x32" type="image/png"/><link href="https://xiaokunji.com/Q.svg" rel="apple-touch-icon"/><link href="https://xiaokunji.com/Q.svg" rel="mask-icon"/><meta content="#2e2e33" name="theme-color"/><meta content="#2e2e33" name="msapplication-TileColor"/><link href="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis/Redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5LRU%E4%B8%8ELFU.html" hreflang="zh" rel="alternate"/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta content="Redis的淘汰策略LRU与LFU" property="og:title"/><meta content="     " property="og:description"/><meta content="article" property="og:type"/><meta content="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis/Redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5LRU%E4%B8%8ELFU.html" property="og:url"/><meta content="综合" property="article:section"/><meta content="2023-08-22T00:00:00+00:00" property="article:published_time"/><meta content="2023-08-22T22:36:07+08:00" property="article:modified_time"/><meta content="summary" name="twitter:card"/><meta content="Redis的淘汰策略LRU与LFU" name="twitter:title"/><meta content="     " name="twitter:description"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"Redis的淘汰策略LRU与LFU","item":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis/Redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5LRU%E4%B8%8ELFU.html"}]}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis的淘汰策略LRU与LFU","name":"Redis的淘汰策略LRU与LFU","description":"     ","keywords":[" redis中的LRU实现","define LRU_BITS 24","define REDIS_LRU_BITS 24"," redis中的LFU实现","  ldt(Last Decrement Time)"," logc(Logistic Counter)"," logc 算法调整"," 扩展"," 淘汰池的更新策略"],"articleBody":"[toc]\n释放内存其实在每次处理命令时都会执行, 只是满足判断条件才执行 , 例如内存满了, 需要淘汰key等等条件, 若发现已用内存超出maxmemory，会计算需释放的内存量。这个 释放内存大小=已使用内存量-maxmemory。\nredis中的LRU实现 redis没有使用标准的LRU算法, 只是近似的LRU算法, 因为嫌LinkedList占用的空间太大了(因为起码要记录头尾指针)\n简述: redis通过计算每个key的闲置时间来决定是否要选它淘汰(全局时钟 减去 当前key的访问时钟), redis会随机选几个key, 它们的闲置时间都要大于一个阈值(其实会存入一个pool, 这个阈值就是pool中最小的闲置时间), 当内存不够时, 就从这几个key中淘汰闲置时间最大的值\n首先看一下全局时钟定义\n#define LRU_BITS 24 struct redisServer { pid_t pid; /* Main process pid. */ char *configfile; /* Absolute config file path, or NULL */ ….. unsigned lruclock:LRU_BITS; /* Clock for LRU eviction */ ... }; redisServer 中包含了redis服务器启动之后的基本信息(PID,配置文件路径,serverCron运行频率hz等),外部可调用模块信息，网络信息，RDB/AOF信息，日志信息，复制信息等等。\n上述结构体中lruclock:LRU_BITS,其中存储了服务器自启动之后的lru时钟，该时钟是全局的lru时钟。该时钟100ms更新一次。\n可以通过hz来调整,默认情况hz=10,因此每1000ms/10=100ms执行一次定时任务\n因此lrulock最大能到(2**24-1)/3600/24 = 194天,如果超过了这个时间，lrulock重新开始。对于redis server来说，server.lrulock表示的是一个全局的lrulock，\n如果全局时钟 小于 对象时钟, 则会再加上时钟最大值 REDIS_LRU_CLOCK_MAX , 也就是 194天 的秒数, 相当于是第二轮了\n/* Given an object returns the min number of seconds the object was never * requested, using an approximated LRU algorithm. */ #define REDIS_LRU_CLOCK_MAX ((1\u003c","wordCount":"4300","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-08-22T22:36:07+08:00","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis/Redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5LRU%E4%B8%8ELFU.html"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.com/img/Q.svg"}}}</script></head><body class="dark" id="top"><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class="header"><nav class="nav"><div class="logo"><a accesskey="h" href="https://xiaokunji.com/zh/" title="米二 (Alt + H)"><img alt="" aria-label="logo" height="35" src="https://xiaokunji.com/img/Q.svg"/>米二</a><div class="logo-switches"><button accesskey="t" id="theme-toggle" title="(Alt + T)"><svg fill="none" height="18" id="moon" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path></svg><svg fill="none" height="18" id="sun" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="5"></circle><line x1="12" x2="12" y1="1" y2="3"></line><line x1="12" x2="12" y1="21" y2="23"></line><line x1="4.22" x2="5.64" y1="4.22" y2="5.64"></line><line x1="18.36" x2="19.78" y1="18.36" y2="19.78"></line><line x1="1" x2="3" y1="12" y2="12"></line><line x1="21" x2="23" y1="12" y2="12"></line><line x1="4.22" x2="5.64" y1="19.78" y2="18.36"></line><line x1="18.36" x2="19.78" y1="5.64" y2="4.22"></line></svg></button><ul class="lang-switch"><li>|</li><li><a aria-label="English" href="https://xiaokunji.com/en/" title="English">English</a></li></ul></div></div><ul id="menu"><li><a href="https://xiaokunji.com/zh/" title="🏠主页"><span>🏠主页</span></a></li><li><a accesskey="/" href="https://xiaokunji.com/zh/search" title="🔍搜索 (Alt + /)"><span>🔍搜索</span></a></li><li><a href="https://xiaokunji.com/zh/post.html" title="📚文章"><span>📚文章</span></a></li><li><a href="https://xiaokunji.com/zh/archives.html" title="⏱时间轴"><span>⏱时间轴</span></a></li><li><a href="https://xiaokunji.com/zh/tags.html" title="🔖标签"><span>🔖标签</span></a></li><li><a href="https://xiaokunji.com/zh/categories.html" title="📖分类"><span>📖分类</span></a></li><li><a href="https://xiaokunji.com/zh/links.html" title="🤝友链"><span>🤝友链</span></a></li></ul></nav></header><main class="main"><article class="post-single"><header class="post-header"><nav aria-label="breadcrumb"><ul><a href="https://xiaokunji.com/zh/">🏠</a> <span>&gt;</span>
<a href="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88.html">综合</a> <span>&gt;</span>
<a href="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis.html">Redis</a> <span>&gt;</span></ul></nav><h1 class="post-title">Redis的淘汰策略LRU与LFU</h1><div class="post-description"></div><div class="post-meta">创建:&amp;nbsp;&lt;span title='2023-08-22 00:00:00 +0000 UTC'&gt;2023-08-22&lt;/span&gt;&amp;nbsp;·&amp;nbsp;更新:&amp;nbsp;2023-08-22&amp;nbsp;·&amp;nbsp;xkj
 | 分类:  <ul class="post-categories-meta" style="display:inline"><a href="https://xiaokunji.com/zh/categories/%E7%BB%BC%E5%90%88.html">综合</a></ul><span id="busuanzi_container_page_pv"> | 访问: <span id="busuanzi_value_page_pv">1</span></span></div></header><aside class="toc-container wide" id="toc-container"><div class="toc"><details open=""><summary accesskey="c" title="(Alt + C)"><span class="details">目录</span></summary><div class="inner"><ul><li><a aria-label="redis中的LRU实现" href="#redis%e4%b8%ad%e7%9a%84lru%e5%ae%9e%e7%8e%b0">redis中的LRU实现</a></li><li><a aria-label="redis中的LFU实现" href="#redis%e4%b8%ad%e7%9a%84lfu%e5%ae%9e%e7%8e%b0">redis中的LFU实现</a><ul><li><a aria-label="ldt(Last Decrement Time)" href="#ldtlast-decrement-time">ldt(Last Decrement Time)</a></li><li><a aria-label="logc(Logistic Counter)" href="#logclogistic-counter">logc(Logistic Counter)</a></li><li><a aria-label="logc 算法调整" href="#logc-%e7%ae%97%e6%b3%95%e8%b0%83%e6%95%b4">logc 算法调整</a></li></ul></li><li><a aria-label="扩展" href="#%e6%89%a9%e5%b1%95">扩展</a><ul><li><a aria-label="淘汰池的更新策略" href="#%e6%b7%98%e6%b1%b0%e6%b1%a0%e7%9a%84%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5">淘汰池的更新策略</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class="post-content"><p>[toc]</p><blockquote><p>释放内存其实在每次处理命令时都会执行, 只是满足判断条件才执行 , 例如内存满了, 需要淘汰key等等条件, 若发现已用内存超出<code>maxmemory</code>，会计算需释放的内存量。这个 <code>释放内存大小=已使用内存量-maxmemory</code>。</p></blockquote><h1 id="redis中的lru实现">redis中的LRU实现<a aria-hidden="true" class="anchor" hidden="" href="#redis中的lru实现">#</a></h1><p>redis没有使用标准的LRU算法, 只是近似的LRU算法, 因为嫌LinkedList占用的空间太大了(因为起码要记录头尾指针)</p><blockquote><p>简述: redis通过计算每个key的闲置时间来决定是否要选它淘汰(全局时钟 减去 当前key的访问时钟), redis会随机选几个key, 它们的闲置时间都要大于一个阈值(其实会存入一个pool, 这个阈值就是pool中最小的闲置时间), 当内存不够时, 就<strong>从这几个key中淘汰闲置时间最大的值</strong></p></blockquote><p>首先看一下全局时钟定义</p><div class="highlight"><pre style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c++" data-lang="c++"><span style="display:flex"><span><span style="color:#8b949e;font-weight:700;font-style:italic">#define LRU_BITS 24
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-weight:700;font-style:italic"></span><span style="color:#ff7b72">struct</span> <span style="color:#f0883e;font-weight:700">redisServer</span> {
</span></span><span style="display:flex"><span>       pid_t pid; <span style="color:#8b949e;font-style:italic">/* Main process pid. */</span>
</span></span><span style="display:flex"><span>       <span style="color:#ff7b72">char</span> <span style="color:#ff7b72;font-weight:700">*</span>configfile; <span style="color:#8b949e;font-style:italic">/* Absolute config file path, or NULL */</span>
</span></span><span style="display:flex"><span>       <span style="color:#f85149">…</span>..
</span></span><span style="display:flex"><span>       <span style="color:#ff7b72">unsigned</span> <span style="color:#79c0ff;font-weight:700">lruclock</span>:LRU_BITS; <span style="color:#8b949e;font-style:italic">/* Clock for LRU eviction */</span>
</span></span><span style="display:flex"><span>       ...
</span></span><span style="display:flex"><span>};
</span></span></code></pre></div><p>redisServer 中包含了redis服务器启动之后的基本信息(PID,配置文件路径,serverCron运行频率hz等),外部可调用模块信息，网络信息，RDB/AOF信息，日志信息，复制信息等等。</p><p>上述结构体中<code>lruclock:LRU_BITS</code>,其中存储了服务器自启动之后的lru时钟，该时钟是全局的lru时钟。<strong>该时钟100ms更新一次</strong>。</p><blockquote><p>可以通过hz来调整,默认情况hz=10,因此每1000ms/10=100ms执行一次定时任务</p></blockquote><p>因此lrulock最大能到(2**24-1)/3600/24 = 194天,如果超过了这个时间，lrulock重新开始。对于redis server来说，server.lrulock表示的是一个全局的lrulock，</p><blockquote><p>如果全局时钟 小于 对象时钟, 则会再加上时钟最大值 <code>REDIS_LRU_CLOCK_MAX</code> , 也就是 194天 的秒数, 相当于是第二轮了</p><div class="highlight"><pre style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">/* Given an object returns the min number of seconds the object was never
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * requested, using an approximated LRU algorithm. */</span>
</span></span><span style="display:flex"><span><span style="color:#8b949e;font-weight:700;font-style:italic">#define REDIS_LRU_CLOCK_MAX ((1&lt;&lt;REDIS_LRU_BITS)-1) </span><span style="color:#8b949e;font-style:italic">/* Max value of obj-&gt;lru */</span><span style="color:#8b949e;font-weight:700;font-style:italic">
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-weight:700;font-style:italic">#define REDIS_LRU_CLOCK_RESOLUTION 1 </span><span style="color:#8b949e;font-style:italic">/* LRU clock resolution in seconds */</span><span style="color:#8b949e;font-weight:700;font-style:italic">
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-weight:700;font-style:italic"></span><span style="color:#ff7b72">unsigned</span> <span style="color:#ff7b72">long</span> <span style="color:#d2a8ff;font-weight:700">estimateObjectIdleTime</span>(robj <span style="color:#ff7b72;font-weight:700">*</span>o) {
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">if</span> (server.lruclock <span style="color:#ff7b72;font-weight:700">&gt;=</span> o<span style="color:#ff7b72;font-weight:700">-&gt;</span>lru) {
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">return</span> (server.lruclock <span style="color:#ff7b72;font-weight:700">-</span> o<span style="color:#ff7b72;font-weight:700">-&gt;</span>lru) <span style="color:#ff7b72;font-weight:700">*</span> REDIS_LRU_CLOCK_RESOLUTION;
</span></span><span style="display:flex"><span>    } <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">return</span> ((REDIS_LRU_CLOCK_MAX <span style="color:#ff7b72;font-weight:700">-</span> o<span style="color:#ff7b72;font-weight:700">-&gt;</span>lru) <span style="color:#ff7b72;font-weight:700">+</span> server.lruclock) <span style="color:#ff7b72;font-weight:700">*</span> REDIS_LRU_CLOCK_RESOLUTION;
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div></blockquote><p>那么对于每个redisObject都有一个自己的lrulock。这样每redisObject就可以根据自己的lrulock和全局的server.lrulock比较，来确定是否能够被淘汰掉。</p><p>再看一下 redisObject的实现</p><div class="highlight"><pre style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#8b949e;font-weight:700;font-style:italic">#define REDIS_LRU_BITS 24
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-weight:700;font-style:italic"></span><span style="color:#ff7b72">typedef</span> <span style="color:#ff7b72">struct</span> redisObject {
</span></span><span style="display:flex"><span>     <span style="color:#ff7b72">unsigned</span> <span style="color:#79c0ff;font-weight:700">type</span>:<span style="color:#a5d6ff">4</span>;
</span></span><span style="display:flex"><span>     <span style="color:#ff7b72">unsigned</span> <span style="color:#79c0ff;font-weight:700">encoding</span>:<span style="color:#a5d6ff">4</span>;
</span></span><span style="display:flex"><span>    <span style="color:#8b949e;font-style:italic">// 从这里看出, 这个字段在不同淘汰策略下, 存的内容是不一样的
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>     <span style="color:#ff7b72">unsigned</span> <span style="color:#79c0ff;font-weight:700">lru</span>:LRU_BITS; <span style="color:#8b949e;font-style:italic">/* LRU time (relative to server.lruclock) or
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">                             * LFU data (least significant 8 bits frequency
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">                             * and most significant 16 bits decreas time). */</span>
</span></span><span style="display:flex"><span>     <span style="color:#ff7b72">int</span> refcount;
</span></span><span style="display:flex"><span>     <span style="color:#ff7b72">void</span> <span style="color:#ff7b72;font-weight:700">*</span>ptr;
</span></span><span style="display:flex"><span>} robj
</span></span></code></pre></div><p>在Redis的dict中每次按key获取一个值的时候，都会调用lookupKey函数,如果配置使用了LRU模式,该函数会更新value中的lru字段为当前秒级别的时间戳</p><div class="highlight"><pre style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex"><span>robj <span style="color:#ff7b72;font-weight:700">*</span><span style="color:#d2a8ff;font-weight:700">lookupKey</span>(redisDb <span style="color:#ff7b72;font-weight:700">*</span>db, robj <span style="color:#ff7b72;font-weight:700">*</span>key, <span style="color:#ff7b72">int</span> flags) {
</span></span><span style="display:flex"><span>    ...
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">if</span> (server.maxmemory_policy <span style="color:#ff7b72;font-weight:700">&amp;</span> MAXMEMORY_FLAG_LFU) { <span style="color:#8b949e;font-style:italic">//如果配置的是lfu方式，则更新lfu
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>                <span style="color:#d2a8ff;font-weight:700">updateLFU</span>(val);
</span></span><span style="display:flex"><span>            } <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex"><span>                val<span style="color:#ff7b72;font-weight:700">-&gt;</span>lru <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">LRU_CLOCK</span>();<span style="color:#8b949e;font-style:italic">//否则按lru方式更新
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>            }
</span></span><span style="display:flex"><span>    ...
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>第一次随机选取的key都会放入一个pool中(pool的大小为16),pool中的key是按lru大小顺序排列的。接下来每次随机选取的key lru值必须大于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接<strong>从pool中选取一个lru最大的值然后将其淘汰</strong>。这样一来，每次移除的Key并不仅仅是随机选择的N个Key里面最大的，而且还是pool里面idle time最大的</p><p>随机选的key的数量默认为5, 由 <code>server.maxmemory_samples</code> 控制, <code>maxmemory_samples</code> 就是样本大小, 值越大, 约接近LRU, 淘汰的正确率越高, 性能消耗也越大</p><blockquote><p>采用"pool"，把一个全局排序问题 转化成为了 局部的比较问题。(尽管排序本质上也是比较，囧)。要想知道idle time 最大的key，精确的LRU需要对全局的key的idle time排序，然后就能找出idle time最大的key了。但是可以采用一种近似的思想，即随机采样(samping)若干个key，这若干个key就代表着全局的key，把samping得到的key放到pool里面，每次采样之后更新pool，使得pool里面总是保存着随机选择过的key的idle time最大的那些key。需要evict key时，直接从pool里面取出idle time最大的key，将之evict掉。这种思想是很值得借鉴的。</p></blockquote><h1 id="redis中的lfu实现">redis中的LFU实现<a aria-hidden="true" class="anchor" hidden="" href="#redis中的lfu实现">#</a></h1><blockquote><p>简述: 它和LRU规则一样, 利用在key中时间钟字段, 不过把内部时钟的24位分成两部分，前16位还代表时钟，<strong>后8位代表一个计数器</strong>。8位只能代表255，但是redis并没有采用线性上升的方式，而是结合增长因子来计数, 而且还有衰退因子来减少计数。也会和LRU一样, 存在一个淘汰池, <strong>从淘汰池中redis会对内部时钟最小的key进行淘汰</strong>（最小表示最不频繁使用），注意这个过程也是根据策略随机选择键</p></blockquote><p>在LFU模式下，Redis对象头的24bit lru字段被分成两段来存储，高16bit存储ldt(Last Decrement Time)，低8bit存储logc(Logistic Counter)。</p><p><img alt="lru_24 bit.png" loading="lazy" src="Redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5LRU%E4%B8%8ELFU.assets/5dd759c2c31876ed554585f5cd0e9193.png"/></p><h2 id="ldtlast-decrement-time">ldt(Last Decrement Time)<a aria-hidden="true" class="anchor" hidden="" href="#ldtlast-decrement-time">#</a></h2><p>高16bit用来记录最近一次计数器降低的时间，由于只有8bit，存储的是Unix分钟时间戳取模2^16，16bit能表示的最大值为65535（65535/24/60≈45.5），大概45.5天会折返（折返指的是取模后的值重新从0开始）。</p><p>源码如下:</p><div class="highlight"><pre style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">/* Return the current time in minutes, just taking the least significant
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * 16 bits. The returned time is suitable to be stored as LDT (last decrement
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * time) for the LFU implementation. */</span>
</span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">// server.unixtime是Redis缓存的Unix时间戳
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">// 可以看出使用的Unix的分钟时间戳，取模2^16
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">unsigned</span> <span style="color:#ff7b72">long</span> <span style="color:#d2a8ff;font-weight:700">LFUGetTimeInMinutes</span>(<span style="color:#ff7b72">void</span>) {
</span></span><span style="display:flex"><span>  <span style="color:#ff7b72">return</span> (server.unixtime<span style="color:#ff7b72;font-weight:700">/</span><span style="color:#a5d6ff">60</span>) <span style="color:#ff7b72;font-weight:700">&amp;</span> <span style="color:#a5d6ff">65535</span>;
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span> 
</span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">/* Given an object last access time, compute the minimum number of minutes
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * that elapsed since the last access. Handle overflow (ldt greater than
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * the current 16 bits minutes time) considering the time as wrapping
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * exactly once. */</span>
</span></span><span style="display:flex"><span><span style="color:#ff7b72">unsigned</span> <span style="color:#ff7b72">long</span> <span style="color:#d2a8ff;font-weight:700">LFUTimeElapsed</span>(<span style="color:#ff7b72">unsigned</span> <span style="color:#ff7b72">long</span> ldt) {
</span></span><span style="display:flex"><span>  <span style="color:#8b949e;font-style:italic">// 获取系统当前的LFU time
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#ff7b72">unsigned</span> <span style="color:#ff7b72">long</span> now <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">LFUGetTimeInMinutes</span>();
</span></span><span style="display:flex"><span>  <span style="color:#8b949e;font-style:italic">// 如果now &gt;= ldt 直接取差值  
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#ff7b72">if</span> (now <span style="color:#ff7b72;font-weight:700">&gt;=</span> ldt) <span style="color:#ff7b72">return</span> now<span style="color:#ff7b72;font-weight:700">-</span>ldt;
</span></span><span style="display:flex"><span>  <span style="color:#8b949e;font-style:italic">// 如果now &lt; ldt 增加上65535
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#8b949e;font-style:italic">// 注意Redis 认为折返就只有一次折返，多次折返也是一次，我思考了很久感觉这个应该是可以接受的，本身Redis的淘汰算法就带有随机性  
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">65535</span><span style="color:#ff7b72;font-weight:700">-</span>ldt<span style="color:#ff7b72;font-weight:700">+</span>now;
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><h2 id="logclogistic-counter">logc(Logistic Counter)<a aria-hidden="true" class="anchor" hidden="" href="#logclogistic-counter">#</a></h2><p>低8位用来记录访问频次，8bit能表示的最大值为255，logc肯定无法记录真实的Rediskey的访问次数，其实从名字可以看出存储的是访问次数的对数值，每个<strong>新加入的key的logc初始值为5（LFU_INITI_VAL）</strong>，这样可以保证新加入的值不会被首先选中淘汰；logc每次key被访问时都会更新；此外，logc会随着时间衰减。</p><h2 id="logc-算法调整">logc 算法调整<a aria-hidden="true" class="anchor" hidden="" href="#logc-算法调整">#</a></h2><p>redis.conf 提供了两个配置项，用于调整LFU的算法从而控制Logistic Counter的增长和衰减。</p><div class="highlight"><pre style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-properties" data-lang="properties"><span style="display:flex"><span>-- <span style="color:#a5d6ff">用于调整Logistic Counter的增长速度，lfu-log-factor值越大，Logistic Counter增长越慢。</span>
</span></span><span style="display:flex"><span>lfu-log-factor <span style="color:#a5d6ff">10</span>
</span></span><span style="display:flex"><span>-- <span style="color:#a5d6ff">用于调整Logistic Counter的衰减速度，它是一个以分钟为单位的数值，默认值为1,；lfu-decay-time值越大，衰减越慢。</span>
</span></span><span style="display:flex"><span>lfu-decay-time <span style="color:#a5d6ff">1</span>
</span></span></code></pre></div><p>增长的源码:</p><div class="highlight"><pre style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">/* Logarithmically increment a counter. The greater is the current counter value
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * the less likely is that it gets really implemented. Saturate it at 255. */</span>
</span></span><span style="display:flex"><span><span style="color:#ff7b72">uint8_t</span> <span style="color:#d2a8ff;font-weight:700">LFULogIncr</span>(<span style="color:#ff7b72">uint8_t</span> counter) {
</span></span><span style="display:flex"><span>  <span style="color:#8b949e;font-style:italic">// Logistic Counter最大值为255  
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#ff7b72">if</span> (counter <span style="color:#ff7b72;font-weight:700">==</span> <span style="color:#a5d6ff">255</span>) <span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">255</span>;
</span></span><span style="display:flex"><span>  <span style="color:#8b949e;font-style:italic">// 取一个0~1的随机数r  
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#ff7b72">double</span> r <span style="color:#ff7b72;font-weight:700">=</span> (<span style="color:#ff7b72">double</span>)<span style="color:#d2a8ff;font-weight:700">rand</span>()<span style="color:#ff7b72;font-weight:700">/</span>RAND_MAX;
</span></span><span style="display:flex"><span>  <span style="color:#8b949e;font-style:italic">// counter减去LFU_INIT_VAL （LFU_INIT_VAL为每个key的Logistic Counter初始值，默认为5）
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#ff7b72">double</span> baseval <span style="color:#ff7b72;font-weight:700">=</span> counter <span style="color:#ff7b72;font-weight:700">-</span> LFU_INIT_VAL;
</span></span><span style="display:flex"><span>  <span style="color:#8b949e;font-style:italic">// 如果衰减之后已经小于5了，那么baseval &lt; 0取0
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#ff7b72">if</span> (baseval <span style="color:#ff7b72;font-weight:700">&lt;</span> <span style="color:#a5d6ff">0</span>) baseval <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex"><span>  <span style="color:#8b949e;font-style:italic">// lfu-log-factor在这里被使用
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#8b949e;font-style:italic">// 可以看出如果lfu_log_factor的值越大，p越小
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#8b949e;font-style:italic">// r &lt; p的概率就越小，Logistic Counter增加的概率就越小（因此lfu_log_factor越大增长越缓慢）
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#ff7b72">double</span> p <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">1.0</span><span style="color:#ff7b72;font-weight:700">/</span>(baseval<span style="color:#ff7b72;font-weight:700">*</span>server.lfu_log_factor<span style="color:#ff7b72;font-weight:700">+</span><span style="color:#a5d6ff">1</span>);
</span></span><span style="display:flex"><span>  <span style="color:#ff7b72">if</span> (r <span style="color:#ff7b72;font-weight:700">&lt;</span> p) counter<span style="color:#ff7b72;font-weight:700">++</span>;
</span></span><span style="display:flex"><span>  <span style="color:#ff7b72">return</span> counter;
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>衰减的源代码：</p><div class="highlight"><pre style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">/* If the object decrement time is reached decrement the LFU counter but
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * do not update LFU fields of the object, we update the access time
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * and counter in an explicit way when the object is really accessed.
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * And we will times halve the counter according to the times of
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * elapsed time than server.lfu_decay_time.
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * Return the object frequency counter.
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> *
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * This function is used in order to scan the dataset for the best object
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * to fit: as we check for the candidate, we incrementally decrement the
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"> * counter of the scanned objects if needed. */</span>
</span></span><span style="display:flex"><span><span style="color:#ff7b72">unsigned</span> <span style="color:#ff7b72">long</span> <span style="color:#d2a8ff;font-weight:700">LFUDecrAndReturn</span>(robj <span style="color:#ff7b72;font-weight:700">*</span>o) {
</span></span><span style="display:flex"><span>  <span style="color:#8b949e;font-style:italic">// 获取lru的高16位，也就是ldt
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#ff7b72">unsigned</span> <span style="color:#ff7b72">long</span> ldt <span style="color:#ff7b72;font-weight:700">=</span> o<span style="color:#ff7b72;font-weight:700">-&gt;</span>lru <span style="color:#ff7b72;font-weight:700">&gt;&gt;</span> <span style="color:#a5d6ff">8</span>;  
</span></span><span style="display:flex"><span>  <span style="color:#8b949e;font-style:italic">// 获取lru的低8位，也就是logc  
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#ff7b72">unsigned</span> <span style="color:#ff7b72">long</span> counter <span style="color:#ff7b72;font-weight:700">=</span> o<span style="color:#ff7b72;font-weight:700">-&gt;</span>lru <span style="color:#ff7b72;font-weight:700">&amp;</span> <span style="color:#a5d6ff">255</span>;
</span></span><span style="display:flex"><span>  <span style="color:#8b949e;font-style:italic">// 根据配置的lfu-decay-time计算Logistic Counter需要衰减的值
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#ff7b72">unsigned</span> <span style="color:#ff7b72">long</span> num_periods <span style="color:#ff7b72;font-weight:700">=</span> server.lfu_decay_time <span style="color:#ff7b72;font-weight:700">?</span> <span style="color:#d2a8ff;font-weight:700">LFUTimeElapsed</span>(ldt) <span style="color:#ff7b72;font-weight:700">/</span> server.<span style="color:#79c0ff;font-weight:700">lfu_decay_time</span> : <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex"><span>  <span style="color:#ff7b72">if</span> (num_periods)
</span></span><span style="display:flex"><span>    counter <span style="color:#ff7b72;font-weight:700">=</span> (num_periods <span style="color:#ff7b72;font-weight:700">&gt;</span> counter) <span style="color:#ff7b72;font-weight:700">?</span> <span style="color:#a5d6ff">0</span> <span style="color:#ff7b72;font-weight:700">:</span> counter <span style="color:#ff7b72;font-weight:700">-</span> num_periods;
</span></span><span style="display:flex"><span>  <span style="color:#ff7b72">return</span> counter;
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>LFU 与 LRU 有一个共同点，当内存达到max_memory时，选择key是随机抓取的，因此Redis为了使这种随机性更加准确，设计了一个淘汰池，这个淘汰池对于LFU和LRU算的都适应，只是淘汰池的排序算法有区别而已。</p><h1 id="扩展">扩展<a aria-hidden="true" class="anchor" hidden="" href="#扩展">#</a></h1><h2 id="淘汰池的更新策略">淘汰池的更新策略<a aria-hidden="true" class="anchor" hidden="" href="#淘汰池的更新策略">#</a></h2><p>这个淘汰池就是使用LRU和LFU时, 需要淘汰key时, 是从淘汰池按时间钟来淘汰, 源码如下:</p><div class="highlight"><pre style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c"><span style="display:flex"><span><span style="color:#ff7b72">void</span> <span style="color:#d2a8ff;font-weight:700">evictionPoolPopulate</span>(<span style="color:#ff7b72">int</span> dbid, dict <span style="color:#ff7b72;font-weight:700">*</span>sampledict, dict <span style="color:#ff7b72;font-weight:700">*</span>keydict, <span style="color:#ff7b72">struct</span> evictionPoolEntry <span style="color:#ff7b72;font-weight:700">*</span>pool) {
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">int</span> j, k, count;
</span></span><span style="display:flex"><span>    dictEntry <span style="color:#ff7b72;font-weight:700">*</span>samples[server.maxmemory_samples];
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    count <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">dictGetSomeKeys</span>(sampledict,samples,server.maxmemory_samples);
</span></span><span style="display:flex"><span>    <span style="color:#ff7b72">for</span> (j <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0</span>; j <span style="color:#ff7b72;font-weight:700">&lt;</span> count; j<span style="color:#ff7b72;font-weight:700">++</span>) {
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">unsigned</span> <span style="color:#ff7b72">long</span> <span style="color:#ff7b72">long</span> idle;
</span></span><span style="display:flex"><span>        sds key;
</span></span><span style="display:flex"><span>        robj <span style="color:#ff7b72;font-weight:700">*</span>o;
</span></span><span style="display:flex"><span>        dictEntry <span style="color:#ff7b72;font-weight:700">*</span>de;
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>        de <span style="color:#ff7b72;font-weight:700">=</span> samples[j];
</span></span><span style="display:flex"><span>        key <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">dictGetKey</span>(de);
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>        <span style="color:#8b949e;font-style:italic">/* If the dictionary we are sampling from is not the main
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">         * dictionary (but the expires one) we need to lookup the key
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">         * again in the key dictionary to obtain the value object. */</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">if</span> (server.maxmemory_policy <span style="color:#ff7b72;font-weight:700">!=</span> MAXMEMORY_VOLATILE_TTL) {
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">if</span> (sampledict <span style="color:#ff7b72;font-weight:700">!=</span> keydict) de <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">dictFind</span>(keydict, key);
</span></span><span style="display:flex"><span>            o <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">dictGetVal</span>(de);
</span></span><span style="display:flex"><span>        }
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>        <span style="color:#8b949e;font-style:italic">/* Calculate the idle time according to the policy. This is called
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">         * idle just because the code initially handled LRU, but is in fact
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">         * just a score where an higher score means better candidate. */</span>
</span></span><span style="display:flex"><span>        <span style="color:#8b949e;font-style:italic">// 空闲时间的计算方式 LRU 、 LFU 、最快过期的可以 三种过期策略下 都是不同的
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#ff7b72">if</span> (server.maxmemory_policy <span style="color:#ff7b72;font-weight:700">&amp;</span> MAXMEMORY_FLAG_LRU) {
</span></span><span style="display:flex"><span>            idle <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">estimateObjectIdleTime</span>(o);
</span></span><span style="display:flex"><span>        } <span style="color:#ff7b72">else</span> <span style="color:#ff7b72">if</span> (server.maxmemory_policy <span style="color:#ff7b72;font-weight:700">&amp;</span> MAXMEMORY_FLAG_LFU) {
</span></span><span style="display:flex"><span>            <span style="color:#8b949e;font-style:italic">/* When we use an LRU policy, we sort the keys by idle time
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">             * so that we expire keys starting from greater idle time.
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">             * However when the policy is an LFU one, we have a frequency
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">             * estimation, and we want to evict keys with lower frequency
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">             * first. So inside the pool we put objects using the inverted
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">             * frequency subtracting the actual frequency to the maximum
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">             * frequency of 255. */</span>
</span></span><span style="display:flex"><span>            idle <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">255</span><span style="color:#ff7b72;font-weight:700">-</span><span style="color:#d2a8ff;font-weight:700">LFUDecrAndReturn</span>(o);
</span></span><span style="display:flex"><span>        } <span style="color:#ff7b72">else</span> <span style="color:#ff7b72">if</span> (server.maxmemory_policy <span style="color:#ff7b72;font-weight:700">==</span> MAXMEMORY_VOLATILE_TTL) {
</span></span><span style="display:flex"><span>            <span style="color:#8b949e;font-style:italic">/* In this case the sooner the expire the better. */</span>
</span></span><span style="display:flex"><span>            idle <span style="color:#ff7b72;font-weight:700">=</span> ULLONG_MAX <span style="color:#ff7b72;font-weight:700">-</span> (<span style="color:#ff7b72">long</span>)<span style="color:#d2a8ff;font-weight:700">dictGetVal</span>(de);
</span></span><span style="display:flex"><span>        } <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex"><span>            <span style="color:#d2a8ff;font-weight:700">serverPanic</span>(<span style="color:#a5d6ff">"Unknown eviction policy in evictionPoolPopulate()"</span>);
</span></span><span style="display:flex"><span>        }
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>        <span style="color:#8b949e;font-style:italic">/* Insert the element inside the pool.
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">         * First, find the first empty bucket or the first populated
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">         * bucket that has an idle time smaller than our idle time. */</span>
</span></span><span style="display:flex"><span>        k <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#a5d6ff">0</span>;
</span></span><span style="display:flex"><span>        <span style="color:#8b949e;font-style:italic">// 在这里判断 池中某一个key的空闲时间是否小于 当前key的空闲时间
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic"></span>        <span style="color:#ff7b72">while</span> (k <span style="color:#ff7b72;font-weight:700">&lt;</span> EVPOOL_SIZE <span style="color:#ff7b72;font-weight:700">&amp;&amp;</span>
</span></span><span style="display:flex"><span>               pool[k].key <span style="color:#ff7b72;font-weight:700">&amp;&amp;</span>
</span></span><span style="display:flex"><span>               pool[k].idle <span style="color:#ff7b72;font-weight:700">&lt;</span> idle) k<span style="color:#ff7b72;font-weight:700">++</span>;
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">if</span> (k <span style="color:#ff7b72;font-weight:700">==</span> <span style="color:#a5d6ff">0</span> <span style="color:#ff7b72;font-weight:700">&amp;&amp;</span> pool[EVPOOL_SIZE<span style="color:#ff7b72;font-weight:700">-</span><span style="color:#a5d6ff">1</span>].key <span style="color:#ff7b72;font-weight:700">!=</span> NULL) {
</span></span><span style="display:flex"><span>            <span style="color:#8b949e;font-style:italic">/* Can't insert if the element is &lt; the worst element we have
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">             * and there are no empty buckets. */</span>
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">continue</span>;
</span></span><span style="display:flex"><span>        } <span style="color:#ff7b72">else</span> <span style="color:#ff7b72">if</span> (k <span style="color:#ff7b72;font-weight:700">&lt;</span> EVPOOL_SIZE <span style="color:#ff7b72;font-weight:700">&amp;&amp;</span> pool[k].key <span style="color:#ff7b72;font-weight:700">==</span> NULL) {
</span></span><span style="display:flex"><span>            <span style="color:#8b949e;font-style:italic">/* Inserting into empty position. No setup needed before insert. */</span>
</span></span><span style="display:flex"><span>        } <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex"><span>            <span style="color:#8b949e;font-style:italic">/* Inserting in the middle. Now k points to the first element
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">             * greater than the element to insert.  */</span>
</span></span><span style="display:flex"><span>            <span style="color:#ff7b72">if</span> (pool[EVPOOL_SIZE<span style="color:#ff7b72;font-weight:700">-</span><span style="color:#a5d6ff">1</span>].key <span style="color:#ff7b72;font-weight:700">==</span> NULL) {
</span></span><span style="display:flex"><span>                <span style="color:#8b949e;font-style:italic">/* Free space on the right? Insert at k shifting
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">                 * all the elements from k to end to the right. */</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>                <span style="color:#8b949e;font-style:italic">/* Save SDS before overwriting. */</span>
</span></span><span style="display:flex"><span>                sds cached <span style="color:#ff7b72;font-weight:700">=</span> pool[EVPOOL_SIZE<span style="color:#ff7b72;font-weight:700">-</span><span style="color:#a5d6ff">1</span>].cached;
</span></span><span style="display:flex"><span>                <span style="color:#d2a8ff;font-weight:700">memmove</span>(pool<span style="color:#ff7b72;font-weight:700">+</span>k<span style="color:#ff7b72;font-weight:700">+</span><span style="color:#a5d6ff">1</span>,pool<span style="color:#ff7b72;font-weight:700">+</span>k,
</span></span><span style="display:flex"><span>                    <span style="color:#ff7b72">sizeof</span>(pool[<span style="color:#a5d6ff">0</span>])<span style="color:#ff7b72;font-weight:700">*</span>(EVPOOL_SIZE<span style="color:#ff7b72;font-weight:700">-</span>k<span style="color:#ff7b72;font-weight:700">-</span><span style="color:#a5d6ff">1</span>));
</span></span><span style="display:flex"><span>                pool[k].cached <span style="color:#ff7b72;font-weight:700">=</span> cached;
</span></span><span style="display:flex"><span>            } <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex"><span>                <span style="color:#8b949e;font-style:italic">/* No free space on right? Insert at k-1 */</span>
</span></span><span style="display:flex"><span>                k<span style="color:#ff7b72;font-weight:700">--</span>;
</span></span><span style="display:flex"><span>                <span style="color:#8b949e;font-style:italic">/* Shift all elements on the left of k (included) to the
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">                 * left, so we discard the element with smaller idle time. */</span>
</span></span><span style="display:flex"><span>                sds cached <span style="color:#ff7b72;font-weight:700">=</span> pool[<span style="color:#a5d6ff">0</span>].cached; <span style="color:#8b949e;font-style:italic">/* Save SDS before overwriting. */</span>
</span></span><span style="display:flex"><span>                <span style="color:#ff7b72">if</span> (pool[<span style="color:#a5d6ff">0</span>].key <span style="color:#ff7b72;font-weight:700">!=</span> pool[<span style="color:#a5d6ff">0</span>].cached) <span style="color:#d2a8ff;font-weight:700">sdsfree</span>(pool[<span style="color:#a5d6ff">0</span>].key);
</span></span><span style="display:flex"><span>                <span style="color:#d2a8ff;font-weight:700">memmove</span>(pool,pool<span style="color:#ff7b72;font-weight:700">+</span><span style="color:#a5d6ff">1</span>,<span style="color:#ff7b72">sizeof</span>(pool[<span style="color:#a5d6ff">0</span>])<span style="color:#ff7b72;font-weight:700">*</span>k);
</span></span><span style="display:flex"><span>                pool[k].cached <span style="color:#ff7b72;font-weight:700">=</span> cached;
</span></span><span style="display:flex"><span>            }
</span></span><span style="display:flex"><span>        }
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>        <span style="color:#8b949e;font-style:italic">/* Try to reuse the cached SDS string allocated in the pool entry,
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">         * because allocating and deallocating this object is costly
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">         * (according to the profiler, not my fantasy. Remember:
</span></span></span><span style="display:flex"><span><span style="color:#8b949e;font-style:italic">         * premature optimizbla bla bla bla. */</span>
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">int</span> klen <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">sdslen</span>(key);
</span></span><span style="display:flex"><span>        <span style="color:#ff7b72">if</span> (klen <span style="color:#ff7b72;font-weight:700">&gt;</span> EVPOOL_CACHED_SDS_SIZE) {
</span></span><span style="display:flex"><span>            pool[k].key <span style="color:#ff7b72;font-weight:700">=</span> <span style="color:#d2a8ff;font-weight:700">sdsdup</span>(key);
</span></span><span style="display:flex"><span>        } <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex"><span>            <span style="color:#d2a8ff;font-weight:700">memcpy</span>(pool[k].cached,key,klen<span style="color:#ff7b72;font-weight:700">+</span><span style="color:#a5d6ff">1</span>);
</span></span><span style="display:flex"><span>            <span style="color:#d2a8ff;font-weight:700">sdssetlen</span>(pool[k].cached,klen);
</span></span><span style="display:flex"><span>            pool[k].key <span style="color:#ff7b72;font-weight:700">=</span> pool[k].cached;
</span></span><span style="display:flex"><span>        }
</span></span><span style="display:flex"><span>        pool[k].idle <span style="color:#ff7b72;font-weight:700">=</span> idle;
</span></span><span style="display:flex"><span>        pool[k].dbid <span style="color:#ff7b72;font-weight:700">=</span> dbid;
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p><a href="https://cloud.tencent.com/developer/article/1925123" rel="noopener" target="_blank">Redis的LRU缓存淘汰算法实现 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href="https://www.cnblogs.com/linxiyue/p/10955533.html" rel="noopener" target="_blank">Redis中的LFU算法 - 再见紫罗兰 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qq_41125219/article/details/120445829" rel="noopener" target="_blank">Redis精通系列——LFU算法详述(Least Frequently Used - 最不经常使用)_李子捌的博客-CSDN博客_lfu算法</a></p><p><a href="https://www.jianshu.com/p/c8aeb3eee6bc" rel="noopener" target="_blank">Redis的缓存淘汰策略LRU与LFU - 简书 (jianshu.com)</a></p><p><a href="https://www.cnblogs.com/hapjin/p/10933405.html" rel="noopener" target="_blank">Redis的LRU算法 - 演变历程详解 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/belongtocode/article/details/102989685" rel="noopener" target="_blank">全面讲解LRU算法_Apple_Web的博客-CSDN博客_lru 算法</a></p><p><a href="http://www.redis.cn/articles/20161114002.html" rel="noopener" target="_blank">由浅入深介绍 Redis LRU 策略的具体实现 – Redis中国用户组（CRUG）</a></p></div><footer class="post-footer"><ul class="post-tags"><li><a href="https://xiaokunji.com/zh/tags/Redis.html">Redis</a></li><li><a href="https://xiaokunji.com/zh/tags/%E7%BB%BC%E5%90%88.html">综合</a></li></ul><nav class="paginav"><a class="prev" href="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/%E4%B8%AA%E4%BA%BA%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7%E7%AF%87/python%E6%90%AD%E5%BB%BAidle%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/python%E6%90%AD%E5%BB%BAidle%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html"><span class="title">« 上一页</span><br/><span>python搭建idle开发环境</span>
</a><a class="next" href="https://xiaokunji.com/zh/%E7%BB%BC%E5%90%88/Redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><span class="title">下一页 »</span><br/><span>redis底层数据结构</span></a></nav></footer></article></main><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><footer class="footer"><span>Copyright
©
-2023
<a href="https://xiaokunji.com/zh/" style="color:#939393">米二</a>
All Rights Reserved
</span><span id="busuanzi_container"><span class="fa fa-user">用户数:</span><span id="busuanzi_value_site_uv"></span>
<span class="fa fa-eye">访问数:</span><span id="busuanzi_value_site_pv"></span></span></footer><a accesskey="g" aria-label="go to top" class="top-link" href="#top" id="top-link" title="Go to Top (Alt + G)"><svg fill="currentcolor" viewbox="0 0 12 6" xmlns="http://www.w3.org/2000/svg"><path d="M12 6H0l6-6z"></path></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>