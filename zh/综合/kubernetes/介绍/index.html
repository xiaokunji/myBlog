<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>介绍 | 米二</title><meta name=keywords content=" 一、Kubernetes是什么？, 二、Kubernetes解决了什么问题？, 三、kubernetes特点, 四、Kubernetes常用相关概念, 五、Kubernetes结构"><meta name=description content="     "><meta name=author content="xkj"><link rel=canonical href=https://xiaokunji.github.io/myBlog/zh/%E7%BB%BC%E5%90%88/kubernetes/%E4%BB%8B%E7%BB%8D/><link crossorigin=anonymous href=/myBlog/assets/css/stylesheet.a2492b1919558dad2b0783841b531329520921f957f354ded4c3fc4d21dcc77f.css integrity="sha256-okkrGRlVja0rB4OEG1MTKVIJIflX81Te1MP8TSHcx38=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/myBlog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaokunji.github.io/myBlog/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://xiaokunji.github.io/myBlog/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://xiaokunji.github.io/myBlog/img/Q.gif><link rel=apple-touch-icon href=https://xiaokunji.github.io/myBlog/Q.gif><link rel=mask-icon href=https://xiaokunji.github.io/myBlog/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://xiaokunji.github.io/myBlog/zh/%E7%BB%BC%E5%90%88/kubernetes/%E4%BB%8B%E7%BB%8D/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="介绍"><meta property="og:description" content="     "><meta property="og:type" content="article"><meta property="og:url" content="https://xiaokunji.github.io/myBlog/zh/%E7%BB%BC%E5%90%88/kubernetes/%E4%BB%8B%E7%BB%8D/"><meta property="article:section" content="综合"><meta property="article:published_time" content="2023-08-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="介绍"><meta name=twitter:description content="     "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":3,"name":"介绍","item":"https://xiaokunji.github.io/myBlog/zh/%E7%BB%BC%E5%90%88/kubernetes/%E4%BB%8B%E7%BB%8D/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"介绍","name":"介绍","description":"     ","keywords":[" 一、Kubernetes是什么？"," 二、Kubernetes解决了什么问题？"," 三、kubernetes特点"," 四、Kubernetes常用相关概念"," 五、Kubernetes结构"],"articleBody":"[toc]\n一、Kubernetes是什么？ 官方文档中描述为:\nKubernetes一个用于容器集群的自动化部署、扩容以及运维的开源平台。通过Kubernetes,你可以快速有效地响应用户需求;快速而有预期地部署你的应用;极速地扩展你的应用;无缝对接新应用功能;节省资源，优化硬件资源的使用。为容器编排管理提供了完整的开源方案。\n介绍一下其中提到的几个词:\n容器\n我们现在常说的容器一般是指Docker容器，通过容器隔离的特性和宿主机进行解耦，使我们的服务不需要依赖于宿主机而运行，与宿主机互不影响，Docker容器十分轻量。而kubernetes则负责管理服务中所有的Docker容器，创建、运行、重启与删除容器。\n快速响应\n个人理解为两个方面。\n一、新增或者修改需求时，可以快速进行部署测试(CICD)；\n二、kubernetes可以根据不同条件进行动态扩缩容，举个栗子，用户访问量突然由1000人上升到100000人时，现有的服务已经无法支撑，kubernetes会自动将用户服务模块增加更多实例以保证当前的系统访问量。\n扩展\n在快速响应的特点中已经有所提及，这里再补充一点: Kubernetes内部有完善的注册发现机制，当某个服务的实例增加时，kubernetes会自动将其加入服务列表中，免除在传统运维中需要人工维护服务列表的问题。\n对接新应用\nkubernetes是一个通用的容器编排框架，支持不同类型的语言，或者是语言无关的，新增加的应用都会以一个新的对象进行接入。\n硬件资源\n这一点我觉得是kubernetess很基本但是非常重要的一个优点了，kubernetes在部署应用时会自动检查各个服务器的cpu与内存使用量，同时会根据服务申请的cpu与内存资源，将服务部署到最合适的服务器。(其实这就是容器调度的核心功能了)\n小知识: 因kubernetes名字过长，一般简称为k8s，因为k与s之间有8个字母，故而称之。\n二、Kubernetes解决了什么问题？ 下面以几个case进行阐述，便于理解。\n服务器环境\nkubernetes是使用Docker进行容器管理的，所以天生具备Docker的所有特性，只需要使用相应环境的Docker镜像就可以运行服务，还需要关心宿主机是redhat、centos还是ubuntu，只要在宿主机上安装Docker环境即可，相比传统运维，减少了各种依赖环境的冲突，降低运维成本，也方便整体服务的迁移。\n服务器资源管理\n对于kubernetes来说，是不关心有几台服务器的，每个服务器都是一个资源对象(Node)，kubernetes关心的是这个Node上有多少可用的cpu和内存。例如现在有两台服务器\nserver01 (4c16g), 已用(2c7.5G)\nserver02 (4c16g), 已用(3c13G)\n现在有一个服务ServiceA需要部署，ServiceA申明自己运行需要至少3G内存，这时kubernetes会根据调度策略将其部署到server01上，很明显server01的资源是更加充足的。实际上kubernetes的调度策略要复杂的多，kubernetes会监控整体服务器资源的状态进行调度，而以前的运维方式只能由人工判断资源使用。\n服务容灾恢复\n说简单点，就是服务挂了之后，能够自动恢复。例如现在有一个ServiceA，运行在server01上，kubernetes会通过内部的kubelet组件监控ServiceA服务进程的状态，一旦发现进程丢失(服务本身挂掉或者整个server01的服务器挂掉)，就会尝试换一台资源充足的服务器重新部署ServiceA并启动，这样就可以确保我们的服务一直是可用状态，而不需要人工维护。\n硬件资源利用\n前面已经说过，kubernetes会根据节点(Node)的CPU与内存资源的可用量对服务进行部署调度，在调度策略中，可以配置不同的调度策略。例如现在有两台服务器：\nserver01 (4c16g), 已用(3c7.5G) server02 (4c16g), 已用(1c13G) 需要部署两个服务\nserviceA-Java, 申请2G内存，0.5CPU单位 ServiceB-Nginx, 申请200M内存,申请1CPU单位 这里kubernetes如果讲道理的话，会将ServiceA-Java部署到server01，将serviceB-Nginx部署到server02。这里server01的内存和server02的CPU资源都得到了充分的利用。经过个人实践，相比之前的部署方式，kubernetes节省了很多资源，资源利用是非常高效的。\n原文：https://blog.csdn.net/kingboyworld/article/details/80966107\n版本管理与滚动升级\n版本管理 kubernetes在部署服务时，会记录部署服务的版本，我们可以很容易的进行上次版本或跨版本回退。\n滚动升级 kubernetes在进行服务升级时，采用的默认策略是先将一部分新的服务启动，确定服务正常后，停止一部分旧服务，进行新老服务的替换，之后再启动一些新的服务，停止一部分旧服务，直到旧服务全部停止，即切换完成。滚动省级的过程中，极大的减少了服务切换的间隔时间。\n其它\n上面所说的是kubernetes的主体功能，kubernetes还有很多其他重要的特性解决了之前运维的痛点，例如DNS解析、自动负载、存储声明等等。\n原文：https://blog.csdn.net/kingboyworld/article/details/80966107\n三、kubernetes特点 网络模型\nkubernetes采用了三层网络模型，分为PodIP,ClusterIP,NodeIP。用简单的话来说，kubernetes在内部使用自己的网络进行通讯，这样做一个最直接的好处是我们不用再担心端口冲突的问题。\n举个栗子: 我们在server01上部署两个一样的服务serviceA-1,serviceA-2,两个服务的端口都是8080，这个时候有一个服务是无法启动的，因为端口被占用了，而在kubernetes中，两个服务在不同的Docker容器中,每个Docker容器都有自己的IP,这时就不会出现端口占用的问题了。\n为什么要有三层网络有三个IP呢？其实每个IP的作用是不一样的：\nNodeIP NodeIP是最好理解的，就是每个服务器的IP。例如server01的IP是192.168.1.2，有一个服务实例的IP申明类型为NodeIP，端口申明为30222,那么我们就可以通过192.168.1.2:30222访问到这个服务实例。\nPodIP PodIP的作用可以简单理解为每个服务自己特有的IP,就像上面说的可以解决端口冲突的问题，同时也是每个服务的唯一标识。PodIP是无法通过外网访问的，只能在服务内部进行访问。\nClusterIP(可以按照下面访问的进行理解，但实际有所区别) 中文叫集群IP。集群IP可以简单理解为是对同一个服务的多个实例(每个实例有自己的PodIP)组成的集群的入口IP，换句话说，是对多个实例的负载IP。举个栗子：\n有三个实例:\nserviceA-1 172.22.1.2 serviceA-2 172.22.1.3 serviceA-3 172.22.1.4 有一个ClusterIP 172.23.2.23指向了serviceA服务，那么我们访问172.23.2.23则会负载转向到172.22.1.2、172.22.1.3、172.22.1.4中的其中一个服务\n对象\n在kubernetes中，万物皆对象。路由(Ingress)、服务(Service)、部署(Deployment)、存储(Storage/PV/PVC)、容器(Pod)、角色(Role)、账户(Accoutn)、配置(ConfigMap)等等。通过管理这些对象来管理整个kubernetes集群。\n注意：此处说的服务(Service),不同于上文提到的服务(开发的项目模块)\n声名式管理\nkubernetes采用声名式进行资源管理，也就是从结果来看问题。举个栗子，现在需要部署十个ServiceA\n面向过程: 部署ServiceA-01,再部署ServiceA02…..ServiceA-10，强调的是过程，用代码来表示的话就是while(serviceA.count \u003c 10) {serviceA.count++}\n面向结果(声明式):不管是同时部署还是挨个部署，总之要部署十个ServiceA服务。用代码来表示的话就是kubernetes.addServiceA(10),不用管内部的细节怎么处理，只要最终的结果。\n四、Kubernetes常用相关概念 部署 - Deployment Deployment 的作用是管理和控制 Pod 和 ReplicaSet，管控它们运行在用户期望的状态中。哎，打个形象的比喻，Deployment 就是包工头，主要负责监督底下的工人 Pod 干活，确保每时每刻有用户要求数量的 Pod 在工作。如果一旦发现某个工人 Pod 不行了，就赶紧新拉一个 Pod 过来替换它。\nReplicaSets ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。ReplicaSet 的作用就是管理和控制 Pod，管控他们好好干活。但是，ReplicaSet 受控于 Deployment。形象来说，ReplicaSet 就是总包工头手下的小包工头。\n从 K8S 使用者角度来看，用户会直接操作 Deployment 部署服务，而当 Deployment 被部署的时候，K8S 会自动生成要求的 ReplicaSet 和 Pod。在**K8S 官方文档 中也指出用户只需要关心 Deployment 而不操心 ReplicaSet**：\nReplicationController\nReplicationController 确保在任何时候都有特定数量的 Pod 副本处于运行状态。 换句话说，ReplicationController 确保一个 Pod 或一组同类的 Pod 总是可用的。其实“ReplicationController 是 ReplicaSet 的前身”，官方也推荐用 Deployment 取代 ReplicationController 来部署服务。\n容器组 - Pod\nPod是Kubernetes中的最小管理单元，Pods和Docker中的容器可以理解为包含关系，在Pods中可以包含有多个Docker容器，例如有ServiceA和ServiceB,ServiceA高度依赖ServiceB(需要共享主机的相同文件),这时就可以将ServiceA与ServiceB放在同一个Pods中，当做一个整体来管理。如果分开部署当然也可以，不过会消耗额外的资源或者产生其他不必要的麻烦。例如我们的应用服务/redis等 都是pod\n服务 - Service Service是一个对象，并不是我们常说的“服务”的含义, 这个对象有自己的IP，也就是ClusterIP, 是若干个 Pod 的流量入口、流量均衡器。Service 是 K8S 服务的核心，屏蔽了服务细节，统一对外暴露服务接口，真正做到了“微服务”。举个例子，我们的一个服务 A，部署了 3 个备份，也就是 3 个 Pod；对于用户来说，只需要关注一个 Service 的入口就可以，而不需要操心究竟应该请求哪一个 Pod。优势非常明显：一方面外部用户不需要感知因为 Pod 上服务的意外崩溃、K8S 重新拉起 Pod 而造成的 IP 变更，外部用户也不需要感知因升级、变更服务带来的 Pod 替换而造成的 IP 变化，另一方面，Service 还可以做流量负载均衡。\n路由 - Ingress Ingress 是整个 K8S 集群的接入层，复杂集群内外通讯。无论是容器组还是Service，外网都是无法直接访问的，Ingress就可以通过一个负载IP与Kubernetes集群内部进行通讯，一般会和Service对象进行配合使用。\n配置项 - ConfigMap 简单理解为一个管理配置的对象，可以将项目的配置写入到ConfgiMap中，项目中的配置使用相应的变量名就可以读取相应的变量值。\nVolume 数据卷 K8S 支持很多类型的 volume 数据卷挂载，具体请参见**K8S 卷 **。前文就“如何理解 volume”提到：“需要手动 mount 的磁盘”，此外，有一点可以帮助理解：数据卷 volume 是 Pod 内部的磁盘资源。\nvolumeMounts volume 是 K8S 的对象，对应一个实体的数据卷；而 volumeMounts 只是 container 的挂载点，对应 container 的其中一个参数。但是，volumeMounts 依赖于 volume，只有当 Pod 内有 volume 资源的时候，该 Pod 内部的 container 才可能有 volumeMounts。\nContainer 容器 一个 Pod 内可以有多个容器 container。\n在 Pod 中，容器也有分类\n标准容器 Application Container。 初始化容器 Init Container。 边车容器 Sidecar Container。 临时容器 Ephemeral Container。 一般来说，我们部署的大多是标准容器（ Application Container）。\nnamespace 命名空间 和前文介绍的所有的概念都不一样，namespace 跟 Pod 没有直接关系，而是 K8S 另一个维度的对象。或者说，前文提到的概念都是为了服务 Pod 的，而 namespace 则是为了服务整个 K8S 集群的。\nKubernetes 支持多个虚拟集群，它们底层依赖于同一个物理集群。 这些虚拟集群被称为namespace 。\n比如我有 2 个业务 A 和 B，那么我可以创建 ns-a 和 ns-b 分别部署业务 A 和 B 的服务，如在 ns-a 中部署了一个 deployment，名字是 hello，返回用户的是“hello a”；在 ns-b 中也部署了一个 deployment，名字恰巧也是 hello，返回用户的是“hello b”（要知道，在同一个 namespace 下 deployment 不能同名；但是不同 namespace 之间没有影响）\n五、Kubernetes结构 Kubernetes由Master节点和Worker节点组成。master节点是Kubernetes的大脑，而woker节点则是kubernetes中实际运行服务的劳动者。\nMaster 主要由ETCD/Controller Manager/Api Server/Schedular能成，\nETCD 主要负责存储各个woker节点的状态和其它相关数据，可以理解为kubernetes的数据库。\nController Manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等, K8S 所有 Worker Node 的监控器。Controller Manager 有很多具体的 Controller。Controller 负责监控和调整在 Worker Node 上部署的服务的状态，比如用户要求 A 服务部署 2 个副本，那么当其中一个服务挂了的时候，Controller 会马上调整，让 Scheduler 再选择一个 Worker Node 重新部署服务。\nScheduler K8S 所有 Worker Node 的调度器, 负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上\nAPI Server。K8S 的请求入口服务\nAPI Server 负责接收 K8S 所有请求（来自 UI 界面或者 CLI 命令行工具），然后，API Server 根据用户的具体请求，去通知其他组件干活。\nWorker 主要由kubelet和kube-proxy组成，一般还会安装kube-dns组件。\nkubelet Worker Node 的监视器，以及与 Master Node 的通讯器, 负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；\nkube-proxy 负责为Service提供cluster内部的服务发现和负载均衡；\nkube-dns 负责为整个集群提供DNS服务，通过Service名称访问相应的服务\nContainer Runtime。\nWorker Node 的运行环境。即安装了容器化所需的软件环境确保容器化程序能够跑起来，比如 Docker Engine。大白话就是帮忙装好了 Docker 运行环境。\nLogging Layer。K8S 的监控状态收集器。\nLogging Layer 负责采集 Node 上所有服务的 CPU、内存、磁盘、网络等监控项信息。\nKubernetes 入门\u0026进阶实战 - 知乎 (zhihu.com) 最新、最全、最详细的 K8S 学习笔记总结（2021最新版） - 知乎 (zhihu.com) 一、Kubernetes简介-是什么？_KimZing的博客-CSDN博客 ","wordCount":"5997","inLanguage":"zh","datePublished":"2023-08-22T00:00:00Z","dateModified":"2023-08-22T00:00:00Z","author":{"@type":"Person","name":"xkj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaokunji.github.io/myBlog/zh/%E7%BB%BC%E5%90%88/kubernetes/%E4%BB%8B%E7%BB%8D/"},"publisher":{"@type":"Organization","name":"米二","logo":{"@type":"ImageObject","url":"https://xiaokunji.github.io/myBlog/img/Q.gif"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaokunji.github.io/myBlog/zh/ accesskey=h title="米二 (Alt + H)"><img src=https://xiaokunji.github.io/myBlog/img/Q.gif alt aria-label=logo height=35>米二</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaokunji.github.io/myBlog/en/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://xiaokunji.github.io/myBlog/zh/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://xiaokunji.github.io/myBlog/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://xiaokunji.github.io/myBlog/zh/post title=📚文章><span>📚文章</span></a></li><li><a href=https://xiaokunji.github.io/myBlog/zh/archives/ title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://xiaokunji.github.io/myBlog/zh/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://xiaokunji.github.io/myBlog/zh/categories title=📖分类><span>📖分类</span></a></li><li><a href=https://xiaokunji.github.io/myBlog/zh/links title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><nav aria-label=breadcrumb><ul><a href=https://xiaokunji.github.io/myBlog/zh/>content</a> <span>></span>
<a href=https://xiaokunji.github.io/myBlog/zh/%E7%BB%BC%E5%90%88/>综合</a> <span>></span>
<a href=https://xiaokunji.github.io/myBlog/zh/%E7%BB%BC%E5%90%88/kubernetes/>Kubernetes</a> <span>></span></ul></nav><h1 class=post-title>介绍</h1><div class=post-description></div><div class=post-meta><span title='2023-08-22 00:00:00 +0000 UTC'>2023-08-22</span>&nbsp;·&nbsp;12 分钟&nbsp;·&nbsp;xkj
&nbsp;|&nbsp;分类: &nbsp;<ul class=post-categories-meta><a href=https://xiaokunji.github.io/myBlog/zh/categories/%E7%BB%BC%E5%90%88/>综合</a></ul><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span id=busuanzi_container_page_pv>&nbsp;| 访问: <span id=busuanzi_value_page_pv></span></span>
<script src=https://cdn.staticfile.org/twikoo//twikoo.all.min.js></script><script>let url=document.documentURI,dnsUrl="https://xiaokunji.github.io/myBlog/",urlSplit=url.split(dnsUrl),finalUrl=urlSplit[1];finalUrl[0]!=="/"&&(finalUrl="/"+finalUrl),twikoo.getCommentsCount({envId:null,region:null,urls:[finalUrl],includeReply:!1}).then(function(e){let t=e[0].count;const n=document.getElementById("comment_count");n.innerText=t}).catch(function(e){console.error(e)})</script>&nbsp;| 评论: &nbsp; <span id=comment_count></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80kubernetes%e6%98%af%e4%bb%80%e4%b9%88 aria-label=一、Kubernetes是什么？>一、Kubernetes是什么？</a></li><li><a href=#%e4%ba%8ckubernetes%e8%a7%a3%e5%86%b3%e4%ba%86%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98 aria-label=二、Kubernetes解决了什么问题？>二、Kubernetes解决了什么问题？</a></li><li><a href=#%e4%b8%89kubernetes%e7%89%b9%e7%82%b9 aria-label=三、kubernetes特点>三、kubernetes特点</a></li><li><a href=#%e5%9b%9bkubernetes%e5%b8%b8%e7%94%a8%e7%9b%b8%e5%85%b3%e6%a6%82%e5%bf%b5 aria-label=四、Kubernetes常用相关概念>四、Kubernetes常用相关概念</a><ul><ul><li><a href=#container-%e5%ae%b9%e5%99%a8 aria-label="Container 容器"><strong>Container 容器</strong></a></li><li><a href=#namespace-%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4 aria-label="namespace 命名空间"><strong>namespace 命名空间</strong></a></li></ul></ul></li><li><a href=#%e4%ba%94kubernetes%e7%bb%93%e6%9e%84 aria-label=五、Kubernetes结构>五、Kubernetes结构</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>[toc]</p><h1 id=一kubernetes是什么>一、Kubernetes是什么？<a hidden class=anchor aria-hidden=true href=#一kubernetes是什么>#</a></h1><p>官方文档中描述为:</p><p>Kubernetes一个用于容器集群的自动化部署、扩容以及运维的开源平台。通过Kubernetes,你可以快速有效地响应用户需求;快速而有预期地部署你的应用;极速地扩展你的应用;无缝对接新应用功能;节省资源，优化硬件资源的使用。为容器编排管理提供了完整的开源方案。</p><p>介绍一下其中提到的几个词:</p><p><strong>容器</strong></p><p>我们现在常说的容器一般是指Docker容器，通过容器隔离的特性和宿主机进行解耦，使我们的服务不需要依赖于宿主机而运行，与宿主机互不影响，Docker容器十分轻量。而kubernetes则负责管理服务中所有的Docker容器，创建、运行、重启与删除容器。</p><p><strong>快速响应</strong></p><p>个人理解为两个方面。</p><p>一、新增或者修改需求时，可以快速进行部署测试(CICD)；</p><p>二、kubernetes可以根据不同条件进行动态扩缩容，举个栗子，用户访问量突然由1000人上升到100000人时，现有的服务已经无法支撑，kubernetes会自动将用户服务模块增加更多实例以保证当前的系统访问量。</p><p><strong>扩展</strong></p><p>在快速响应的特点中已经有所提及，这里再补充一点: Kubernetes内部有完善的注册发现机制，当某个服务的实例增加时，kubernetes会自动将其加入服务列表中，免除在传统运维中需要人工维护服务列表的问题。</p><p><strong>对接新应用</strong></p><p>kubernetes是一个通用的容器编排框架，支持不同类型的语言，或者是语言无关的，新增加的应用都会以一个新的对象进行接入。</p><p><strong>硬件资源</strong></p><p>这一点我觉得是kubernetess很基本但是非常重要的一个优点了，kubernetes在部署应用时会自动检查各个服务器的cpu与内存使用量，同时会根据服务申请的cpu与内存资源，将服务部署到最合适的服务器。(其实这就是容器调度的核心功能了)</p><blockquote><p>小知识: 因kubernetes名字过长，一般简称为k8s，因为k与s之间有8个字母，故而称之。</p></blockquote><h1 id=二kubernetes解决了什么问题>二、Kubernetes解决了什么问题？<a hidden class=anchor aria-hidden=true href=#二kubernetes解决了什么问题>#</a></h1><p>下面以几个case进行阐述，便于理解。</p><p><strong>服务器环境</strong></p><p>kubernetes是使用Docker进行容器管理的，所以天生具备Docker的所有特性，只需要使用相应环境的Docker镜像就可以运行服务，还需要关心宿主机是redhat、centos还是ubuntu，只要在宿主机上安装Docker环境即可，相比传统运维，减少了各种依赖环境的冲突，降低运维成本，也方便整体服务的迁移。</p><p><strong>服务器资源管理</strong></p><p>对于kubernetes来说，是不关心有几台服务器的，每个服务器都是一个资源对象(Node)，kubernetes关心的是这个Node上有多少可用的cpu和内存。例如现在有两台服务器</p><p>server01 (4c16g), 已用(2c7.5G)</p><p>server02 (4c16g), 已用(3c13G)</p><p>现在有一个服务ServiceA需要部署，ServiceA申明自己运行需要至少3G内存，这时kubernetes会根据调度策略将其部署到server01上，很明显server01的资源是更加充足的。实际上kubernetes的调度策略要复杂的多，kubernetes会监控整体服务器资源的状态进行调度，而以前的运维方式只能由人工判断资源使用。</p><p><strong>服务容灾恢复</strong></p><p>说简单点，就是服务挂了之后，能够自动恢复。例如现在有一个ServiceA，运行在server01上，kubernetes会通过内部的kubelet组件监控ServiceA服务进程的状态，一旦发现进程丢失(服务本身挂掉或者整个server01的服务器挂掉)，就会尝试换一台资源充足的服务器重新部署ServiceA并启动，这样就可以确保我们的服务一直是可用状态，而不需要人工维护。</p><p><strong>硬件资源利用</strong></p><p>前面已经说过，kubernetes会根据节点(Node)的CPU与内存资源的可用量对服务进行部署调度，在调度策略中，可以配置不同的调度策略。例如现在有两台服务器：</p><ul><li>server01 (4c16g), 已用(3c7.5G)</li><li>server02 (4c16g), 已用(1c13G)</li></ul><p>需要部署两个服务</p><ul><li>serviceA-Java, 申请2G内存，0.5CPU单位</li><li>ServiceB-Nginx, 申请200M内存,申请1CPU单位</li></ul><p>这里kubernetes如果讲道理的话，会将ServiceA-Java部署到server01，将serviceB-Nginx部署到server02。这里server01的内存和server02的CPU资源都得到了充分的利用。经过个人实践，相比之前的部署方式，kubernetes节省了很多资源，资源利用是非常高效的。</p><blockquote><p>原文：https://blog.csdn.net/kingboyworld/article/details/80966107</p></blockquote><p><strong>版本管理与滚动升级</strong></p><ul><li>版本管理</li></ul><p>kubernetes在部署服务时，会记录部署服务的版本，我们可以很容易的进行上次版本或跨版本回退。</p><ul><li>滚动升级</li></ul><p>kubernetes在进行服务升级时，采用的默认策略是先将一部分新的服务启动，确定服务正常后，停止一部分旧服务，进行新老服务的替换，之后再启动一些新的服务，停止一部分旧服务，直到旧服务全部停止，即切换完成。滚动省级的过程中，极大的减少了服务切换的间隔时间。</p><p><strong>其它</strong></p><p>上面所说的是kubernetes的主体功能，kubernetes还有很多其他重要的特性解决了之前运维的痛点，例如DNS解析、自动负载、存储声明等等。</p><blockquote><p>原文：https://blog.csdn.net/kingboyworld/article/details/80966107</p></blockquote><h1 id=三kubernetes特点>三、kubernetes特点<a hidden class=anchor aria-hidden=true href=#三kubernetes特点>#</a></h1><p><strong>网络模型</strong></p><p>kubernetes采用了三层网络模型，分为PodIP,ClusterIP,NodeIP。用简单的话来说，kubernetes在内部使用自己的网络进行通讯，这样做一个最直接的好处是我们不用再担心端口冲突的问题。</p><p>举个栗子: 我们在server01上部署两个一样的服务serviceA-1,serviceA-2,两个服务的端口都是8080，这个时候有一个服务是无法启动的，因为端口被占用了，而在kubernetes中，两个服务在不同的Docker容器中,每个Docker容器都有自己的IP,这时就不会出现端口占用的问题了。</p><p>为什么要有三层网络有三个IP呢？其实每个IP的作用是不一样的：</p><ul><li>NodeIP</li></ul><p>NodeIP是最好理解的，就是每个服务器的IP。例如server01的IP是192.168.1.2，有一个服务实例的IP申明类型为NodeIP，端口申明为30222,那么我们就可以通过192.168.1.2:30222访问到这个服务实例。</p><ul><li>PodIP</li></ul><p>PodIP的作用可以简单理解为每个服务自己特有的IP,就像上面说的可以解决端口冲突的问题，同时也是每个服务的唯一标识。PodIP是无法通过外网访问的，只能在服务内部进行访问。</p><ul><li>ClusterIP(可以按照下面访问的进行理解，但实际有所区别)</li></ul><p>中文叫集群IP。集群IP可以简单理解为是对同一个服务的多个实例(每个实例有自己的PodIP)组成的集群的入口IP，换句话说，是对多个实例的负载IP。举个栗子：</p><p>有三个实例:</p><ul><li>serviceA-1 172.22.1.2</li><li>serviceA-2 172.22.1.3</li><li>serviceA-3 172.22.1.4</li></ul><p>有一个ClusterIP 172.23.2.23指向了serviceA服务，那么我们访问172.23.2.23则会负载转向到172.22.1.2、172.22.1.3、172.22.1.4中的其中一个服务</p><p><strong>对象</strong></p><p>在kubernetes中，万物皆对象。路由(Ingress)、服务(Service)、部署(Deployment)、存储(Storage/PV/PVC)、容器(Pod)、角色(Role)、账户(Accoutn)、配置(ConfigMap)等等。通过管理这些对象来管理整个kubernetes集群。</p><blockquote><p>注意：此处说的服务(Service),不同于上文提到的服务(开发的项目模块)</p></blockquote><p><strong>声名式管理</strong></p><p>kubernetes采用声名式进行资源管理，也就是从结果来看问题。举个栗子，现在需要部署十个ServiceA</p><ul><li><p>面向过程: 部署ServiceA-01,再部署ServiceA02…..ServiceA-10，强调的是过程，用代码来表示的话就是while(serviceA.count &lt; 10) {serviceA.count++}</p></li><li><p>面向结果(声明式):不管是同时部署还是挨个部署，总之要部署十个ServiceA服务。用代码来表示的话就是kubernetes.addServiceA(10),不用管内部的细节怎么处理，只要最终的结果。</p></li></ul><h1 id=四kubernetes常用相关概念>四、Kubernetes常用相关概念<a hidden class=anchor aria-hidden=true href=#四kubernetes常用相关概念>#</a></h1><ol><li><strong>部署 - Deployment</strong></li></ol><p><strong>Deployment 的作用是管理和控制 Pod 和 ReplicaSet，管控它们运行在用户期望的状态中</strong>。哎，打个形象的比喻，<strong>Deployment 就是包工头</strong>，主要负责监督底下的工人 Pod 干活，确保每时每刻有用户要求数量的 Pod 在工作。如果一旦发现某个工人 Pod 不行了，就赶紧新拉一个 Pod 过来替换它。</p><ol start=2><li><strong>ReplicaSets</strong></li></ol><p>ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。ReplicaSet 的作用就是管理和控制 Pod，管控他们好好干活。但是，ReplicaSet 受控于 Deployment。形象来说，<strong>ReplicaSet 就是总包工头手下的小包工头</strong>。</p><p>从 K8S 使用者角度来看，用户会直接操作 Deployment 部署服务，而当 Deployment 被部署的时候，K8S 会自动生成要求的 ReplicaSet 和 Pod。在**<a href=https://www.kubernetes.org.cn/replicasets target=_blank rel=noopener>K8S 官方文档</a>
<strong>中也指出用户</strong>只需要关心 Deployment 而不操心 ReplicaSet**：</p><ol start=3><li><p><strong>ReplicationController</strong></p><p><em>ReplicationController</em> 确保在任何时候都有特定数量的 Pod 副本处于运行状态。 换句话说，ReplicationController 确保一个 Pod 或一组同类的 Pod 总是可用的。其实“ReplicationController 是 ReplicaSet 的前身”，官方也推荐用 Deployment 取代 ReplicationController 来部署服务。</p></li><li><p><strong>容器组 - Pod</strong></p></li></ol><p>Pod是Kubernetes中的最小管理单元，Pods和Docker中的容器可以理解为包含关系，在Pods中可以包含有多个Docker容器，例如有ServiceA和ServiceB,ServiceA高度依赖ServiceB(需要共享主机的相同文件),这时就可以将ServiceA与ServiceB放在同一个Pods中，当做一个整体来管理。如果分开部署当然也可以，不过会消耗额外的资源或者产生其他不必要的麻烦。例如我们的应用服务/redis等 都是pod</p><p><img loading=lazy src=.%5c%e4%bb%8b%e7%bb%8d.assets%0b2-7b1633cfca5e301706ffdaa064f38296_r.jpg alt=img></p><ol start=3><li><strong>服务 - Service</strong></li></ol><p>Service是一个对象，并不是我们常说的“服务”的含义, 这个对象有自己的IP，也就是ClusterIP, 是若干个 Pod 的流量入口、流量均衡器。<strong>Service 是 K8S 服务的核心，屏蔽了服务细节，统一对外暴露服务接口，真正做到了“微服务”</strong>。举个例子，我们的一个服务 A，部署了 3 个备份，也就是 3 个 Pod；对于用户来说，只需要关注一个 Service 的入口就可以，而不需要操心究竟应该请求哪一个 Pod。优势非常明显：<strong>一方面外部用户不需要感知因为 Pod 上服务的意外崩溃、K8S 重新拉起 Pod 而造成的 IP 变更，外部用户也不需要感知因升级、变更服务带来的 Pod 替换而造成的 IP 变化，另一方面，Service 还可以做流量负载均衡</strong>。</p><ol start=4><li><strong>路由 - Ingress</strong></li></ol><p>Ingress 是整个 K8S 集群的接入层，复杂集群内外通讯。无论是容器组还是Service，外网都是无法直接访问的，Ingress就可以通过一个负载IP与Kubernetes集群内部进行通讯，一般会和Service对象进行配合使用。</p><p><img loading=lazy src=.%5c%e4%bb%8b%e7%bb%8d.assets%0b2-3b8d0c22c4f2f6c4ed467811e91d3c4b_r.jpg alt=img></p><ol start=5><li><strong>配置项 - ConfigMap</strong></li></ol><p>简单理解为一个管理配置的对象，可以将项目的配置写入到ConfgiMap中，项目中的配置使用相应的变量名就可以读取相应的变量值。</p><ol start=6><li><strong>Volume 数据卷</strong></li></ol><p>K8S 支持很多类型的 volume 数据卷挂载，具体请参见**<a href=https://kubernetes.io/zh/docs/concepts/storage/volumes/ target=_blank rel=noopener>K8S 卷</a>
**。前文就“如何理解 volume”提到：“<strong>需要手动 mount 的磁盘</strong>”，此外，有一点可以帮助理解：<strong>数据卷 volume 是 Pod 内部的磁盘资源</strong>。</p><ol start=7><li><strong>volumeMounts</strong></li></ol><p><strong>volume 是 K8S 的对象，对应一个实体的数据卷；而 volumeMounts 只是 container 的挂载点，对应 container 的其中一个参数</strong>。但是，<strong>volumeMounts 依赖于 volume</strong>，只有当 Pod 内有 volume 资源的时候，该 Pod 内部的 container 才可能有 volumeMounts。</p><ol start=8><li><h3 id=container-容器><strong>Container 容器</strong><a hidden class=anchor aria-hidden=true href=#container-容器>#</a></h3><p><strong>一个 Pod 内可以有多个容器 container</strong>。</p><p>在 Pod 中，容器也有分类</p><ul><li><strong>标准容器 Application Container</strong>。</li><li><strong>初始化容器 Init Container</strong>。</li><li><strong>边车容器 Sidecar Container</strong>。</li><li><strong>临时容器 Ephemeral Container</strong>。</li></ul><p>一般来说，我们部署的大多是<strong>标准容器（ Application Container）</strong>。</p></li><li><h3 id=namespace-命名空间><strong>namespace 命名空间</strong><a hidden class=anchor aria-hidden=true href=#namespace-命名空间>#</a></h3><p>和前文介绍的所有的概念都不一样，namespace 跟 Pod 没有直接关系，而是 K8S 另一个维度的对象。或者说，前文提到的概念都是为了服务 Pod 的，而 namespace 则是为了服务整个 K8S 集群的。</p><p>Kubernetes 支持多个虚拟集群，它们底层依赖于同一个物理集群。 这些虚拟集群被称为namespace 。</p><blockquote><p>比如我有 2 个业务 A 和 B，那么我可以创建 ns-a 和 ns-b 分别部署业务 A 和 B 的服务，如在 ns-a 中部署了一个 deployment，名字是 hello，返回用户的是“hello a”；在 ns-b 中也部署了一个 deployment，名字恰巧也是 hello，返回用户的是“hello b”（要知道，在同一个 namespace 下 deployment 不能同名；但是不同 namespace 之间没有影响）</p></blockquote></li></ol><h1 id=五kubernetes结构>五、Kubernetes结构<a hidden class=anchor aria-hidden=true href=#五kubernetes结构>#</a></h1><p>Kubernetes由Master节点和Worker节点组成。<u>master节点是Kubernetes的大脑，而woker节点则是kubernetes中实际运行服务的劳动者。</u></p><p><strong>Master</strong> 主要由ETCD/Controller Manager/Api Server/Schedular能成，</p><ul><li><strong>ETCD</strong></li></ul><p>主要负责存储各个woker节点的状态和其它相关数据，可以理解为kubernetes的数据库。</p><ul><li><strong>Controller Manager</strong></li></ul><p>负责维护集群的状态，比如故障检测、自动扩展、滚动更新等, <strong>K8S 所有 Worker Node 的监控器</strong>。Controller Manager 有很多具体的 Controller。Controller 负责监控和调整在 Worker Node 上部署的服务的状态，比如用户要求 A 服务部署 2 个副本，那么当其中一个服务挂了的时候，Controller 会马上调整，让 Scheduler 再选择一个 Worker Node 重新部署服务。</p><ul><li><strong>Scheduler</strong></li></ul><p><strong>K8S 所有 Worker Node 的调度器</strong>, 负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上</p><ul><li><p><strong>API Server</strong>。<strong>K8S 的请求入口服务</strong></p><p>API Server 负责接收 K8S 所有请求（来自 UI 界面或者 CLI 命令行工具），然后，API Server 根据用户的具体请求，去通知其他组件干活。</p></li></ul><p><strong>Worker</strong> 主要由kubelet和kube-proxy组成，一般还会安装kube-dns组件。</p><ul><li><strong>kubelet</strong></li></ul><p><strong>Worker Node 的监视器，以及与 Master Node 的通讯器</strong>, 负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；</p><ul><li><strong>kube-proxy</strong></li></ul><p>负责为Service提供cluster内部的服务发现和负载均衡；</p><ul><li><strong>kube-dns</strong></li></ul><p>负责为整个集群提供DNS服务，通过Service名称访问相应的服务</p><ul><li><p><strong>Container Runtime</strong>。</p><p><strong>Worker Node 的运行环境</strong>。即安装了容器化所需的软件环境确保容器化程序能够跑起来，比如 Docker Engine。大白话就是帮忙装好了 Docker 运行环境。</p></li><li><p><strong>Logging Layer</strong>。<strong>K8S 的监控状态收集器</strong>。</p><p>Logging Layer 负责采集 Node 上所有服务的 CPU、内存、磁盘、网络等监控项信息。</p></li></ul><p><img loading=lazy src=.%5c%e4%bb%8b%e7%bb%8d.assets%5cimage-20230801181022701.png alt=image-20230801181022701></p><p><a href=https://zhuanlan.zhihu.com/p/339008746 target=_blank rel=noopener>Kubernetes 入门&进阶实战 - 知乎 (zhihu.com)</a></p><p><a href=https://zhuanlan.zhihu.com/p/365759073 target=_blank rel=noopener>最新、最全、最详细的 K8S 学习笔记总结（2021最新版） - 知乎 (zhihu.com)</a></p><p><a href=https://blog.csdn.net/kingboyworld/article/details/80966107 target=_blank rel=noopener>一、Kubernetes简介-是什么？_KimZing的博客-CSDN博客</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaokunji.github.io/myBlog/zh/tags/kubernetes/>Kubernetes</a></li><li><a href=https://xiaokunji.github.io/myBlog/zh/tags/%E7%BB%BC%E5%90%88/>综合</a></li></ul><nav class=paginav><a class=prev href=https://xiaokunji.github.io/myBlog/zh/%E7%BB%BC%E5%90%88/elk/%E4%BB%8B%E7%BB%8D/><span class=title>« 上一页</span><br><span>介绍</span></a>
<a class=next href=https://xiaokunji.github.io/myBlog/zh/%E7%BB%BC%E5%90%88/rocketmq/%E4%BB%8B%E7%BB%8D/><span class=title>下一页 »</span><br><span>介绍</span></a></nav></footer></article></main><footer class=footer><span>Copyright
&copy;
-2023
<a href=https://xiaokunji.github.io/myBlog/zh/ style=color:#939393>米二</a>
All Rights Reserved</span>
<span id=busuanzi_container><span class="fa fa-user">用户数:</span><span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye">访问数:</span><span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>